/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.Msg = (function() {

    /**
     * Namespace Msg.
     * @exports Msg
     * @namespace
     */
    var Msg = {};

    Msg.Any = (function() {

        /**
         * Properties of an Any.
         * @memberof Msg
         * @interface IAny
         * @property {string|null} [typeUrl] Any typeUrl
         * @property {Uint8Array|null} [value] Any value
         */

        /**
         * Constructs a new Any.
         * @memberof Msg
         * @classdesc Represents an Any.
         * @implements IAny
         * @constructor
         * @param {Msg.IAny=} [properties] Properties to set
         */
        function Any(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Any typeUrl.
         * @member {string} typeUrl
         * @memberof Msg.Any
         * @instance
         */
        Any.prototype.typeUrl = "";

        /**
         * Any value.
         * @member {Uint8Array} value
         * @memberof Msg.Any
         * @instance
         */
        Any.prototype.value = $util.newBuffer([]);

        /**
         * Creates a new Any instance using the specified properties.
         * @function create
         * @memberof Msg.Any
         * @static
         * @param {Msg.IAny=} [properties] Properties to set
         * @returns {Msg.Any} Any instance
         */
        Any.create = function create(properties) {
            return new Any(properties);
        };

        /**
         * Encodes the specified Any message. Does not implicitly {@link Msg.Any.verify|verify} messages.
         * @function encode
         * @memberof Msg.Any
         * @static
         * @param {Msg.IAny} message Any message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Any.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.typeUrl);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
            return writer;
        };

        /**
         * Encodes the specified Any message, length delimited. Does not implicitly {@link Msg.Any.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.Any
         * @static
         * @param {Msg.IAny} message Any message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Any.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Any message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.Any
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.Any} Any
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Any.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.Any();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeUrl = reader.string();
                    break;
                case 2:
                    message.value = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Any message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.Any
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.Any} Any
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Any.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Any message.
         * @function verify
         * @memberof Msg.Any
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Any.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                if (!$util.isString(message.typeUrl))
                    return "typeUrl: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                    return "value: buffer expected";
            return null;
        };

        /**
         * Creates an Any message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.Any
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.Any} Any
         */
        Any.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.Any)
                return object;
            var message = new $root.Msg.Any();
            if (object.typeUrl != null)
                message.typeUrl = String(object.typeUrl);
            if (object.value != null)
                if (typeof object.value === "string")
                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                else if (object.value.length)
                    message.value = object.value;
            return message;
        };

        /**
         * Creates a plain object from an Any message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.Any
         * @static
         * @param {Msg.Any} message Any
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Any.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.typeUrl = "";
                if (options.bytes === String)
                    object.value = "";
                else {
                    object.value = [];
                    if (options.bytes !== Array)
                        object.value = $util.newBuffer(object.value);
                }
            }
            if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                object.typeUrl = message.typeUrl;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
            return object;
        };

        /**
         * Converts this Any to JSON.
         * @function toJSON
         * @memberof Msg.Any
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Any.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Any;
    })();

    Msg.FinishedStatus = (function() {

        /**
         * Properties of a FinishedStatus.
         * @memberof Msg
         * @interface IFinishedStatus
         * @property {string|null} [id] FinishedStatus id
         * @property {number|Long|null} [grade] FinishedStatus grade
         */

        /**
         * Constructs a new FinishedStatus.
         * @memberof Msg
         * @classdesc Represents a FinishedStatus.
         * @implements IFinishedStatus
         * @constructor
         * @param {Msg.IFinishedStatus=} [properties] Properties to set
         */
        function FinishedStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FinishedStatus id.
         * @member {string} id
         * @memberof Msg.FinishedStatus
         * @instance
         */
        FinishedStatus.prototype.id = "";

        /**
         * FinishedStatus grade.
         * @member {number|Long} grade
         * @memberof Msg.FinishedStatus
         * @instance
         */
        FinishedStatus.prototype.grade = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new FinishedStatus instance using the specified properties.
         * @function create
         * @memberof Msg.FinishedStatus
         * @static
         * @param {Msg.IFinishedStatus=} [properties] Properties to set
         * @returns {Msg.FinishedStatus} FinishedStatus instance
         */
        FinishedStatus.create = function create(properties) {
            return new FinishedStatus(properties);
        };

        /**
         * Encodes the specified FinishedStatus message. Does not implicitly {@link Msg.FinishedStatus.verify|verify} messages.
         * @function encode
         * @memberof Msg.FinishedStatus
         * @static
         * @param {Msg.IFinishedStatus} message FinishedStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FinishedStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.grade != null && message.hasOwnProperty("grade"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.grade);
            return writer;
        };

        /**
         * Encodes the specified FinishedStatus message, length delimited. Does not implicitly {@link Msg.FinishedStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.FinishedStatus
         * @static
         * @param {Msg.IFinishedStatus} message FinishedStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FinishedStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FinishedStatus message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.FinishedStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.FinishedStatus} FinishedStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FinishedStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.FinishedStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.grade = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FinishedStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.FinishedStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.FinishedStatus} FinishedStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FinishedStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FinishedStatus message.
         * @function verify
         * @memberof Msg.FinishedStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FinishedStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.grade != null && message.hasOwnProperty("grade"))
                if (!$util.isInteger(message.grade) && !(message.grade && $util.isInteger(message.grade.low) && $util.isInteger(message.grade.high)))
                    return "grade: integer|Long expected";
            return null;
        };

        /**
         * Creates a FinishedStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.FinishedStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.FinishedStatus} FinishedStatus
         */
        FinishedStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.FinishedStatus)
                return object;
            var message = new $root.Msg.FinishedStatus();
            if (object.id != null)
                message.id = String(object.id);
            if (object.grade != null)
                if ($util.Long)
                    (message.grade = $util.Long.fromValue(object.grade)).unsigned = false;
                else if (typeof object.grade === "string")
                    message.grade = parseInt(object.grade, 10);
                else if (typeof object.grade === "number")
                    message.grade = object.grade;
                else if (typeof object.grade === "object")
                    message.grade = new $util.LongBits(object.grade.low >>> 0, object.grade.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a FinishedStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.FinishedStatus
         * @static
         * @param {Msg.FinishedStatus} message FinishedStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FinishedStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.grade = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.grade = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.grade != null && message.hasOwnProperty("grade"))
                if (typeof message.grade === "number")
                    object.grade = options.longs === String ? String(message.grade) : message.grade;
                else
                    object.grade = options.longs === String ? $util.Long.prototype.toString.call(message.grade) : options.longs === Number ? new $util.LongBits(message.grade.low >>> 0, message.grade.high >>> 0).toNumber() : message.grade;
            return object;
        };

        /**
         * Converts this FinishedStatus to JSON.
         * @function toJSON
         * @memberof Msg.FinishedStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FinishedStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FinishedStatus;
    })();

    Msg.Coordination = (function() {

        /**
         * Properties of a Coordination.
         * @memberof Msg
         * @interface ICoordination
         * @property {number|null} [X] Coordination X
         * @property {number|null} [Y] Coordination Y
         * @property {number|null} [Z] Coordination Z
         */

        /**
         * Constructs a new Coordination.
         * @memberof Msg
         * @classdesc Represents a Coordination.
         * @implements ICoordination
         * @constructor
         * @param {Msg.ICoordination=} [properties] Properties to set
         */
        function Coordination(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Coordination X.
         * @member {number} X
         * @memberof Msg.Coordination
         * @instance
         */
        Coordination.prototype.X = 0;

        /**
         * Coordination Y.
         * @member {number} Y
         * @memberof Msg.Coordination
         * @instance
         */
        Coordination.prototype.Y = 0;

        /**
         * Coordination Z.
         * @member {number} Z
         * @memberof Msg.Coordination
         * @instance
         */
        Coordination.prototype.Z = 0;

        /**
         * Creates a new Coordination instance using the specified properties.
         * @function create
         * @memberof Msg.Coordination
         * @static
         * @param {Msg.ICoordination=} [properties] Properties to set
         * @returns {Msg.Coordination} Coordination instance
         */
        Coordination.create = function create(properties) {
            return new Coordination(properties);
        };

        /**
         * Encodes the specified Coordination message. Does not implicitly {@link Msg.Coordination.verify|verify} messages.
         * @function encode
         * @memberof Msg.Coordination
         * @static
         * @param {Msg.ICoordination} message Coordination message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coordination.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.X != null && message.hasOwnProperty("X"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.X);
            if (message.Y != null && message.hasOwnProperty("Y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.Y);
            if (message.Z != null && message.hasOwnProperty("Z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.Z);
            return writer;
        };

        /**
         * Encodes the specified Coordination message, length delimited. Does not implicitly {@link Msg.Coordination.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.Coordination
         * @static
         * @param {Msg.ICoordination} message Coordination message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coordination.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Coordination message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.Coordination
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.Coordination} Coordination
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coordination.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.Coordination();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.X = reader.float();
                    break;
                case 2:
                    message.Y = reader.float();
                    break;
                case 3:
                    message.Z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Coordination message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.Coordination
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.Coordination} Coordination
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coordination.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Coordination message.
         * @function verify
         * @memberof Msg.Coordination
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Coordination.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.X != null && message.hasOwnProperty("X"))
                if (typeof message.X !== "number")
                    return "X: number expected";
            if (message.Y != null && message.hasOwnProperty("Y"))
                if (typeof message.Y !== "number")
                    return "Y: number expected";
            if (message.Z != null && message.hasOwnProperty("Z"))
                if (typeof message.Z !== "number")
                    return "Z: number expected";
            return null;
        };

        /**
         * Creates a Coordination message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.Coordination
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.Coordination} Coordination
         */
        Coordination.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.Coordination)
                return object;
            var message = new $root.Msg.Coordination();
            if (object.X != null)
                message.X = Number(object.X);
            if (object.Y != null)
                message.Y = Number(object.Y);
            if (object.Z != null)
                message.Z = Number(object.Z);
            return message;
        };

        /**
         * Creates a plain object from a Coordination message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.Coordination
         * @static
         * @param {Msg.Coordination} message Coordination
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Coordination.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.X = 0;
                object.Y = 0;
                object.Z = 0;
            }
            if (message.X != null && message.hasOwnProperty("X"))
                object.X = options.json && !isFinite(message.X) ? String(message.X) : message.X;
            if (message.Y != null && message.hasOwnProperty("Y"))
                object.Y = options.json && !isFinite(message.Y) ? String(message.Y) : message.Y;
            if (message.Z != null && message.hasOwnProperty("Z"))
                object.Z = options.json && !isFinite(message.Z) ? String(message.Z) : message.Z;
            return object;
        };

        /**
         * Converts this Coordination to JSON.
         * @function toJSON
         * @memberof Msg.Coordination
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Coordination.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Coordination;
    })();

    Msg.PlayerAttribute = (function() {

        /**
         * Properties of a PlayerAttribute.
         * @memberof Msg
         * @interface IPlayerAttribute
         * @property {string|null} [nickname] PlayerAttribute nickname
         * @property {string|null} [url] PlayerAttribute url
         * @property {number|Long|null} [diamond] PlayerAttribute diamond
         * @property {number|Long|null} [gold] PlayerAttribute gold
         * @property {number|Long|null} [exp] PlayerAttribute exp
         * @property {number|Long|null} [expLimit] PlayerAttribute expLimit
         * @property {number|Long|null} [level] PlayerAttribute level
         * @property {number|Long|null} [strength] PlayerAttribute strength
         * @property {number|Long|null} [strengthLimit] PlayerAttribute strengthLimit
         * @property {number|Long|null} [nextUpdate] PlayerAttribute nextUpdate
         * @property {string|null} [id] PlayerAttribute id
         * @property {number|Long|null} [cup] PlayerAttribute cup
         * @property {Array.<number|Long>|null} [fashion] PlayerAttribute fashion
         * @property {Array.<number|Long>|null} [weapon] PlayerAttribute weapon
         */

        /**
         * Constructs a new PlayerAttribute.
         * @memberof Msg
         * @classdesc Represents a PlayerAttribute.
         * @implements IPlayerAttribute
         * @constructor
         * @param {Msg.IPlayerAttribute=} [properties] Properties to set
         */
        function PlayerAttribute(properties) {
            this.fashion = [];
            this.weapon = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayerAttribute nickname.
         * @member {string} nickname
         * @memberof Msg.PlayerAttribute
         * @instance
         */
        PlayerAttribute.prototype.nickname = "";

        /**
         * PlayerAttribute url.
         * @member {string} url
         * @memberof Msg.PlayerAttribute
         * @instance
         */
        PlayerAttribute.prototype.url = "";

        /**
         * PlayerAttribute diamond.
         * @member {number|Long} diamond
         * @memberof Msg.PlayerAttribute
         * @instance
         */
        PlayerAttribute.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PlayerAttribute gold.
         * @member {number|Long} gold
         * @memberof Msg.PlayerAttribute
         * @instance
         */
        PlayerAttribute.prototype.gold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PlayerAttribute exp.
         * @member {number|Long} exp
         * @memberof Msg.PlayerAttribute
         * @instance
         */
        PlayerAttribute.prototype.exp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PlayerAttribute expLimit.
         * @member {number|Long} expLimit
         * @memberof Msg.PlayerAttribute
         * @instance
         */
        PlayerAttribute.prototype.expLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PlayerAttribute level.
         * @member {number|Long} level
         * @memberof Msg.PlayerAttribute
         * @instance
         */
        PlayerAttribute.prototype.level = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PlayerAttribute strength.
         * @member {number|Long} strength
         * @memberof Msg.PlayerAttribute
         * @instance
         */
        PlayerAttribute.prototype.strength = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PlayerAttribute strengthLimit.
         * @member {number|Long} strengthLimit
         * @memberof Msg.PlayerAttribute
         * @instance
         */
        PlayerAttribute.prototype.strengthLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PlayerAttribute nextUpdate.
         * @member {number|Long} nextUpdate
         * @memberof Msg.PlayerAttribute
         * @instance
         */
        PlayerAttribute.prototype.nextUpdate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PlayerAttribute id.
         * @member {string} id
         * @memberof Msg.PlayerAttribute
         * @instance
         */
        PlayerAttribute.prototype.id = "";

        /**
         * PlayerAttribute cup.
         * @member {number|Long} cup
         * @memberof Msg.PlayerAttribute
         * @instance
         */
        PlayerAttribute.prototype.cup = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PlayerAttribute fashion.
         * @member {Array.<number|Long>} fashion
         * @memberof Msg.PlayerAttribute
         * @instance
         */
        PlayerAttribute.prototype.fashion = $util.emptyArray;

        /**
         * PlayerAttribute weapon.
         * @member {Array.<number|Long>} weapon
         * @memberof Msg.PlayerAttribute
         * @instance
         */
        PlayerAttribute.prototype.weapon = $util.emptyArray;

        /**
         * Creates a new PlayerAttribute instance using the specified properties.
         * @function create
         * @memberof Msg.PlayerAttribute
         * @static
         * @param {Msg.IPlayerAttribute=} [properties] Properties to set
         * @returns {Msg.PlayerAttribute} PlayerAttribute instance
         */
        PlayerAttribute.create = function create(properties) {
            return new PlayerAttribute(properties);
        };

        /**
         * Encodes the specified PlayerAttribute message. Does not implicitly {@link Msg.PlayerAttribute.verify|verify} messages.
         * @function encode
         * @memberof Msg.PlayerAttribute
         * @static
         * @param {Msg.IPlayerAttribute} message PlayerAttribute message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerAttribute.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.nickname);
            if (message.url != null && message.hasOwnProperty("url"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
            if (message.diamond != null && message.hasOwnProperty("diamond"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.diamond);
            if (message.gold != null && message.hasOwnProperty("gold"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.gold);
            if (message.exp != null && message.hasOwnProperty("exp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.exp);
            if (message.expLimit != null && message.hasOwnProperty("expLimit"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.expLimit);
            if (message.level != null && message.hasOwnProperty("level"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.level);
            if (message.strength != null && message.hasOwnProperty("strength"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.strength);
            if (message.strengthLimit != null && message.hasOwnProperty("strengthLimit"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.strengthLimit);
            if (message.nextUpdate != null && message.hasOwnProperty("nextUpdate"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.nextUpdate);
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.id);
            if (message.cup != null && message.hasOwnProperty("cup"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.cup);
            if (message.fashion != null && message.fashion.length) {
                writer.uint32(/* id 13, wireType 2 =*/106).fork();
                for (var i = 0; i < message.fashion.length; ++i)
                    writer.int64(message.fashion[i]);
                writer.ldelim();
            }
            if (message.weapon != null && message.weapon.length) {
                writer.uint32(/* id 14, wireType 2 =*/114).fork();
                for (var i = 0; i < message.weapon.length; ++i)
                    writer.int64(message.weapon[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified PlayerAttribute message, length delimited. Does not implicitly {@link Msg.PlayerAttribute.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PlayerAttribute
         * @static
         * @param {Msg.IPlayerAttribute} message PlayerAttribute message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerAttribute.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayerAttribute message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PlayerAttribute
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PlayerAttribute} PlayerAttribute
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerAttribute.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PlayerAttribute();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nickname = reader.string();
                    break;
                case 2:
                    message.url = reader.string();
                    break;
                case 3:
                    message.diamond = reader.int64();
                    break;
                case 4:
                    message.gold = reader.int64();
                    break;
                case 5:
                    message.exp = reader.int64();
                    break;
                case 6:
                    message.expLimit = reader.int64();
                    break;
                case 7:
                    message.level = reader.int64();
                    break;
                case 8:
                    message.strength = reader.int64();
                    break;
                case 9:
                    message.strengthLimit = reader.int64();
                    break;
                case 10:
                    message.nextUpdate = reader.int64();
                    break;
                case 11:
                    message.id = reader.string();
                    break;
                case 12:
                    message.cup = reader.int64();
                    break;
                case 13:
                    if (!(message.fashion && message.fashion.length))
                        message.fashion = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.fashion.push(reader.int64());
                    } else
                        message.fashion.push(reader.int64());
                    break;
                case 14:
                    if (!(message.weapon && message.weapon.length))
                        message.weapon = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.weapon.push(reader.int64());
                    } else
                        message.weapon.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayerAttribute message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PlayerAttribute
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PlayerAttribute} PlayerAttribute
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerAttribute.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayerAttribute message.
         * @function verify
         * @memberof Msg.PlayerAttribute
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerAttribute.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                if (!$util.isString(message.nickname))
                    return "nickname: string expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.diamond != null && message.hasOwnProperty("diamond"))
                if (!$util.isInteger(message.diamond) && !(message.diamond && $util.isInteger(message.diamond.low) && $util.isInteger(message.diamond.high)))
                    return "diamond: integer|Long expected";
            if (message.gold != null && message.hasOwnProperty("gold"))
                if (!$util.isInteger(message.gold) && !(message.gold && $util.isInteger(message.gold.low) && $util.isInteger(message.gold.high)))
                    return "gold: integer|Long expected";
            if (message.exp != null && message.hasOwnProperty("exp"))
                if (!$util.isInteger(message.exp) && !(message.exp && $util.isInteger(message.exp.low) && $util.isInteger(message.exp.high)))
                    return "exp: integer|Long expected";
            if (message.expLimit != null && message.hasOwnProperty("expLimit"))
                if (!$util.isInteger(message.expLimit) && !(message.expLimit && $util.isInteger(message.expLimit.low) && $util.isInteger(message.expLimit.high)))
                    return "expLimit: integer|Long expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level) && !(message.level && $util.isInteger(message.level.low) && $util.isInteger(message.level.high)))
                    return "level: integer|Long expected";
            if (message.strength != null && message.hasOwnProperty("strength"))
                if (!$util.isInteger(message.strength) && !(message.strength && $util.isInteger(message.strength.low) && $util.isInteger(message.strength.high)))
                    return "strength: integer|Long expected";
            if (message.strengthLimit != null && message.hasOwnProperty("strengthLimit"))
                if (!$util.isInteger(message.strengthLimit) && !(message.strengthLimit && $util.isInteger(message.strengthLimit.low) && $util.isInteger(message.strengthLimit.high)))
                    return "strengthLimit: integer|Long expected";
            if (message.nextUpdate != null && message.hasOwnProperty("nextUpdate"))
                if (!$util.isInteger(message.nextUpdate) && !(message.nextUpdate && $util.isInteger(message.nextUpdate.low) && $util.isInteger(message.nextUpdate.high)))
                    return "nextUpdate: integer|Long expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.cup != null && message.hasOwnProperty("cup"))
                if (!$util.isInteger(message.cup) && !(message.cup && $util.isInteger(message.cup.low) && $util.isInteger(message.cup.high)))
                    return "cup: integer|Long expected";
            if (message.fashion != null && message.hasOwnProperty("fashion")) {
                if (!Array.isArray(message.fashion))
                    return "fashion: array expected";
                for (var i = 0; i < message.fashion.length; ++i)
                    if (!$util.isInteger(message.fashion[i]) && !(message.fashion[i] && $util.isInteger(message.fashion[i].low) && $util.isInteger(message.fashion[i].high)))
                        return "fashion: integer|Long[] expected";
            }
            if (message.weapon != null && message.hasOwnProperty("weapon")) {
                if (!Array.isArray(message.weapon))
                    return "weapon: array expected";
                for (var i = 0; i < message.weapon.length; ++i)
                    if (!$util.isInteger(message.weapon[i]) && !(message.weapon[i] && $util.isInteger(message.weapon[i].low) && $util.isInteger(message.weapon[i].high)))
                        return "weapon: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a PlayerAttribute message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PlayerAttribute
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PlayerAttribute} PlayerAttribute
         */
        PlayerAttribute.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PlayerAttribute)
                return object;
            var message = new $root.Msg.PlayerAttribute();
            if (object.nickname != null)
                message.nickname = String(object.nickname);
            if (object.url != null)
                message.url = String(object.url);
            if (object.diamond != null)
                if ($util.Long)
                    (message.diamond = $util.Long.fromValue(object.diamond)).unsigned = false;
                else if (typeof object.diamond === "string")
                    message.diamond = parseInt(object.diamond, 10);
                else if (typeof object.diamond === "number")
                    message.diamond = object.diamond;
                else if (typeof object.diamond === "object")
                    message.diamond = new $util.LongBits(object.diamond.low >>> 0, object.diamond.high >>> 0).toNumber();
            if (object.gold != null)
                if ($util.Long)
                    (message.gold = $util.Long.fromValue(object.gold)).unsigned = false;
                else if (typeof object.gold === "string")
                    message.gold = parseInt(object.gold, 10);
                else if (typeof object.gold === "number")
                    message.gold = object.gold;
                else if (typeof object.gold === "object")
                    message.gold = new $util.LongBits(object.gold.low >>> 0, object.gold.high >>> 0).toNumber();
            if (object.exp != null)
                if ($util.Long)
                    (message.exp = $util.Long.fromValue(object.exp)).unsigned = false;
                else if (typeof object.exp === "string")
                    message.exp = parseInt(object.exp, 10);
                else if (typeof object.exp === "number")
                    message.exp = object.exp;
                else if (typeof object.exp === "object")
                    message.exp = new $util.LongBits(object.exp.low >>> 0, object.exp.high >>> 0).toNumber();
            if (object.expLimit != null)
                if ($util.Long)
                    (message.expLimit = $util.Long.fromValue(object.expLimit)).unsigned = false;
                else if (typeof object.expLimit === "string")
                    message.expLimit = parseInt(object.expLimit, 10);
                else if (typeof object.expLimit === "number")
                    message.expLimit = object.expLimit;
                else if (typeof object.expLimit === "object")
                    message.expLimit = new $util.LongBits(object.expLimit.low >>> 0, object.expLimit.high >>> 0).toNumber();
            if (object.level != null)
                if ($util.Long)
                    (message.level = $util.Long.fromValue(object.level)).unsigned = false;
                else if (typeof object.level === "string")
                    message.level = parseInt(object.level, 10);
                else if (typeof object.level === "number")
                    message.level = object.level;
                else if (typeof object.level === "object")
                    message.level = new $util.LongBits(object.level.low >>> 0, object.level.high >>> 0).toNumber();
            if (object.strength != null)
                if ($util.Long)
                    (message.strength = $util.Long.fromValue(object.strength)).unsigned = false;
                else if (typeof object.strength === "string")
                    message.strength = parseInt(object.strength, 10);
                else if (typeof object.strength === "number")
                    message.strength = object.strength;
                else if (typeof object.strength === "object")
                    message.strength = new $util.LongBits(object.strength.low >>> 0, object.strength.high >>> 0).toNumber();
            if (object.strengthLimit != null)
                if ($util.Long)
                    (message.strengthLimit = $util.Long.fromValue(object.strengthLimit)).unsigned = false;
                else if (typeof object.strengthLimit === "string")
                    message.strengthLimit = parseInt(object.strengthLimit, 10);
                else if (typeof object.strengthLimit === "number")
                    message.strengthLimit = object.strengthLimit;
                else if (typeof object.strengthLimit === "object")
                    message.strengthLimit = new $util.LongBits(object.strengthLimit.low >>> 0, object.strengthLimit.high >>> 0).toNumber();
            if (object.nextUpdate != null)
                if ($util.Long)
                    (message.nextUpdate = $util.Long.fromValue(object.nextUpdate)).unsigned = false;
                else if (typeof object.nextUpdate === "string")
                    message.nextUpdate = parseInt(object.nextUpdate, 10);
                else if (typeof object.nextUpdate === "number")
                    message.nextUpdate = object.nextUpdate;
                else if (typeof object.nextUpdate === "object")
                    message.nextUpdate = new $util.LongBits(object.nextUpdate.low >>> 0, object.nextUpdate.high >>> 0).toNumber();
            if (object.id != null)
                message.id = String(object.id);
            if (object.cup != null)
                if ($util.Long)
                    (message.cup = $util.Long.fromValue(object.cup)).unsigned = false;
                else if (typeof object.cup === "string")
                    message.cup = parseInt(object.cup, 10);
                else if (typeof object.cup === "number")
                    message.cup = object.cup;
                else if (typeof object.cup === "object")
                    message.cup = new $util.LongBits(object.cup.low >>> 0, object.cup.high >>> 0).toNumber();
            if (object.fashion) {
                if (!Array.isArray(object.fashion))
                    throw TypeError(".Msg.PlayerAttribute.fashion: array expected");
                message.fashion = [];
                for (var i = 0; i < object.fashion.length; ++i)
                    if ($util.Long)
                        (message.fashion[i] = $util.Long.fromValue(object.fashion[i])).unsigned = false;
                    else if (typeof object.fashion[i] === "string")
                        message.fashion[i] = parseInt(object.fashion[i], 10);
                    else if (typeof object.fashion[i] === "number")
                        message.fashion[i] = object.fashion[i];
                    else if (typeof object.fashion[i] === "object")
                        message.fashion[i] = new $util.LongBits(object.fashion[i].low >>> 0, object.fashion[i].high >>> 0).toNumber();
            }
            if (object.weapon) {
                if (!Array.isArray(object.weapon))
                    throw TypeError(".Msg.PlayerAttribute.weapon: array expected");
                message.weapon = [];
                for (var i = 0; i < object.weapon.length; ++i)
                    if ($util.Long)
                        (message.weapon[i] = $util.Long.fromValue(object.weapon[i])).unsigned = false;
                    else if (typeof object.weapon[i] === "string")
                        message.weapon[i] = parseInt(object.weapon[i], 10);
                    else if (typeof object.weapon[i] === "number")
                        message.weapon[i] = object.weapon[i];
                    else if (typeof object.weapon[i] === "object")
                        message.weapon[i] = new $util.LongBits(object.weapon[i].low >>> 0, object.weapon[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a PlayerAttribute message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PlayerAttribute
         * @static
         * @param {Msg.PlayerAttribute} message PlayerAttribute
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerAttribute.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.fashion = [];
                object.weapon = [];
            }
            if (options.defaults) {
                object.nickname = "";
                object.url = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.diamond = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.diamond = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.gold = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gold = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expLimit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.level = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.level = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.strength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.strength = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.strengthLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.strengthLimit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.nextUpdate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nextUpdate = options.longs === String ? "0" : 0;
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.cup = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.cup = options.longs === String ? "0" : 0;
            }
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                object.nickname = message.nickname;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.diamond != null && message.hasOwnProperty("diamond"))
                if (typeof message.diamond === "number")
                    object.diamond = options.longs === String ? String(message.diamond) : message.diamond;
                else
                    object.diamond = options.longs === String ? $util.Long.prototype.toString.call(message.diamond) : options.longs === Number ? new $util.LongBits(message.diamond.low >>> 0, message.diamond.high >>> 0).toNumber() : message.diamond;
            if (message.gold != null && message.hasOwnProperty("gold"))
                if (typeof message.gold === "number")
                    object.gold = options.longs === String ? String(message.gold) : message.gold;
                else
                    object.gold = options.longs === String ? $util.Long.prototype.toString.call(message.gold) : options.longs === Number ? new $util.LongBits(message.gold.low >>> 0, message.gold.high >>> 0).toNumber() : message.gold;
            if (message.exp != null && message.hasOwnProperty("exp"))
                if (typeof message.exp === "number")
                    object.exp = options.longs === String ? String(message.exp) : message.exp;
                else
                    object.exp = options.longs === String ? $util.Long.prototype.toString.call(message.exp) : options.longs === Number ? new $util.LongBits(message.exp.low >>> 0, message.exp.high >>> 0).toNumber() : message.exp;
            if (message.expLimit != null && message.hasOwnProperty("expLimit"))
                if (typeof message.expLimit === "number")
                    object.expLimit = options.longs === String ? String(message.expLimit) : message.expLimit;
                else
                    object.expLimit = options.longs === String ? $util.Long.prototype.toString.call(message.expLimit) : options.longs === Number ? new $util.LongBits(message.expLimit.low >>> 0, message.expLimit.high >>> 0).toNumber() : message.expLimit;
            if (message.level != null && message.hasOwnProperty("level"))
                if (typeof message.level === "number")
                    object.level = options.longs === String ? String(message.level) : message.level;
                else
                    object.level = options.longs === String ? $util.Long.prototype.toString.call(message.level) : options.longs === Number ? new $util.LongBits(message.level.low >>> 0, message.level.high >>> 0).toNumber() : message.level;
            if (message.strength != null && message.hasOwnProperty("strength"))
                if (typeof message.strength === "number")
                    object.strength = options.longs === String ? String(message.strength) : message.strength;
                else
                    object.strength = options.longs === String ? $util.Long.prototype.toString.call(message.strength) : options.longs === Number ? new $util.LongBits(message.strength.low >>> 0, message.strength.high >>> 0).toNumber() : message.strength;
            if (message.strengthLimit != null && message.hasOwnProperty("strengthLimit"))
                if (typeof message.strengthLimit === "number")
                    object.strengthLimit = options.longs === String ? String(message.strengthLimit) : message.strengthLimit;
                else
                    object.strengthLimit = options.longs === String ? $util.Long.prototype.toString.call(message.strengthLimit) : options.longs === Number ? new $util.LongBits(message.strengthLimit.low >>> 0, message.strengthLimit.high >>> 0).toNumber() : message.strengthLimit;
            if (message.nextUpdate != null && message.hasOwnProperty("nextUpdate"))
                if (typeof message.nextUpdate === "number")
                    object.nextUpdate = options.longs === String ? String(message.nextUpdate) : message.nextUpdate;
                else
                    object.nextUpdate = options.longs === String ? $util.Long.prototype.toString.call(message.nextUpdate) : options.longs === Number ? new $util.LongBits(message.nextUpdate.low >>> 0, message.nextUpdate.high >>> 0).toNumber() : message.nextUpdate;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.cup != null && message.hasOwnProperty("cup"))
                if (typeof message.cup === "number")
                    object.cup = options.longs === String ? String(message.cup) : message.cup;
                else
                    object.cup = options.longs === String ? $util.Long.prototype.toString.call(message.cup) : options.longs === Number ? new $util.LongBits(message.cup.low >>> 0, message.cup.high >>> 0).toNumber() : message.cup;
            if (message.fashion && message.fashion.length) {
                object.fashion = [];
                for (var j = 0; j < message.fashion.length; ++j)
                    if (typeof message.fashion[j] === "number")
                        object.fashion[j] = options.longs === String ? String(message.fashion[j]) : message.fashion[j];
                    else
                        object.fashion[j] = options.longs === String ? $util.Long.prototype.toString.call(message.fashion[j]) : options.longs === Number ? new $util.LongBits(message.fashion[j].low >>> 0, message.fashion[j].high >>> 0).toNumber() : message.fashion[j];
            }
            if (message.weapon && message.weapon.length) {
                object.weapon = [];
                for (var j = 0; j < message.weapon.length; ++j)
                    if (typeof message.weapon[j] === "number")
                        object.weapon[j] = options.longs === String ? String(message.weapon[j]) : message.weapon[j];
                    else
                        object.weapon[j] = options.longs === String ? $util.Long.prototype.toString.call(message.weapon[j]) : options.longs === Number ? new $util.LongBits(message.weapon[j].low >>> 0, message.weapon[j].high >>> 0).toNumber() : message.weapon[j];
            }
            return object;
        };

        /**
         * Converts this PlayerAttribute to JSON.
         * @function toJSON
         * @memberof Msg.PlayerAttribute
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerAttribute.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlayerAttribute;
    })();

    Msg.Process = (function() {

        /**
         * Properties of a Process.
         * @memberof Msg
         * @interface IProcess
         * @property {number|Long|null} [level] Process level
         * @property {number|Long|null} [grade] Process grade
         */

        /**
         * Constructs a new Process.
         * @memberof Msg
         * @classdesc Represents a Process.
         * @implements IProcess
         * @constructor
         * @param {Msg.IProcess=} [properties] Properties to set
         */
        function Process(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Process level.
         * @member {number|Long} level
         * @memberof Msg.Process
         * @instance
         */
        Process.prototype.level = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Process grade.
         * @member {number|Long} grade
         * @memberof Msg.Process
         * @instance
         */
        Process.prototype.grade = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Process instance using the specified properties.
         * @function create
         * @memberof Msg.Process
         * @static
         * @param {Msg.IProcess=} [properties] Properties to set
         * @returns {Msg.Process} Process instance
         */
        Process.create = function create(properties) {
            return new Process(properties);
        };

        /**
         * Encodes the specified Process message. Does not implicitly {@link Msg.Process.verify|verify} messages.
         * @function encode
         * @memberof Msg.Process
         * @static
         * @param {Msg.IProcess} message Process message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Process.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.level != null && message.hasOwnProperty("level"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.level);
            if (message.grade != null && message.hasOwnProperty("grade"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.grade);
            return writer;
        };

        /**
         * Encodes the specified Process message, length delimited. Does not implicitly {@link Msg.Process.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.Process
         * @static
         * @param {Msg.IProcess} message Process message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Process.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Process message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.Process
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.Process} Process
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Process.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.Process();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.level = reader.int64();
                    break;
                case 2:
                    message.grade = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Process message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.Process
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.Process} Process
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Process.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Process message.
         * @function verify
         * @memberof Msg.Process
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Process.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level) && !(message.level && $util.isInteger(message.level.low) && $util.isInteger(message.level.high)))
                    return "level: integer|Long expected";
            if (message.grade != null && message.hasOwnProperty("grade"))
                if (!$util.isInteger(message.grade) && !(message.grade && $util.isInteger(message.grade.low) && $util.isInteger(message.grade.high)))
                    return "grade: integer|Long expected";
            return null;
        };

        /**
         * Creates a Process message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.Process
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.Process} Process
         */
        Process.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.Process)
                return object;
            var message = new $root.Msg.Process();
            if (object.level != null)
                if ($util.Long)
                    (message.level = $util.Long.fromValue(object.level)).unsigned = false;
                else if (typeof object.level === "string")
                    message.level = parseInt(object.level, 10);
                else if (typeof object.level === "number")
                    message.level = object.level;
                else if (typeof object.level === "object")
                    message.level = new $util.LongBits(object.level.low >>> 0, object.level.high >>> 0).toNumber();
            if (object.grade != null)
                if ($util.Long)
                    (message.grade = $util.Long.fromValue(object.grade)).unsigned = false;
                else if (typeof object.grade === "string")
                    message.grade = parseInt(object.grade, 10);
                else if (typeof object.grade === "number")
                    message.grade = object.grade;
                else if (typeof object.grade === "object")
                    message.grade = new $util.LongBits(object.grade.low >>> 0, object.grade.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Process message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.Process
         * @static
         * @param {Msg.Process} message Process
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Process.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.level = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.level = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.grade = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.grade = options.longs === String ? "0" : 0;
            }
            if (message.level != null && message.hasOwnProperty("level"))
                if (typeof message.level === "number")
                    object.level = options.longs === String ? String(message.level) : message.level;
                else
                    object.level = options.longs === String ? $util.Long.prototype.toString.call(message.level) : options.longs === Number ? new $util.LongBits(message.level.low >>> 0, message.level.high >>> 0).toNumber() : message.level;
            if (message.grade != null && message.hasOwnProperty("grade"))
                if (typeof message.grade === "number")
                    object.grade = options.longs === String ? String(message.grade) : message.grade;
                else
                    object.grade = options.longs === String ? $util.Long.prototype.toString.call(message.grade) : options.longs === Number ? new $util.LongBits(message.grade.low >>> 0, message.grade.high >>> 0).toNumber() : message.grade;
            return object;
        };

        /**
         * Converts this Process to JSON.
         * @function toJSON
         * @memberof Msg.Process
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Process.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Process;
    })();

    Msg.AwardItem = (function() {

        /**
         * Properties of an AwardItem.
         * @memberof Msg
         * @interface IAwardItem
         * @property {string|null} [type] AwardItem type
         * @property {number|Long|null} [amount] AwardItem amount
         */

        /**
         * Constructs a new AwardItem.
         * @memberof Msg
         * @classdesc Represents an AwardItem.
         * @implements IAwardItem
         * @constructor
         * @param {Msg.IAwardItem=} [properties] Properties to set
         */
        function AwardItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AwardItem type.
         * @member {string} type
         * @memberof Msg.AwardItem
         * @instance
         */
        AwardItem.prototype.type = "";

        /**
         * AwardItem amount.
         * @member {number|Long} amount
         * @memberof Msg.AwardItem
         * @instance
         */
        AwardItem.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AwardItem instance using the specified properties.
         * @function create
         * @memberof Msg.AwardItem
         * @static
         * @param {Msg.IAwardItem=} [properties] Properties to set
         * @returns {Msg.AwardItem} AwardItem instance
         */
        AwardItem.create = function create(properties) {
            return new AwardItem(properties);
        };

        /**
         * Encodes the specified AwardItem message. Does not implicitly {@link Msg.AwardItem.verify|verify} messages.
         * @function encode
         * @memberof Msg.AwardItem
         * @static
         * @param {Msg.IAwardItem} message AwardItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AwardItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
            return writer;
        };

        /**
         * Encodes the specified AwardItem message, length delimited. Does not implicitly {@link Msg.AwardItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.AwardItem
         * @static
         * @param {Msg.IAwardItem} message AwardItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AwardItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AwardItem message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.AwardItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.AwardItem} AwardItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AwardItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.AwardItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AwardItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.AwardItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.AwardItem} AwardItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AwardItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AwardItem message.
         * @function verify
         * @memberof Msg.AwardItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AwardItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };

        /**
         * Creates an AwardItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.AwardItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.AwardItem} AwardItem
         */
        AwardItem.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.AwardItem)
                return object;
            var message = new $root.Msg.AwardItem();
            if (object.type != null)
                message.type = String(object.type);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an AwardItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.AwardItem
         * @static
         * @param {Msg.AwardItem} message AwardItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AwardItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            return object;
        };

        /**
         * Converts this AwardItem to JSON.
         * @function toJSON
         * @memberof Msg.AwardItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AwardItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AwardItem;
    })();

    /**
     * Code enum.
     * @name Msg.Code
     * @enum {string}
     * @property {number} OK=0 OK value
     * @property {number} CANCELLED=1 CANCELLED value
     * @property {number} UNKNOWN=2 UNKNOWN value
     * @property {number} INVALID_ARGUMENT=3 INVALID_ARGUMENT value
     * @property {number} DEADLINE_EXCEEDED=4 DEADLINE_EXCEEDED value
     * @property {number} NOT_FOUND=5 NOT_FOUND value
     * @property {number} ALREADY_EXISTS=6 ALREADY_EXISTS value
     * @property {number} PERMISSION_DENIED=7 PERMISSION_DENIED value
     * @property {number} UNAUTHENTICATED=16 UNAUTHENTICATED value
     * @property {number} RESOURCE_EXHAUSTED=8 RESOURCE_EXHAUSTED value
     * @property {number} FAILED_PRECONDITION=9 FAILED_PRECONDITION value
     * @property {number} ABORTED=10 ABORTED value
     * @property {number} OUT_OF_RANGE=11 OUT_OF_RANGE value
     * @property {number} UNIMPLEMENTED=12 UNIMPLEMENTED value
     * @property {number} INTERNAL=13 INTERNAL value
     * @property {number} UNAVAILABLE=14 UNAVAILABLE value
     * @property {number} DATA_LOSS=15 DATA_LOSS value
     */
    Msg.Code = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OK"] = 0;
        values[valuesById[1] = "CANCELLED"] = 1;
        values[valuesById[2] = "UNKNOWN"] = 2;
        values[valuesById[3] = "INVALID_ARGUMENT"] = 3;
        values[valuesById[4] = "DEADLINE_EXCEEDED"] = 4;
        values[valuesById[5] = "NOT_FOUND"] = 5;
        values[valuesById[6] = "ALREADY_EXISTS"] = 6;
        values[valuesById[7] = "PERMISSION_DENIED"] = 7;
        values[valuesById[16] = "UNAUTHENTICATED"] = 16;
        values[valuesById[8] = "RESOURCE_EXHAUSTED"] = 8;
        values[valuesById[9] = "FAILED_PRECONDITION"] = 9;
        values[valuesById[10] = "ABORTED"] = 10;
        values[valuesById[11] = "OUT_OF_RANGE"] = 11;
        values[valuesById[12] = "UNIMPLEMENTED"] = 12;
        values[valuesById[13] = "INTERNAL"] = 13;
        values[valuesById[14] = "UNAVAILABLE"] = 14;
        values[valuesById[15] = "DATA_LOSS"] = 15;
        return values;
    })();

    Msg.GetCryptKeyReq = (function() {

        /**
         * Properties of a GetCryptKeyReq.
         * @memberof Msg
         * @interface IGetCryptKeyReq
         * @property {number|Long|null} [timeStamp] GetCryptKeyReq timeStamp
         */

        /**
         * Constructs a new GetCryptKeyReq.
         * @memberof Msg
         * @classdesc Represents a GetCryptKeyReq.
         * @implements IGetCryptKeyReq
         * @constructor
         * @param {Msg.IGetCryptKeyReq=} [properties] Properties to set
         */
        function GetCryptKeyReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCryptKeyReq timeStamp.
         * @member {number|Long} timeStamp
         * @memberof Msg.GetCryptKeyReq
         * @instance
         */
        GetCryptKeyReq.prototype.timeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GetCryptKeyReq instance using the specified properties.
         * @function create
         * @memberof Msg.GetCryptKeyReq
         * @static
         * @param {Msg.IGetCryptKeyReq=} [properties] Properties to set
         * @returns {Msg.GetCryptKeyReq} GetCryptKeyReq instance
         */
        GetCryptKeyReq.create = function create(properties) {
            return new GetCryptKeyReq(properties);
        };

        /**
         * Encodes the specified GetCryptKeyReq message. Does not implicitly {@link Msg.GetCryptKeyReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetCryptKeyReq
         * @static
         * @param {Msg.IGetCryptKeyReq} message GetCryptKeyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCryptKeyReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timeStamp);
            return writer;
        };

        /**
         * Encodes the specified GetCryptKeyReq message, length delimited. Does not implicitly {@link Msg.GetCryptKeyReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetCryptKeyReq
         * @static
         * @param {Msg.IGetCryptKeyReq} message GetCryptKeyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCryptKeyReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCryptKeyReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetCryptKeyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetCryptKeyReq} GetCryptKeyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCryptKeyReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetCryptKeyReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timeStamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCryptKeyReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetCryptKeyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetCryptKeyReq} GetCryptKeyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCryptKeyReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCryptKeyReq message.
         * @function verify
         * @memberof Msg.GetCryptKeyReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCryptKeyReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                if (!$util.isInteger(message.timeStamp) && !(message.timeStamp && $util.isInteger(message.timeStamp.low) && $util.isInteger(message.timeStamp.high)))
                    return "timeStamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a GetCryptKeyReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetCryptKeyReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetCryptKeyReq} GetCryptKeyReq
         */
        GetCryptKeyReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetCryptKeyReq)
                return object;
            var message = new $root.Msg.GetCryptKeyReq();
            if (object.timeStamp != null)
                if ($util.Long)
                    (message.timeStamp = $util.Long.fromValue(object.timeStamp)).unsigned = false;
                else if (typeof object.timeStamp === "string")
                    message.timeStamp = parseInt(object.timeStamp, 10);
                else if (typeof object.timeStamp === "number")
                    message.timeStamp = object.timeStamp;
                else if (typeof object.timeStamp === "object")
                    message.timeStamp = new $util.LongBits(object.timeStamp.low >>> 0, object.timeStamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GetCryptKeyReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetCryptKeyReq
         * @static
         * @param {Msg.GetCryptKeyReq} message GetCryptKeyReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetCryptKeyReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeStamp = options.longs === String ? "0" : 0;
            if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                if (typeof message.timeStamp === "number")
                    object.timeStamp = options.longs === String ? String(message.timeStamp) : message.timeStamp;
                else
                    object.timeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.timeStamp) : options.longs === Number ? new $util.LongBits(message.timeStamp.low >>> 0, message.timeStamp.high >>> 0).toNumber() : message.timeStamp;
            return object;
        };

        /**
         * Converts this GetCryptKeyReq to JSON.
         * @function toJSON
         * @memberof Msg.GetCryptKeyReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetCryptKeyReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetCryptKeyReq;
    })();

    Msg.GetCryptKeyResp = (function() {

        /**
         * Properties of a GetCryptKeyResp.
         * @memberof Msg
         * @interface IGetCryptKeyResp
         * @property {string|null} [key] GetCryptKeyResp key
         * @property {string|null} [iv] GetCryptKeyResp iv
         */

        /**
         * Constructs a new GetCryptKeyResp.
         * @memberof Msg
         * @classdesc Represents a GetCryptKeyResp.
         * @implements IGetCryptKeyResp
         * @constructor
         * @param {Msg.IGetCryptKeyResp=} [properties] Properties to set
         */
        function GetCryptKeyResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCryptKeyResp key.
         * @member {string} key
         * @memberof Msg.GetCryptKeyResp
         * @instance
         */
        GetCryptKeyResp.prototype.key = "";

        /**
         * GetCryptKeyResp iv.
         * @member {string} iv
         * @memberof Msg.GetCryptKeyResp
         * @instance
         */
        GetCryptKeyResp.prototype.iv = "";

        /**
         * Creates a new GetCryptKeyResp instance using the specified properties.
         * @function create
         * @memberof Msg.GetCryptKeyResp
         * @static
         * @param {Msg.IGetCryptKeyResp=} [properties] Properties to set
         * @returns {Msg.GetCryptKeyResp} GetCryptKeyResp instance
         */
        GetCryptKeyResp.create = function create(properties) {
            return new GetCryptKeyResp(properties);
        };

        /**
         * Encodes the specified GetCryptKeyResp message. Does not implicitly {@link Msg.GetCryptKeyResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetCryptKeyResp
         * @static
         * @param {Msg.IGetCryptKeyResp} message GetCryptKeyResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCryptKeyResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.iv != null && message.hasOwnProperty("iv"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.iv);
            return writer;
        };

        /**
         * Encodes the specified GetCryptKeyResp message, length delimited. Does not implicitly {@link Msg.GetCryptKeyResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetCryptKeyResp
         * @static
         * @param {Msg.IGetCryptKeyResp} message GetCryptKeyResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCryptKeyResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCryptKeyResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetCryptKeyResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetCryptKeyResp} GetCryptKeyResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCryptKeyResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetCryptKeyResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.iv = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCryptKeyResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetCryptKeyResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetCryptKeyResp} GetCryptKeyResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCryptKeyResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCryptKeyResp message.
         * @function verify
         * @memberof Msg.GetCryptKeyResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCryptKeyResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.iv != null && message.hasOwnProperty("iv"))
                if (!$util.isString(message.iv))
                    return "iv: string expected";
            return null;
        };

        /**
         * Creates a GetCryptKeyResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetCryptKeyResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetCryptKeyResp} GetCryptKeyResp
         */
        GetCryptKeyResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetCryptKeyResp)
                return object;
            var message = new $root.Msg.GetCryptKeyResp();
            if (object.key != null)
                message.key = String(object.key);
            if (object.iv != null)
                message.iv = String(object.iv);
            return message;
        };

        /**
         * Creates a plain object from a GetCryptKeyResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetCryptKeyResp
         * @static
         * @param {Msg.GetCryptKeyResp} message GetCryptKeyResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetCryptKeyResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = "";
                object.iv = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.iv != null && message.hasOwnProperty("iv"))
                object.iv = message.iv;
            return object;
        };

        /**
         * Converts this GetCryptKeyResp to JSON.
         * @function toJSON
         * @memberof Msg.GetCryptKeyResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetCryptKeyResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetCryptKeyResp;
    })();

    Msg.PlayerDailySignInfoReq = (function() {

        /**
         * Properties of a PlayerDailySignInfoReq.
         * @memberof Msg
         * @interface IPlayerDailySignInfoReq
         * @property {string|null} [playerID] PlayerDailySignInfoReq playerID
         */

        /**
         * Constructs a new PlayerDailySignInfoReq.
         * @memberof Msg
         * @classdesc Represents a PlayerDailySignInfoReq.
         * @implements IPlayerDailySignInfoReq
         * @constructor
         * @param {Msg.IPlayerDailySignInfoReq=} [properties] Properties to set
         */
        function PlayerDailySignInfoReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayerDailySignInfoReq playerID.
         * @member {string} playerID
         * @memberof Msg.PlayerDailySignInfoReq
         * @instance
         */
        PlayerDailySignInfoReq.prototype.playerID = "";

        /**
         * Creates a new PlayerDailySignInfoReq instance using the specified properties.
         * @function create
         * @memberof Msg.PlayerDailySignInfoReq
         * @static
         * @param {Msg.IPlayerDailySignInfoReq=} [properties] Properties to set
         * @returns {Msg.PlayerDailySignInfoReq} PlayerDailySignInfoReq instance
         */
        PlayerDailySignInfoReq.create = function create(properties) {
            return new PlayerDailySignInfoReq(properties);
        };

        /**
         * Encodes the specified PlayerDailySignInfoReq message. Does not implicitly {@link Msg.PlayerDailySignInfoReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.PlayerDailySignInfoReq
         * @static
         * @param {Msg.IPlayerDailySignInfoReq} message PlayerDailySignInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerDailySignInfoReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified PlayerDailySignInfoReq message, length delimited. Does not implicitly {@link Msg.PlayerDailySignInfoReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PlayerDailySignInfoReq
         * @static
         * @param {Msg.IPlayerDailySignInfoReq} message PlayerDailySignInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerDailySignInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayerDailySignInfoReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PlayerDailySignInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PlayerDailySignInfoReq} PlayerDailySignInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerDailySignInfoReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PlayerDailySignInfoReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayerDailySignInfoReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PlayerDailySignInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PlayerDailySignInfoReq} PlayerDailySignInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerDailySignInfoReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayerDailySignInfoReq message.
         * @function verify
         * @memberof Msg.PlayerDailySignInfoReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerDailySignInfoReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a PlayerDailySignInfoReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PlayerDailySignInfoReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PlayerDailySignInfoReq} PlayerDailySignInfoReq
         */
        PlayerDailySignInfoReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PlayerDailySignInfoReq)
                return object;
            var message = new $root.Msg.PlayerDailySignInfoReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a PlayerDailySignInfoReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PlayerDailySignInfoReq
         * @static
         * @param {Msg.PlayerDailySignInfoReq} message PlayerDailySignInfoReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerDailySignInfoReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playerID = "";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this PlayerDailySignInfoReq to JSON.
         * @function toJSON
         * @memberof Msg.PlayerDailySignInfoReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerDailySignInfoReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlayerDailySignInfoReq;
    })();

    Msg.PlayerDailySignInfoResp = (function() {

        /**
         * Properties of a PlayerDailySignInfoResp.
         * @memberof Msg
         * @interface IPlayerDailySignInfoResp
         * @property {number|null} [data] PlayerDailySignInfoResp data
         * @property {number|Long|null} [lastSignSt] PlayerDailySignInfoResp lastSignSt
         * @property {number|null} [restDay] PlayerDailySignInfoResp restDay
         * @property {number|null} [todaySigned] PlayerDailySignInfoResp todaySigned
         * @property {Array.<Msg.IAwardItem>|null} [award] PlayerDailySignInfoResp award
         * @property {Msg.IStatus|null} [status] PlayerDailySignInfoResp status
         */

        /**
         * Constructs a new PlayerDailySignInfoResp.
         * @memberof Msg
         * @classdesc Represents a PlayerDailySignInfoResp.
         * @implements IPlayerDailySignInfoResp
         * @constructor
         * @param {Msg.IPlayerDailySignInfoResp=} [properties] Properties to set
         */
        function PlayerDailySignInfoResp(properties) {
            this.award = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayerDailySignInfoResp data.
         * @member {number} data
         * @memberof Msg.PlayerDailySignInfoResp
         * @instance
         */
        PlayerDailySignInfoResp.prototype.data = 0;

        /**
         * PlayerDailySignInfoResp lastSignSt.
         * @member {number|Long} lastSignSt
         * @memberof Msg.PlayerDailySignInfoResp
         * @instance
         */
        PlayerDailySignInfoResp.prototype.lastSignSt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PlayerDailySignInfoResp restDay.
         * @member {number} restDay
         * @memberof Msg.PlayerDailySignInfoResp
         * @instance
         */
        PlayerDailySignInfoResp.prototype.restDay = 0;

        /**
         * PlayerDailySignInfoResp todaySigned.
         * @member {number} todaySigned
         * @memberof Msg.PlayerDailySignInfoResp
         * @instance
         */
        PlayerDailySignInfoResp.prototype.todaySigned = 0;

        /**
         * PlayerDailySignInfoResp award.
         * @member {Array.<Msg.IAwardItem>} award
         * @memberof Msg.PlayerDailySignInfoResp
         * @instance
         */
        PlayerDailySignInfoResp.prototype.award = $util.emptyArray;

        /**
         * PlayerDailySignInfoResp status.
         * @member {Msg.IStatus|null|undefined} status
         * @memberof Msg.PlayerDailySignInfoResp
         * @instance
         */
        PlayerDailySignInfoResp.prototype.status = null;

        /**
         * Creates a new PlayerDailySignInfoResp instance using the specified properties.
         * @function create
         * @memberof Msg.PlayerDailySignInfoResp
         * @static
         * @param {Msg.IPlayerDailySignInfoResp=} [properties] Properties to set
         * @returns {Msg.PlayerDailySignInfoResp} PlayerDailySignInfoResp instance
         */
        PlayerDailySignInfoResp.create = function create(properties) {
            return new PlayerDailySignInfoResp(properties);
        };

        /**
         * Encodes the specified PlayerDailySignInfoResp message. Does not implicitly {@link Msg.PlayerDailySignInfoResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.PlayerDailySignInfoResp
         * @static
         * @param {Msg.IPlayerDailySignInfoResp} message PlayerDailySignInfoResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerDailySignInfoResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.data);
            if (message.lastSignSt != null && message.hasOwnProperty("lastSignSt"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.lastSignSt);
            if (message.restDay != null && message.hasOwnProperty("restDay"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.restDay);
            if (message.todaySigned != null && message.hasOwnProperty("todaySigned"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.todaySigned);
            if (message.award != null && message.award.length)
                for (var i = 0; i < message.award.length; ++i)
                    $root.Msg.AwardItem.encode(message.award[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.status != null && message.hasOwnProperty("status"))
                $root.Msg.Status.encode(message.status, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PlayerDailySignInfoResp message, length delimited. Does not implicitly {@link Msg.PlayerDailySignInfoResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PlayerDailySignInfoResp
         * @static
         * @param {Msg.IPlayerDailySignInfoResp} message PlayerDailySignInfoResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerDailySignInfoResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayerDailySignInfoResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PlayerDailySignInfoResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PlayerDailySignInfoResp} PlayerDailySignInfoResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerDailySignInfoResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PlayerDailySignInfoResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.uint32();
                    break;
                case 2:
                    message.lastSignSt = reader.int64();
                    break;
                case 3:
                    message.restDay = reader.uint32();
                    break;
                case 4:
                    message.todaySigned = reader.uint32();
                    break;
                case 5:
                    if (!(message.award && message.award.length))
                        message.award = [];
                    message.award.push($root.Msg.AwardItem.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.status = $root.Msg.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayerDailySignInfoResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PlayerDailySignInfoResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PlayerDailySignInfoResp} PlayerDailySignInfoResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerDailySignInfoResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayerDailySignInfoResp message.
         * @function verify
         * @memberof Msg.PlayerDailySignInfoResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerDailySignInfoResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isInteger(message.data))
                    return "data: integer expected";
            if (message.lastSignSt != null && message.hasOwnProperty("lastSignSt"))
                if (!$util.isInteger(message.lastSignSt) && !(message.lastSignSt && $util.isInteger(message.lastSignSt.low) && $util.isInteger(message.lastSignSt.high)))
                    return "lastSignSt: integer|Long expected";
            if (message.restDay != null && message.hasOwnProperty("restDay"))
                if (!$util.isInteger(message.restDay))
                    return "restDay: integer expected";
            if (message.todaySigned != null && message.hasOwnProperty("todaySigned"))
                if (!$util.isInteger(message.todaySigned))
                    return "todaySigned: integer expected";
            if (message.award != null && message.hasOwnProperty("award")) {
                if (!Array.isArray(message.award))
                    return "award: array expected";
                for (var i = 0; i < message.award.length; ++i) {
                    var error = $root.Msg.AwardItem.verify(message.award[i]);
                    if (error)
                        return "award." + error;
                }
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.Msg.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a PlayerDailySignInfoResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PlayerDailySignInfoResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PlayerDailySignInfoResp} PlayerDailySignInfoResp
         */
        PlayerDailySignInfoResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PlayerDailySignInfoResp)
                return object;
            var message = new $root.Msg.PlayerDailySignInfoResp();
            if (object.data != null)
                message.data = object.data >>> 0;
            if (object.lastSignSt != null)
                if ($util.Long)
                    (message.lastSignSt = $util.Long.fromValue(object.lastSignSt)).unsigned = false;
                else if (typeof object.lastSignSt === "string")
                    message.lastSignSt = parseInt(object.lastSignSt, 10);
                else if (typeof object.lastSignSt === "number")
                    message.lastSignSt = object.lastSignSt;
                else if (typeof object.lastSignSt === "object")
                    message.lastSignSt = new $util.LongBits(object.lastSignSt.low >>> 0, object.lastSignSt.high >>> 0).toNumber();
            if (object.restDay != null)
                message.restDay = object.restDay >>> 0;
            if (object.todaySigned != null)
                message.todaySigned = object.todaySigned >>> 0;
            if (object.award) {
                if (!Array.isArray(object.award))
                    throw TypeError(".Msg.PlayerDailySignInfoResp.award: array expected");
                message.award = [];
                for (var i = 0; i < object.award.length; ++i) {
                    if (typeof object.award[i] !== "object")
                        throw TypeError(".Msg.PlayerDailySignInfoResp.award: object expected");
                    message.award[i] = $root.Msg.AwardItem.fromObject(object.award[i]);
                }
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".Msg.PlayerDailySignInfoResp.status: object expected");
                message.status = $root.Msg.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a PlayerDailySignInfoResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PlayerDailySignInfoResp
         * @static
         * @param {Msg.PlayerDailySignInfoResp} message PlayerDailySignInfoResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerDailySignInfoResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.award = [];
            if (options.defaults) {
                object.data = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.lastSignSt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastSignSt = options.longs === String ? "0" : 0;
                object.restDay = 0;
                object.todaySigned = 0;
                object.status = null;
            }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            if (message.lastSignSt != null && message.hasOwnProperty("lastSignSt"))
                if (typeof message.lastSignSt === "number")
                    object.lastSignSt = options.longs === String ? String(message.lastSignSt) : message.lastSignSt;
                else
                    object.lastSignSt = options.longs === String ? $util.Long.prototype.toString.call(message.lastSignSt) : options.longs === Number ? new $util.LongBits(message.lastSignSt.low >>> 0, message.lastSignSt.high >>> 0).toNumber() : message.lastSignSt;
            if (message.restDay != null && message.hasOwnProperty("restDay"))
                object.restDay = message.restDay;
            if (message.todaySigned != null && message.hasOwnProperty("todaySigned"))
                object.todaySigned = message.todaySigned;
            if (message.award && message.award.length) {
                object.award = [];
                for (var j = 0; j < message.award.length; ++j)
                    object.award[j] = $root.Msg.AwardItem.toObject(message.award[j], options);
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.Msg.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this PlayerDailySignInfoResp to JSON.
         * @function toJSON
         * @memberof Msg.PlayerDailySignInfoResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerDailySignInfoResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlayerDailySignInfoResp;
    })();

    Msg.PlayerDailySignReq = (function() {

        /**
         * Properties of a PlayerDailySignReq.
         * @memberof Msg
         * @interface IPlayerDailySignReq
         * @property {string|null} [playerID] PlayerDailySignReq playerID
         * @property {number|null} [fixDay] PlayerDailySignReq fixDay
         */

        /**
         * Constructs a new PlayerDailySignReq.
         * @memberof Msg
         * @classdesc Represents a PlayerDailySignReq.
         * @implements IPlayerDailySignReq
         * @constructor
         * @param {Msg.IPlayerDailySignReq=} [properties] Properties to set
         */
        function PlayerDailySignReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayerDailySignReq playerID.
         * @member {string} playerID
         * @memberof Msg.PlayerDailySignReq
         * @instance
         */
        PlayerDailySignReq.prototype.playerID = "";

        /**
         * PlayerDailySignReq fixDay.
         * @member {number} fixDay
         * @memberof Msg.PlayerDailySignReq
         * @instance
         */
        PlayerDailySignReq.prototype.fixDay = 0;

        /**
         * Creates a new PlayerDailySignReq instance using the specified properties.
         * @function create
         * @memberof Msg.PlayerDailySignReq
         * @static
         * @param {Msg.IPlayerDailySignReq=} [properties] Properties to set
         * @returns {Msg.PlayerDailySignReq} PlayerDailySignReq instance
         */
        PlayerDailySignReq.create = function create(properties) {
            return new PlayerDailySignReq(properties);
        };

        /**
         * Encodes the specified PlayerDailySignReq message. Does not implicitly {@link Msg.PlayerDailySignReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.PlayerDailySignReq
         * @static
         * @param {Msg.IPlayerDailySignReq} message PlayerDailySignReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerDailySignReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            if (message.fixDay != null && message.hasOwnProperty("fixDay"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.fixDay);
            return writer;
        };

        /**
         * Encodes the specified PlayerDailySignReq message, length delimited. Does not implicitly {@link Msg.PlayerDailySignReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PlayerDailySignReq
         * @static
         * @param {Msg.IPlayerDailySignReq} message PlayerDailySignReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerDailySignReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayerDailySignReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PlayerDailySignReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PlayerDailySignReq} PlayerDailySignReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerDailySignReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PlayerDailySignReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                case 2:
                    message.fixDay = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayerDailySignReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PlayerDailySignReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PlayerDailySignReq} PlayerDailySignReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerDailySignReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayerDailySignReq message.
         * @function verify
         * @memberof Msg.PlayerDailySignReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerDailySignReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            if (message.fixDay != null && message.hasOwnProperty("fixDay"))
                if (!$util.isInteger(message.fixDay))
                    return "fixDay: integer expected";
            return null;
        };

        /**
         * Creates a PlayerDailySignReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PlayerDailySignReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PlayerDailySignReq} PlayerDailySignReq
         */
        PlayerDailySignReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PlayerDailySignReq)
                return object;
            var message = new $root.Msg.PlayerDailySignReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            if (object.fixDay != null)
                message.fixDay = object.fixDay >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PlayerDailySignReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PlayerDailySignReq
         * @static
         * @param {Msg.PlayerDailySignReq} message PlayerDailySignReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerDailySignReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerID = "";
                object.fixDay = 0;
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.fixDay != null && message.hasOwnProperty("fixDay"))
                object.fixDay = message.fixDay;
            return object;
        };

        /**
         * Converts this PlayerDailySignReq to JSON.
         * @function toJSON
         * @memberof Msg.PlayerDailySignReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerDailySignReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlayerDailySignReq;
    })();

    Msg.PlayerDailySignResp = (function() {

        /**
         * Properties of a PlayerDailySignResp.
         * @memberof Msg
         * @interface IPlayerDailySignResp
         * @property {number|null} [data] PlayerDailySignResp data
         * @property {number|Long|null} [lastSignSt] PlayerDailySignResp lastSignSt
         * @property {number|null} [restDay] PlayerDailySignResp restDay
         * @property {number|null} [todaySigned] PlayerDailySignResp todaySigned
         * @property {Array.<Msg.IAwardItem>|null} [award] PlayerDailySignResp award
         * @property {Msg.IStatus|null} [status] PlayerDailySignResp status
         */

        /**
         * Constructs a new PlayerDailySignResp.
         * @memberof Msg
         * @classdesc Represents a PlayerDailySignResp.
         * @implements IPlayerDailySignResp
         * @constructor
         * @param {Msg.IPlayerDailySignResp=} [properties] Properties to set
         */
        function PlayerDailySignResp(properties) {
            this.award = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayerDailySignResp data.
         * @member {number} data
         * @memberof Msg.PlayerDailySignResp
         * @instance
         */
        PlayerDailySignResp.prototype.data = 0;

        /**
         * PlayerDailySignResp lastSignSt.
         * @member {number|Long} lastSignSt
         * @memberof Msg.PlayerDailySignResp
         * @instance
         */
        PlayerDailySignResp.prototype.lastSignSt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PlayerDailySignResp restDay.
         * @member {number} restDay
         * @memberof Msg.PlayerDailySignResp
         * @instance
         */
        PlayerDailySignResp.prototype.restDay = 0;

        /**
         * PlayerDailySignResp todaySigned.
         * @member {number} todaySigned
         * @memberof Msg.PlayerDailySignResp
         * @instance
         */
        PlayerDailySignResp.prototype.todaySigned = 0;

        /**
         * PlayerDailySignResp award.
         * @member {Array.<Msg.IAwardItem>} award
         * @memberof Msg.PlayerDailySignResp
         * @instance
         */
        PlayerDailySignResp.prototype.award = $util.emptyArray;

        /**
         * PlayerDailySignResp status.
         * @member {Msg.IStatus|null|undefined} status
         * @memberof Msg.PlayerDailySignResp
         * @instance
         */
        PlayerDailySignResp.prototype.status = null;

        /**
         * Creates a new PlayerDailySignResp instance using the specified properties.
         * @function create
         * @memberof Msg.PlayerDailySignResp
         * @static
         * @param {Msg.IPlayerDailySignResp=} [properties] Properties to set
         * @returns {Msg.PlayerDailySignResp} PlayerDailySignResp instance
         */
        PlayerDailySignResp.create = function create(properties) {
            return new PlayerDailySignResp(properties);
        };

        /**
         * Encodes the specified PlayerDailySignResp message. Does not implicitly {@link Msg.PlayerDailySignResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.PlayerDailySignResp
         * @static
         * @param {Msg.IPlayerDailySignResp} message PlayerDailySignResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerDailySignResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.data);
            if (message.lastSignSt != null && message.hasOwnProperty("lastSignSt"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.lastSignSt);
            if (message.restDay != null && message.hasOwnProperty("restDay"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.restDay);
            if (message.todaySigned != null && message.hasOwnProperty("todaySigned"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.todaySigned);
            if (message.award != null && message.award.length)
                for (var i = 0; i < message.award.length; ++i)
                    $root.Msg.AwardItem.encode(message.award[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.status != null && message.hasOwnProperty("status"))
                $root.Msg.Status.encode(message.status, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PlayerDailySignResp message, length delimited. Does not implicitly {@link Msg.PlayerDailySignResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PlayerDailySignResp
         * @static
         * @param {Msg.IPlayerDailySignResp} message PlayerDailySignResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerDailySignResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayerDailySignResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PlayerDailySignResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PlayerDailySignResp} PlayerDailySignResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerDailySignResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PlayerDailySignResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.uint32();
                    break;
                case 2:
                    message.lastSignSt = reader.int64();
                    break;
                case 3:
                    message.restDay = reader.uint32();
                    break;
                case 4:
                    message.todaySigned = reader.uint32();
                    break;
                case 5:
                    if (!(message.award && message.award.length))
                        message.award = [];
                    message.award.push($root.Msg.AwardItem.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.status = $root.Msg.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayerDailySignResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PlayerDailySignResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PlayerDailySignResp} PlayerDailySignResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerDailySignResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayerDailySignResp message.
         * @function verify
         * @memberof Msg.PlayerDailySignResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerDailySignResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isInteger(message.data))
                    return "data: integer expected";
            if (message.lastSignSt != null && message.hasOwnProperty("lastSignSt"))
                if (!$util.isInteger(message.lastSignSt) && !(message.lastSignSt && $util.isInteger(message.lastSignSt.low) && $util.isInteger(message.lastSignSt.high)))
                    return "lastSignSt: integer|Long expected";
            if (message.restDay != null && message.hasOwnProperty("restDay"))
                if (!$util.isInteger(message.restDay))
                    return "restDay: integer expected";
            if (message.todaySigned != null && message.hasOwnProperty("todaySigned"))
                if (!$util.isInteger(message.todaySigned))
                    return "todaySigned: integer expected";
            if (message.award != null && message.hasOwnProperty("award")) {
                if (!Array.isArray(message.award))
                    return "award: array expected";
                for (var i = 0; i < message.award.length; ++i) {
                    var error = $root.Msg.AwardItem.verify(message.award[i]);
                    if (error)
                        return "award." + error;
                }
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.Msg.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a PlayerDailySignResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PlayerDailySignResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PlayerDailySignResp} PlayerDailySignResp
         */
        PlayerDailySignResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PlayerDailySignResp)
                return object;
            var message = new $root.Msg.PlayerDailySignResp();
            if (object.data != null)
                message.data = object.data >>> 0;
            if (object.lastSignSt != null)
                if ($util.Long)
                    (message.lastSignSt = $util.Long.fromValue(object.lastSignSt)).unsigned = false;
                else if (typeof object.lastSignSt === "string")
                    message.lastSignSt = parseInt(object.lastSignSt, 10);
                else if (typeof object.lastSignSt === "number")
                    message.lastSignSt = object.lastSignSt;
                else if (typeof object.lastSignSt === "object")
                    message.lastSignSt = new $util.LongBits(object.lastSignSt.low >>> 0, object.lastSignSt.high >>> 0).toNumber();
            if (object.restDay != null)
                message.restDay = object.restDay >>> 0;
            if (object.todaySigned != null)
                message.todaySigned = object.todaySigned >>> 0;
            if (object.award) {
                if (!Array.isArray(object.award))
                    throw TypeError(".Msg.PlayerDailySignResp.award: array expected");
                message.award = [];
                for (var i = 0; i < object.award.length; ++i) {
                    if (typeof object.award[i] !== "object")
                        throw TypeError(".Msg.PlayerDailySignResp.award: object expected");
                    message.award[i] = $root.Msg.AwardItem.fromObject(object.award[i]);
                }
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".Msg.PlayerDailySignResp.status: object expected");
                message.status = $root.Msg.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a PlayerDailySignResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PlayerDailySignResp
         * @static
         * @param {Msg.PlayerDailySignResp} message PlayerDailySignResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerDailySignResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.award = [];
            if (options.defaults) {
                object.data = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.lastSignSt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastSignSt = options.longs === String ? "0" : 0;
                object.restDay = 0;
                object.todaySigned = 0;
                object.status = null;
            }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            if (message.lastSignSt != null && message.hasOwnProperty("lastSignSt"))
                if (typeof message.lastSignSt === "number")
                    object.lastSignSt = options.longs === String ? String(message.lastSignSt) : message.lastSignSt;
                else
                    object.lastSignSt = options.longs === String ? $util.Long.prototype.toString.call(message.lastSignSt) : options.longs === Number ? new $util.LongBits(message.lastSignSt.low >>> 0, message.lastSignSt.high >>> 0).toNumber() : message.lastSignSt;
            if (message.restDay != null && message.hasOwnProperty("restDay"))
                object.restDay = message.restDay;
            if (message.todaySigned != null && message.hasOwnProperty("todaySigned"))
                object.todaySigned = message.todaySigned;
            if (message.award && message.award.length) {
                object.award = [];
                for (var j = 0; j < message.award.length; ++j)
                    object.award[j] = $root.Msg.AwardItem.toObject(message.award[j], options);
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.Msg.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this PlayerDailySignResp to JSON.
         * @function toJSON
         * @memberof Msg.PlayerDailySignResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerDailySignResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlayerDailySignResp;
    })();

    Msg.Status = (function() {

        /**
         * Properties of a Status.
         * @memberof Msg
         * @interface IStatus
         * @property {number|null} [code] Status code
         * @property {string|null} [message] Status message
         * @property {Array.<Msg.IAny>|null} [details] Status details
         */

        /**
         * Constructs a new Status.
         * @memberof Msg
         * @classdesc Represents a Status.
         * @implements IStatus
         * @constructor
         * @param {Msg.IStatus=} [properties] Properties to set
         */
        function Status(properties) {
            this.details = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Status code.
         * @member {number} code
         * @memberof Msg.Status
         * @instance
         */
        Status.prototype.code = 0;

        /**
         * Status message.
         * @member {string} message
         * @memberof Msg.Status
         * @instance
         */
        Status.prototype.message = "";

        /**
         * Status details.
         * @member {Array.<Msg.IAny>} details
         * @memberof Msg.Status
         * @instance
         */
        Status.prototype.details = $util.emptyArray;

        /**
         * Creates a new Status instance using the specified properties.
         * @function create
         * @memberof Msg.Status
         * @static
         * @param {Msg.IStatus=} [properties] Properties to set
         * @returns {Msg.Status} Status instance
         */
        Status.create = function create(properties) {
            return new Status(properties);
        };

        /**
         * Encodes the specified Status message. Does not implicitly {@link Msg.Status.verify|verify} messages.
         * @function encode
         * @memberof Msg.Status
         * @static
         * @param {Msg.IStatus} message Status message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Status.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && message.hasOwnProperty("code"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            if (message.details != null && message.details.length)
                for (var i = 0; i < message.details.length; ++i)
                    $root.Msg.Any.encode(message.details[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Status message, length delimited. Does not implicitly {@link Msg.Status.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.Status
         * @static
         * @param {Msg.IStatus} message Status message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Status.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Status message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.Status
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.Status} Status
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Status.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.Status();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    if (!(message.details && message.details.length))
                        message.details = [];
                    message.details.push($root.Msg.Any.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Status message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.Status
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.Status} Status
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Status.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Status message.
         * @function verify
         * @memberof Msg.Status
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Status.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isInteger(message.code))
                    return "code: integer expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.details != null && message.hasOwnProperty("details")) {
                if (!Array.isArray(message.details))
                    return "details: array expected";
                for (var i = 0; i < message.details.length; ++i) {
                    var error = $root.Msg.Any.verify(message.details[i]);
                    if (error)
                        return "details." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Status message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.Status
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.Status} Status
         */
        Status.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.Status)
                return object;
            var message = new $root.Msg.Status();
            if (object.code != null)
                message.code = object.code | 0;
            if (object.message != null)
                message.message = String(object.message);
            if (object.details) {
                if (!Array.isArray(object.details))
                    throw TypeError(".Msg.Status.details: array expected");
                message.details = [];
                for (var i = 0; i < object.details.length; ++i) {
                    if (typeof object.details[i] !== "object")
                        throw TypeError(".Msg.Status.details: object expected");
                    message.details[i] = $root.Msg.Any.fromObject(object.details[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Status message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.Status
         * @static
         * @param {Msg.Status} message Status
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Status.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.details = [];
            if (options.defaults) {
                object.code = 0;
                object.message = "";
            }
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.details && message.details.length) {
                object.details = [];
                for (var j = 0; j < message.details.length; ++j)
                    object.details[j] = $root.Msg.Any.toObject(message.details[j], options);
            }
            return object;
        };

        /**
         * Converts this Status to JSON.
         * @function toJSON
         * @memberof Msg.Status
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Status.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Status;
    })();

    Msg.UpdateWeaponReq = (function() {

        /**
         * Properties of an UpdateWeaponReq.
         * @memberof Msg
         * @interface IUpdateWeaponReq
         * @property {string|null} [playerID] UpdateWeaponReq playerID
         * @property {number|Long|null} [oldWeaponID] UpdateWeaponReq oldWeaponID
         * @property {number|Long|null} [newWeaponID] UpdateWeaponReq newWeaponID
         */

        /**
         * Constructs a new UpdateWeaponReq.
         * @memberof Msg
         * @classdesc Represents an UpdateWeaponReq.
         * @implements IUpdateWeaponReq
         * @constructor
         * @param {Msg.IUpdateWeaponReq=} [properties] Properties to set
         */
        function UpdateWeaponReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateWeaponReq playerID.
         * @member {string} playerID
         * @memberof Msg.UpdateWeaponReq
         * @instance
         */
        UpdateWeaponReq.prototype.playerID = "";

        /**
         * UpdateWeaponReq oldWeaponID.
         * @member {number|Long} oldWeaponID
         * @memberof Msg.UpdateWeaponReq
         * @instance
         */
        UpdateWeaponReq.prototype.oldWeaponID = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UpdateWeaponReq newWeaponID.
         * @member {number|Long} newWeaponID
         * @memberof Msg.UpdateWeaponReq
         * @instance
         */
        UpdateWeaponReq.prototype.newWeaponID = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UpdateWeaponReq instance using the specified properties.
         * @function create
         * @memberof Msg.UpdateWeaponReq
         * @static
         * @param {Msg.IUpdateWeaponReq=} [properties] Properties to set
         * @returns {Msg.UpdateWeaponReq} UpdateWeaponReq instance
         */
        UpdateWeaponReq.create = function create(properties) {
            return new UpdateWeaponReq(properties);
        };

        /**
         * Encodes the specified UpdateWeaponReq message. Does not implicitly {@link Msg.UpdateWeaponReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.UpdateWeaponReq
         * @static
         * @param {Msg.IUpdateWeaponReq} message UpdateWeaponReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateWeaponReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            if (message.oldWeaponID != null && message.hasOwnProperty("oldWeaponID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.oldWeaponID);
            if (message.newWeaponID != null && message.hasOwnProperty("newWeaponID"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.newWeaponID);
            return writer;
        };

        /**
         * Encodes the specified UpdateWeaponReq message, length delimited. Does not implicitly {@link Msg.UpdateWeaponReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.UpdateWeaponReq
         * @static
         * @param {Msg.IUpdateWeaponReq} message UpdateWeaponReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateWeaponReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateWeaponReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.UpdateWeaponReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.UpdateWeaponReq} UpdateWeaponReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateWeaponReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.UpdateWeaponReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                case 2:
                    message.oldWeaponID = reader.int64();
                    break;
                case 3:
                    message.newWeaponID = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateWeaponReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.UpdateWeaponReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.UpdateWeaponReq} UpdateWeaponReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateWeaponReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateWeaponReq message.
         * @function verify
         * @memberof Msg.UpdateWeaponReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateWeaponReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            if (message.oldWeaponID != null && message.hasOwnProperty("oldWeaponID"))
                if (!$util.isInteger(message.oldWeaponID) && !(message.oldWeaponID && $util.isInteger(message.oldWeaponID.low) && $util.isInteger(message.oldWeaponID.high)))
                    return "oldWeaponID: integer|Long expected";
            if (message.newWeaponID != null && message.hasOwnProperty("newWeaponID"))
                if (!$util.isInteger(message.newWeaponID) && !(message.newWeaponID && $util.isInteger(message.newWeaponID.low) && $util.isInteger(message.newWeaponID.high)))
                    return "newWeaponID: integer|Long expected";
            return null;
        };

        /**
         * Creates an UpdateWeaponReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.UpdateWeaponReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.UpdateWeaponReq} UpdateWeaponReq
         */
        UpdateWeaponReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.UpdateWeaponReq)
                return object;
            var message = new $root.Msg.UpdateWeaponReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            if (object.oldWeaponID != null)
                if ($util.Long)
                    (message.oldWeaponID = $util.Long.fromValue(object.oldWeaponID)).unsigned = false;
                else if (typeof object.oldWeaponID === "string")
                    message.oldWeaponID = parseInt(object.oldWeaponID, 10);
                else if (typeof object.oldWeaponID === "number")
                    message.oldWeaponID = object.oldWeaponID;
                else if (typeof object.oldWeaponID === "object")
                    message.oldWeaponID = new $util.LongBits(object.oldWeaponID.low >>> 0, object.oldWeaponID.high >>> 0).toNumber();
            if (object.newWeaponID != null)
                if ($util.Long)
                    (message.newWeaponID = $util.Long.fromValue(object.newWeaponID)).unsigned = false;
                else if (typeof object.newWeaponID === "string")
                    message.newWeaponID = parseInt(object.newWeaponID, 10);
                else if (typeof object.newWeaponID === "number")
                    message.newWeaponID = object.newWeaponID;
                else if (typeof object.newWeaponID === "object")
                    message.newWeaponID = new $util.LongBits(object.newWeaponID.low >>> 0, object.newWeaponID.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UpdateWeaponReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.UpdateWeaponReq
         * @static
         * @param {Msg.UpdateWeaponReq} message UpdateWeaponReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateWeaponReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerID = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.oldWeaponID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.oldWeaponID = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.newWeaponID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.newWeaponID = options.longs === String ? "0" : 0;
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.oldWeaponID != null && message.hasOwnProperty("oldWeaponID"))
                if (typeof message.oldWeaponID === "number")
                    object.oldWeaponID = options.longs === String ? String(message.oldWeaponID) : message.oldWeaponID;
                else
                    object.oldWeaponID = options.longs === String ? $util.Long.prototype.toString.call(message.oldWeaponID) : options.longs === Number ? new $util.LongBits(message.oldWeaponID.low >>> 0, message.oldWeaponID.high >>> 0).toNumber() : message.oldWeaponID;
            if (message.newWeaponID != null && message.hasOwnProperty("newWeaponID"))
                if (typeof message.newWeaponID === "number")
                    object.newWeaponID = options.longs === String ? String(message.newWeaponID) : message.newWeaponID;
                else
                    object.newWeaponID = options.longs === String ? $util.Long.prototype.toString.call(message.newWeaponID) : options.longs === Number ? new $util.LongBits(message.newWeaponID.low >>> 0, message.newWeaponID.high >>> 0).toNumber() : message.newWeaponID;
            return object;
        };

        /**
         * Converts this UpdateWeaponReq to JSON.
         * @function toJSON
         * @memberof Msg.UpdateWeaponReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateWeaponReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateWeaponReq;
    })();

    Msg.UpdateWeaponResp = (function() {

        /**
         * Properties of an UpdateWeaponResp.
         * @memberof Msg
         * @interface IUpdateWeaponResp
         * @property {Msg.UpdateWeaponResp.Result|null} [result] UpdateWeaponResp result
         */

        /**
         * Constructs a new UpdateWeaponResp.
         * @memberof Msg
         * @classdesc Represents an UpdateWeaponResp.
         * @implements IUpdateWeaponResp
         * @constructor
         * @param {Msg.IUpdateWeaponResp=} [properties] Properties to set
         */
        function UpdateWeaponResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateWeaponResp result.
         * @member {Msg.UpdateWeaponResp.Result} result
         * @memberof Msg.UpdateWeaponResp
         * @instance
         */
        UpdateWeaponResp.prototype.result = 0;

        /**
         * Creates a new UpdateWeaponResp instance using the specified properties.
         * @function create
         * @memberof Msg.UpdateWeaponResp
         * @static
         * @param {Msg.IUpdateWeaponResp=} [properties] Properties to set
         * @returns {Msg.UpdateWeaponResp} UpdateWeaponResp instance
         */
        UpdateWeaponResp.create = function create(properties) {
            return new UpdateWeaponResp(properties);
        };

        /**
         * Encodes the specified UpdateWeaponResp message. Does not implicitly {@link Msg.UpdateWeaponResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.UpdateWeaponResp
         * @static
         * @param {Msg.IUpdateWeaponResp} message UpdateWeaponResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateWeaponResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified UpdateWeaponResp message, length delimited. Does not implicitly {@link Msg.UpdateWeaponResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.UpdateWeaponResp
         * @static
         * @param {Msg.IUpdateWeaponResp} message UpdateWeaponResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateWeaponResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateWeaponResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.UpdateWeaponResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.UpdateWeaponResp} UpdateWeaponResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateWeaponResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.UpdateWeaponResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateWeaponResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.UpdateWeaponResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.UpdateWeaponResp} UpdateWeaponResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateWeaponResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateWeaponResp message.
         * @function verify
         * @memberof Msg.UpdateWeaponResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateWeaponResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates an UpdateWeaponResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.UpdateWeaponResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.UpdateWeaponResp} UpdateWeaponResp
         */
        UpdateWeaponResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.UpdateWeaponResp)
                return object;
            var message = new $root.Msg.UpdateWeaponResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateWeaponResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.UpdateWeaponResp
         * @static
         * @param {Msg.UpdateWeaponResp} message UpdateWeaponResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateWeaponResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "Internal" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.UpdateWeaponResp.Result[message.result] : message.result;
            return object;
        };

        /**
         * Converts this UpdateWeaponResp to JSON.
         * @function toJSON
         * @memberof Msg.UpdateWeaponResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateWeaponResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.UpdateWeaponResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        UpdateWeaponResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return UpdateWeaponResp;
    })();

    Msg.UpdateBuyWeaponReq = (function() {

        /**
         * Properties of an UpdateBuyWeaponReq.
         * @memberof Msg
         * @interface IUpdateBuyWeaponReq
         * @property {string|null} [playerID] UpdateBuyWeaponReq playerID
         * @property {number|Long|null} [weaponID] UpdateBuyWeaponReq weaponID
         * @property {number|Long|null} [type] UpdateBuyWeaponReq type
         */

        /**
         * Constructs a new UpdateBuyWeaponReq.
         * @memberof Msg
         * @classdesc Represents an UpdateBuyWeaponReq.
         * @implements IUpdateBuyWeaponReq
         * @constructor
         * @param {Msg.IUpdateBuyWeaponReq=} [properties] Properties to set
         */
        function UpdateBuyWeaponReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateBuyWeaponReq playerID.
         * @member {string} playerID
         * @memberof Msg.UpdateBuyWeaponReq
         * @instance
         */
        UpdateBuyWeaponReq.prototype.playerID = "";

        /**
         * UpdateBuyWeaponReq weaponID.
         * @member {number|Long} weaponID
         * @memberof Msg.UpdateBuyWeaponReq
         * @instance
         */
        UpdateBuyWeaponReq.prototype.weaponID = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UpdateBuyWeaponReq type.
         * @member {number|Long} type
         * @memberof Msg.UpdateBuyWeaponReq
         * @instance
         */
        UpdateBuyWeaponReq.prototype.type = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UpdateBuyWeaponReq instance using the specified properties.
         * @function create
         * @memberof Msg.UpdateBuyWeaponReq
         * @static
         * @param {Msg.IUpdateBuyWeaponReq=} [properties] Properties to set
         * @returns {Msg.UpdateBuyWeaponReq} UpdateBuyWeaponReq instance
         */
        UpdateBuyWeaponReq.create = function create(properties) {
            return new UpdateBuyWeaponReq(properties);
        };

        /**
         * Encodes the specified UpdateBuyWeaponReq message. Does not implicitly {@link Msg.UpdateBuyWeaponReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.UpdateBuyWeaponReq
         * @static
         * @param {Msg.IUpdateBuyWeaponReq} message UpdateBuyWeaponReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateBuyWeaponReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            if (message.weaponID != null && message.hasOwnProperty("weaponID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.weaponID);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.type);
            return writer;
        };

        /**
         * Encodes the specified UpdateBuyWeaponReq message, length delimited. Does not implicitly {@link Msg.UpdateBuyWeaponReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.UpdateBuyWeaponReq
         * @static
         * @param {Msg.IUpdateBuyWeaponReq} message UpdateBuyWeaponReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateBuyWeaponReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateBuyWeaponReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.UpdateBuyWeaponReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.UpdateBuyWeaponReq} UpdateBuyWeaponReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateBuyWeaponReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.UpdateBuyWeaponReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                case 2:
                    message.weaponID = reader.int64();
                    break;
                case 3:
                    message.type = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateBuyWeaponReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.UpdateBuyWeaponReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.UpdateBuyWeaponReq} UpdateBuyWeaponReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateBuyWeaponReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateBuyWeaponReq message.
         * @function verify
         * @memberof Msg.UpdateBuyWeaponReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateBuyWeaponReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            if (message.weaponID != null && message.hasOwnProperty("weaponID"))
                if (!$util.isInteger(message.weaponID) && !(message.weaponID && $util.isInteger(message.weaponID.low) && $util.isInteger(message.weaponID.high)))
                    return "weaponID: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type) && !(message.type && $util.isInteger(message.type.low) && $util.isInteger(message.type.high)))
                    return "type: integer|Long expected";
            return null;
        };

        /**
         * Creates an UpdateBuyWeaponReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.UpdateBuyWeaponReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.UpdateBuyWeaponReq} UpdateBuyWeaponReq
         */
        UpdateBuyWeaponReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.UpdateBuyWeaponReq)
                return object;
            var message = new $root.Msg.UpdateBuyWeaponReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            if (object.weaponID != null)
                if ($util.Long)
                    (message.weaponID = $util.Long.fromValue(object.weaponID)).unsigned = false;
                else if (typeof object.weaponID === "string")
                    message.weaponID = parseInt(object.weaponID, 10);
                else if (typeof object.weaponID === "number")
                    message.weaponID = object.weaponID;
                else if (typeof object.weaponID === "object")
                    message.weaponID = new $util.LongBits(object.weaponID.low >>> 0, object.weaponID.high >>> 0).toNumber();
            if (object.type != null)
                if ($util.Long)
                    (message.type = $util.Long.fromValue(object.type)).unsigned = false;
                else if (typeof object.type === "string")
                    message.type = parseInt(object.type, 10);
                else if (typeof object.type === "number")
                    message.type = object.type;
                else if (typeof object.type === "object")
                    message.type = new $util.LongBits(object.type.low >>> 0, object.type.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UpdateBuyWeaponReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.UpdateBuyWeaponReq
         * @static
         * @param {Msg.UpdateBuyWeaponReq} message UpdateBuyWeaponReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateBuyWeaponReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerID = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.weaponID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.weaponID = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.type = options.longs === String ? "0" : 0;
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.weaponID != null && message.hasOwnProperty("weaponID"))
                if (typeof message.weaponID === "number")
                    object.weaponID = options.longs === String ? String(message.weaponID) : message.weaponID;
                else
                    object.weaponID = options.longs === String ? $util.Long.prototype.toString.call(message.weaponID) : options.longs === Number ? new $util.LongBits(message.weaponID.low >>> 0, message.weaponID.high >>> 0).toNumber() : message.weaponID;
            if (message.type != null && message.hasOwnProperty("type"))
                if (typeof message.type === "number")
                    object.type = options.longs === String ? String(message.type) : message.type;
                else
                    object.type = options.longs === String ? $util.Long.prototype.toString.call(message.type) : options.longs === Number ? new $util.LongBits(message.type.low >>> 0, message.type.high >>> 0).toNumber() : message.type;
            return object;
        };

        /**
         * Converts this UpdateBuyWeaponReq to JSON.
         * @function toJSON
         * @memberof Msg.UpdateBuyWeaponReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateBuyWeaponReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateBuyWeaponReq;
    })();

    Msg.UpdateBuyWeaponResp = (function() {

        /**
         * Properties of an UpdateBuyWeaponResp.
         * @memberof Msg
         * @interface IUpdateBuyWeaponResp
         * @property {Msg.UpdateBuyWeaponResp.Result|null} [result] UpdateBuyWeaponResp result
         */

        /**
         * Constructs a new UpdateBuyWeaponResp.
         * @memberof Msg
         * @classdesc Represents an UpdateBuyWeaponResp.
         * @implements IUpdateBuyWeaponResp
         * @constructor
         * @param {Msg.IUpdateBuyWeaponResp=} [properties] Properties to set
         */
        function UpdateBuyWeaponResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateBuyWeaponResp result.
         * @member {Msg.UpdateBuyWeaponResp.Result} result
         * @memberof Msg.UpdateBuyWeaponResp
         * @instance
         */
        UpdateBuyWeaponResp.prototype.result = 0;

        /**
         * Creates a new UpdateBuyWeaponResp instance using the specified properties.
         * @function create
         * @memberof Msg.UpdateBuyWeaponResp
         * @static
         * @param {Msg.IUpdateBuyWeaponResp=} [properties] Properties to set
         * @returns {Msg.UpdateBuyWeaponResp} UpdateBuyWeaponResp instance
         */
        UpdateBuyWeaponResp.create = function create(properties) {
            return new UpdateBuyWeaponResp(properties);
        };

        /**
         * Encodes the specified UpdateBuyWeaponResp message. Does not implicitly {@link Msg.UpdateBuyWeaponResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.UpdateBuyWeaponResp
         * @static
         * @param {Msg.IUpdateBuyWeaponResp} message UpdateBuyWeaponResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateBuyWeaponResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified UpdateBuyWeaponResp message, length delimited. Does not implicitly {@link Msg.UpdateBuyWeaponResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.UpdateBuyWeaponResp
         * @static
         * @param {Msg.IUpdateBuyWeaponResp} message UpdateBuyWeaponResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateBuyWeaponResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateBuyWeaponResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.UpdateBuyWeaponResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.UpdateBuyWeaponResp} UpdateBuyWeaponResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateBuyWeaponResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.UpdateBuyWeaponResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateBuyWeaponResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.UpdateBuyWeaponResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.UpdateBuyWeaponResp} UpdateBuyWeaponResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateBuyWeaponResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateBuyWeaponResp message.
         * @function verify
         * @memberof Msg.UpdateBuyWeaponResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateBuyWeaponResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    break;
                }
            return null;
        };

        /**
         * Creates an UpdateBuyWeaponResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.UpdateBuyWeaponResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.UpdateBuyWeaponResp} UpdateBuyWeaponResp
         */
        UpdateBuyWeaponResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.UpdateBuyWeaponResp)
                return object;
            var message = new $root.Msg.UpdateBuyWeaponResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "Success":
            case 1:
                message.result = 1;
                break;
            case "NotEnoughGold":
            case 2:
                message.result = 2;
                break;
            case "NotEnoughDiamond":
            case 3:
                message.result = 3;
                break;
            case "NotEnoughLevel":
            case 4:
                message.result = 4;
                break;
            case "NotEnoughCup":
            case 5:
                message.result = 5;
                break;
            case "NotEnoughStar":
            case 6:
                message.result = 6;
                break;
            case "ReaptedBuy":
            case 7:
                message.result = 7;
                break;
            case "InvalidType":
            case 8:
                message.result = 8;
                break;
            case "InvalidPara":
            case 9:
                message.result = 9;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateBuyWeaponResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.UpdateBuyWeaponResp
         * @static
         * @param {Msg.UpdateBuyWeaponResp} message UpdateBuyWeaponResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateBuyWeaponResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "Internal" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.UpdateBuyWeaponResp.Result[message.result] : message.result;
            return object;
        };

        /**
         * Converts this UpdateBuyWeaponResp to JSON.
         * @function toJSON
         * @memberof Msg.UpdateBuyWeaponResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateBuyWeaponResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.UpdateBuyWeaponResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} Success=1 Success value
         * @property {number} NotEnoughGold=2 NotEnoughGold value
         * @property {number} NotEnoughDiamond=3 NotEnoughDiamond value
         * @property {number} NotEnoughLevel=4 NotEnoughLevel value
         * @property {number} NotEnoughCup=5 NotEnoughCup value
         * @property {number} NotEnoughStar=6 NotEnoughStar value
         * @property {number} ReaptedBuy=7 ReaptedBuy value
         * @property {number} InvalidType=8 InvalidType value
         * @property {number} InvalidPara=9 InvalidPara value
         */
        UpdateBuyWeaponResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "Success"] = 1;
            values[valuesById[2] = "NotEnoughGold"] = 2;
            values[valuesById[3] = "NotEnoughDiamond"] = 3;
            values[valuesById[4] = "NotEnoughLevel"] = 4;
            values[valuesById[5] = "NotEnoughCup"] = 5;
            values[valuesById[6] = "NotEnoughStar"] = 6;
            values[valuesById[7] = "ReaptedBuy"] = 7;
            values[valuesById[8] = "InvalidType"] = 8;
            values[valuesById[9] = "InvalidPara"] = 9;
            return values;
        })();

        return UpdateBuyWeaponResp;
    })();

    Msg.UpdatePlayerFashionReq = (function() {

        /**
         * Properties of an UpdatePlayerFashionReq.
         * @memberof Msg
         * @interface IUpdatePlayerFashionReq
         * @property {string|null} [playerID] UpdatePlayerFashionReq playerID
         * @property {number|Long|null} [oldFashionID] UpdatePlayerFashionReq oldFashionID
         * @property {number|Long|null} [newFashionID] UpdatePlayerFashionReq newFashionID
         */

        /**
         * Constructs a new UpdatePlayerFashionReq.
         * @memberof Msg
         * @classdesc Represents an UpdatePlayerFashionReq.
         * @implements IUpdatePlayerFashionReq
         * @constructor
         * @param {Msg.IUpdatePlayerFashionReq=} [properties] Properties to set
         */
        function UpdatePlayerFashionReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdatePlayerFashionReq playerID.
         * @member {string} playerID
         * @memberof Msg.UpdatePlayerFashionReq
         * @instance
         */
        UpdatePlayerFashionReq.prototype.playerID = "";

        /**
         * UpdatePlayerFashionReq oldFashionID.
         * @member {number|Long} oldFashionID
         * @memberof Msg.UpdatePlayerFashionReq
         * @instance
         */
        UpdatePlayerFashionReq.prototype.oldFashionID = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UpdatePlayerFashionReq newFashionID.
         * @member {number|Long} newFashionID
         * @memberof Msg.UpdatePlayerFashionReq
         * @instance
         */
        UpdatePlayerFashionReq.prototype.newFashionID = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UpdatePlayerFashionReq instance using the specified properties.
         * @function create
         * @memberof Msg.UpdatePlayerFashionReq
         * @static
         * @param {Msg.IUpdatePlayerFashionReq=} [properties] Properties to set
         * @returns {Msg.UpdatePlayerFashionReq} UpdatePlayerFashionReq instance
         */
        UpdatePlayerFashionReq.create = function create(properties) {
            return new UpdatePlayerFashionReq(properties);
        };

        /**
         * Encodes the specified UpdatePlayerFashionReq message. Does not implicitly {@link Msg.UpdatePlayerFashionReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.UpdatePlayerFashionReq
         * @static
         * @param {Msg.IUpdatePlayerFashionReq} message UpdatePlayerFashionReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdatePlayerFashionReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            if (message.oldFashionID != null && message.hasOwnProperty("oldFashionID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.oldFashionID);
            if (message.newFashionID != null && message.hasOwnProperty("newFashionID"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.newFashionID);
            return writer;
        };

        /**
         * Encodes the specified UpdatePlayerFashionReq message, length delimited. Does not implicitly {@link Msg.UpdatePlayerFashionReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.UpdatePlayerFashionReq
         * @static
         * @param {Msg.IUpdatePlayerFashionReq} message UpdatePlayerFashionReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdatePlayerFashionReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdatePlayerFashionReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.UpdatePlayerFashionReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.UpdatePlayerFashionReq} UpdatePlayerFashionReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdatePlayerFashionReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.UpdatePlayerFashionReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                case 2:
                    message.oldFashionID = reader.int64();
                    break;
                case 3:
                    message.newFashionID = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdatePlayerFashionReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.UpdatePlayerFashionReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.UpdatePlayerFashionReq} UpdatePlayerFashionReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdatePlayerFashionReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdatePlayerFashionReq message.
         * @function verify
         * @memberof Msg.UpdatePlayerFashionReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdatePlayerFashionReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            if (message.oldFashionID != null && message.hasOwnProperty("oldFashionID"))
                if (!$util.isInteger(message.oldFashionID) && !(message.oldFashionID && $util.isInteger(message.oldFashionID.low) && $util.isInteger(message.oldFashionID.high)))
                    return "oldFashionID: integer|Long expected";
            if (message.newFashionID != null && message.hasOwnProperty("newFashionID"))
                if (!$util.isInteger(message.newFashionID) && !(message.newFashionID && $util.isInteger(message.newFashionID.low) && $util.isInteger(message.newFashionID.high)))
                    return "newFashionID: integer|Long expected";
            return null;
        };

        /**
         * Creates an UpdatePlayerFashionReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.UpdatePlayerFashionReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.UpdatePlayerFashionReq} UpdatePlayerFashionReq
         */
        UpdatePlayerFashionReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.UpdatePlayerFashionReq)
                return object;
            var message = new $root.Msg.UpdatePlayerFashionReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            if (object.oldFashionID != null)
                if ($util.Long)
                    (message.oldFashionID = $util.Long.fromValue(object.oldFashionID)).unsigned = false;
                else if (typeof object.oldFashionID === "string")
                    message.oldFashionID = parseInt(object.oldFashionID, 10);
                else if (typeof object.oldFashionID === "number")
                    message.oldFashionID = object.oldFashionID;
                else if (typeof object.oldFashionID === "object")
                    message.oldFashionID = new $util.LongBits(object.oldFashionID.low >>> 0, object.oldFashionID.high >>> 0).toNumber();
            if (object.newFashionID != null)
                if ($util.Long)
                    (message.newFashionID = $util.Long.fromValue(object.newFashionID)).unsigned = false;
                else if (typeof object.newFashionID === "string")
                    message.newFashionID = parseInt(object.newFashionID, 10);
                else if (typeof object.newFashionID === "number")
                    message.newFashionID = object.newFashionID;
                else if (typeof object.newFashionID === "object")
                    message.newFashionID = new $util.LongBits(object.newFashionID.low >>> 0, object.newFashionID.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UpdatePlayerFashionReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.UpdatePlayerFashionReq
         * @static
         * @param {Msg.UpdatePlayerFashionReq} message UpdatePlayerFashionReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdatePlayerFashionReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerID = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.oldFashionID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.oldFashionID = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.newFashionID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.newFashionID = options.longs === String ? "0" : 0;
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.oldFashionID != null && message.hasOwnProperty("oldFashionID"))
                if (typeof message.oldFashionID === "number")
                    object.oldFashionID = options.longs === String ? String(message.oldFashionID) : message.oldFashionID;
                else
                    object.oldFashionID = options.longs === String ? $util.Long.prototype.toString.call(message.oldFashionID) : options.longs === Number ? new $util.LongBits(message.oldFashionID.low >>> 0, message.oldFashionID.high >>> 0).toNumber() : message.oldFashionID;
            if (message.newFashionID != null && message.hasOwnProperty("newFashionID"))
                if (typeof message.newFashionID === "number")
                    object.newFashionID = options.longs === String ? String(message.newFashionID) : message.newFashionID;
                else
                    object.newFashionID = options.longs === String ? $util.Long.prototype.toString.call(message.newFashionID) : options.longs === Number ? new $util.LongBits(message.newFashionID.low >>> 0, message.newFashionID.high >>> 0).toNumber() : message.newFashionID;
            return object;
        };

        /**
         * Converts this UpdatePlayerFashionReq to JSON.
         * @function toJSON
         * @memberof Msg.UpdatePlayerFashionReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdatePlayerFashionReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdatePlayerFashionReq;
    })();

    Msg.UpdatePlayerFashionResp = (function() {

        /**
         * Properties of an UpdatePlayerFashionResp.
         * @memberof Msg
         * @interface IUpdatePlayerFashionResp
         * @property {Msg.UpdatePlayerFashionResp.Result|null} [result] UpdatePlayerFashionResp result
         */

        /**
         * Constructs a new UpdatePlayerFashionResp.
         * @memberof Msg
         * @classdesc Represents an UpdatePlayerFashionResp.
         * @implements IUpdatePlayerFashionResp
         * @constructor
         * @param {Msg.IUpdatePlayerFashionResp=} [properties] Properties to set
         */
        function UpdatePlayerFashionResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdatePlayerFashionResp result.
         * @member {Msg.UpdatePlayerFashionResp.Result} result
         * @memberof Msg.UpdatePlayerFashionResp
         * @instance
         */
        UpdatePlayerFashionResp.prototype.result = 0;

        /**
         * Creates a new UpdatePlayerFashionResp instance using the specified properties.
         * @function create
         * @memberof Msg.UpdatePlayerFashionResp
         * @static
         * @param {Msg.IUpdatePlayerFashionResp=} [properties] Properties to set
         * @returns {Msg.UpdatePlayerFashionResp} UpdatePlayerFashionResp instance
         */
        UpdatePlayerFashionResp.create = function create(properties) {
            return new UpdatePlayerFashionResp(properties);
        };

        /**
         * Encodes the specified UpdatePlayerFashionResp message. Does not implicitly {@link Msg.UpdatePlayerFashionResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.UpdatePlayerFashionResp
         * @static
         * @param {Msg.IUpdatePlayerFashionResp} message UpdatePlayerFashionResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdatePlayerFashionResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified UpdatePlayerFashionResp message, length delimited. Does not implicitly {@link Msg.UpdatePlayerFashionResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.UpdatePlayerFashionResp
         * @static
         * @param {Msg.IUpdatePlayerFashionResp} message UpdatePlayerFashionResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdatePlayerFashionResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdatePlayerFashionResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.UpdatePlayerFashionResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.UpdatePlayerFashionResp} UpdatePlayerFashionResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdatePlayerFashionResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.UpdatePlayerFashionResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdatePlayerFashionResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.UpdatePlayerFashionResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.UpdatePlayerFashionResp} UpdatePlayerFashionResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdatePlayerFashionResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdatePlayerFashionResp message.
         * @function verify
         * @memberof Msg.UpdatePlayerFashionResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdatePlayerFashionResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates an UpdatePlayerFashionResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.UpdatePlayerFashionResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.UpdatePlayerFashionResp} UpdatePlayerFashionResp
         */
        UpdatePlayerFashionResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.UpdatePlayerFashionResp)
                return object;
            var message = new $root.Msg.UpdatePlayerFashionResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdatePlayerFashionResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.UpdatePlayerFashionResp
         * @static
         * @param {Msg.UpdatePlayerFashionResp} message UpdatePlayerFashionResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdatePlayerFashionResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "Internal" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.UpdatePlayerFashionResp.Result[message.result] : message.result;
            return object;
        };

        /**
         * Converts this UpdatePlayerFashionResp to JSON.
         * @function toJSON
         * @memberof Msg.UpdatePlayerFashionResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdatePlayerFashionResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.UpdatePlayerFashionResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        UpdatePlayerFashionResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return UpdatePlayerFashionResp;
    })();

    Msg.ErrorData = (function() {

        /**
         * Properties of an ErrorData.
         * @memberof Msg
         * @interface IErrorData
         * @property {Msg.IStatus|null} [status] ErrorData status
         */

        /**
         * Constructs a new ErrorData.
         * @memberof Msg
         * @classdesc Represents an ErrorData.
         * @implements IErrorData
         * @constructor
         * @param {Msg.IErrorData=} [properties] Properties to set
         */
        function ErrorData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ErrorData status.
         * @member {Msg.IStatus|null|undefined} status
         * @memberof Msg.ErrorData
         * @instance
         */
        ErrorData.prototype.status = null;

        /**
         * Creates a new ErrorData instance using the specified properties.
         * @function create
         * @memberof Msg.ErrorData
         * @static
         * @param {Msg.IErrorData=} [properties] Properties to set
         * @returns {Msg.ErrorData} ErrorData instance
         */
        ErrorData.create = function create(properties) {
            return new ErrorData(properties);
        };

        /**
         * Encodes the specified ErrorData message. Does not implicitly {@link Msg.ErrorData.verify|verify} messages.
         * @function encode
         * @memberof Msg.ErrorData
         * @static
         * @param {Msg.IErrorData} message ErrorData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ErrorData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && message.hasOwnProperty("status"))
                $root.Msg.Status.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ErrorData message, length delimited. Does not implicitly {@link Msg.ErrorData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.ErrorData
         * @static
         * @param {Msg.IErrorData} message ErrorData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ErrorData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ErrorData message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.ErrorData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.ErrorData} ErrorData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ErrorData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.ErrorData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = $root.Msg.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ErrorData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.ErrorData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.ErrorData} ErrorData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ErrorData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ErrorData message.
         * @function verify
         * @memberof Msg.ErrorData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ErrorData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.Msg.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates an ErrorData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.ErrorData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.ErrorData} ErrorData
         */
        ErrorData.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.ErrorData)
                return object;
            var message = new $root.Msg.ErrorData();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".Msg.ErrorData.status: object expected");
                message.status = $root.Msg.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from an ErrorData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.ErrorData
         * @static
         * @param {Msg.ErrorData} message ErrorData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ErrorData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.Msg.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this ErrorData to JSON.
         * @function toJSON
         * @memberof Msg.ErrorData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ErrorData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ErrorData;
    })();

    Msg.GateError = (function() {

        /**
         * Properties of a GateError.
         * @memberof Msg
         * @interface IGateError
         * @property {Msg.IStatus|null} [status] GateError status
         */

        /**
         * Constructs a new GateError.
         * @memberof Msg
         * @classdesc Represents a GateError.
         * @implements IGateError
         * @constructor
         * @param {Msg.IGateError=} [properties] Properties to set
         */
        function GateError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GateError status.
         * @member {Msg.IStatus|null|undefined} status
         * @memberof Msg.GateError
         * @instance
         */
        GateError.prototype.status = null;

        /**
         * Creates a new GateError instance using the specified properties.
         * @function create
         * @memberof Msg.GateError
         * @static
         * @param {Msg.IGateError=} [properties] Properties to set
         * @returns {Msg.GateError} GateError instance
         */
        GateError.create = function create(properties) {
            return new GateError(properties);
        };

        /**
         * Encodes the specified GateError message. Does not implicitly {@link Msg.GateError.verify|verify} messages.
         * @function encode
         * @memberof Msg.GateError
         * @static
         * @param {Msg.IGateError} message GateError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GateError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && message.hasOwnProperty("status"))
                $root.Msg.Status.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GateError message, length delimited. Does not implicitly {@link Msg.GateError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GateError
         * @static
         * @param {Msg.IGateError} message GateError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GateError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GateError message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GateError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GateError} GateError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GateError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GateError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = $root.Msg.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GateError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GateError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GateError} GateError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GateError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GateError message.
         * @function verify
         * @memberof Msg.GateError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GateError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.Msg.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a GateError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GateError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GateError} GateError
         */
        GateError.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GateError)
                return object;
            var message = new $root.Msg.GateError();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".Msg.GateError.status: object expected");
                message.status = $root.Msg.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a GateError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GateError
         * @static
         * @param {Msg.GateError} message GateError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GateError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.Msg.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this GateError to JSON.
         * @function toJSON
         * @memberof Msg.GateError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GateError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GateError;
    })();

    Msg.HeartBeatReq = (function() {

        /**
         * Properties of a HeartBeatReq.
         * @memberof Msg
         * @interface IHeartBeatReq
         * @property {string|null} [playerID] HeartBeatReq playerID
         */

        /**
         * Constructs a new HeartBeatReq.
         * @memberof Msg
         * @classdesc Represents a HeartBeatReq.
         * @implements IHeartBeatReq
         * @constructor
         * @param {Msg.IHeartBeatReq=} [properties] Properties to set
         */
        function HeartBeatReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeartBeatReq playerID.
         * @member {string} playerID
         * @memberof Msg.HeartBeatReq
         * @instance
         */
        HeartBeatReq.prototype.playerID = "";

        /**
         * Creates a new HeartBeatReq instance using the specified properties.
         * @function create
         * @memberof Msg.HeartBeatReq
         * @static
         * @param {Msg.IHeartBeatReq=} [properties] Properties to set
         * @returns {Msg.HeartBeatReq} HeartBeatReq instance
         */
        HeartBeatReq.create = function create(properties) {
            return new HeartBeatReq(properties);
        };

        /**
         * Encodes the specified HeartBeatReq message. Does not implicitly {@link Msg.HeartBeatReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.HeartBeatReq
         * @static
         * @param {Msg.IHeartBeatReq} message HeartBeatReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartBeatReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified HeartBeatReq message, length delimited. Does not implicitly {@link Msg.HeartBeatReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.HeartBeatReq
         * @static
         * @param {Msg.IHeartBeatReq} message HeartBeatReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartBeatReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeartBeatReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.HeartBeatReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.HeartBeatReq} HeartBeatReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartBeatReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.HeartBeatReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeartBeatReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.HeartBeatReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.HeartBeatReq} HeartBeatReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartBeatReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeartBeatReq message.
         * @function verify
         * @memberof Msg.HeartBeatReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeartBeatReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a HeartBeatReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.HeartBeatReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.HeartBeatReq} HeartBeatReq
         */
        HeartBeatReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.HeartBeatReq)
                return object;
            var message = new $root.Msg.HeartBeatReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a HeartBeatReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.HeartBeatReq
         * @static
         * @param {Msg.HeartBeatReq} message HeartBeatReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeartBeatReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playerID = "";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this HeartBeatReq to JSON.
         * @function toJSON
         * @memberof Msg.HeartBeatReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeartBeatReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HeartBeatReq;
    })();

    Msg.HeartBeatResp = (function() {

        /**
         * Properties of a HeartBeatResp.
         * @memberof Msg
         * @interface IHeartBeatResp
         * @property {Msg.HeartBeatResp.Result|null} [result] HeartBeatResp result
         * @property {number|Long|null} [ts] HeartBeatResp ts
         */

        /**
         * Constructs a new HeartBeatResp.
         * @memberof Msg
         * @classdesc Represents a HeartBeatResp.
         * @implements IHeartBeatResp
         * @constructor
         * @param {Msg.IHeartBeatResp=} [properties] Properties to set
         */
        function HeartBeatResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeartBeatResp result.
         * @member {Msg.HeartBeatResp.Result} result
         * @memberof Msg.HeartBeatResp
         * @instance
         */
        HeartBeatResp.prototype.result = 0;

        /**
         * HeartBeatResp ts.
         * @member {number|Long} ts
         * @memberof Msg.HeartBeatResp
         * @instance
         */
        HeartBeatResp.prototype.ts = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new HeartBeatResp instance using the specified properties.
         * @function create
         * @memberof Msg.HeartBeatResp
         * @static
         * @param {Msg.IHeartBeatResp=} [properties] Properties to set
         * @returns {Msg.HeartBeatResp} HeartBeatResp instance
         */
        HeartBeatResp.create = function create(properties) {
            return new HeartBeatResp(properties);
        };

        /**
         * Encodes the specified HeartBeatResp message. Does not implicitly {@link Msg.HeartBeatResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.HeartBeatResp
         * @static
         * @param {Msg.IHeartBeatResp} message HeartBeatResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartBeatResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.ts != null && message.hasOwnProperty("ts"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.ts);
            return writer;
        };

        /**
         * Encodes the specified HeartBeatResp message, length delimited. Does not implicitly {@link Msg.HeartBeatResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.HeartBeatResp
         * @static
         * @param {Msg.IHeartBeatResp} message HeartBeatResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeartBeatResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeartBeatResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.HeartBeatResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.HeartBeatResp} HeartBeatResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartBeatResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.HeartBeatResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.ts = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeartBeatResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.HeartBeatResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.HeartBeatResp} HeartBeatResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeartBeatResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeartBeatResp message.
         * @function verify
         * @memberof Msg.HeartBeatResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeartBeatResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.ts != null && message.hasOwnProperty("ts"))
                if (!$util.isInteger(message.ts) && !(message.ts && $util.isInteger(message.ts.low) && $util.isInteger(message.ts.high)))
                    return "ts: integer|Long expected";
            return null;
        };

        /**
         * Creates a HeartBeatResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.HeartBeatResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.HeartBeatResp} HeartBeatResp
         */
        HeartBeatResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.HeartBeatResp)
                return object;
            var message = new $root.Msg.HeartBeatResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            if (object.ts != null)
                if ($util.Long)
                    (message.ts = $util.Long.fromValue(object.ts)).unsigned = false;
                else if (typeof object.ts === "string")
                    message.ts = parseInt(object.ts, 10);
                else if (typeof object.ts === "number")
                    message.ts = object.ts;
                else if (typeof object.ts === "object")
                    message.ts = new $util.LongBits(object.ts.low >>> 0, object.ts.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a HeartBeatResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.HeartBeatResp
         * @static
         * @param {Msg.HeartBeatResp} message HeartBeatResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HeartBeatResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "Internal" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.ts = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ts = options.longs === String ? "0" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.HeartBeatResp.Result[message.result] : message.result;
            if (message.ts != null && message.hasOwnProperty("ts"))
                if (typeof message.ts === "number")
                    object.ts = options.longs === String ? String(message.ts) : message.ts;
                else
                    object.ts = options.longs === String ? $util.Long.prototype.toString.call(message.ts) : options.longs === Number ? new $util.LongBits(message.ts.low >>> 0, message.ts.high >>> 0).toNumber() : message.ts;
            return object;
        };

        /**
         * Converts this HeartBeatResp to JSON.
         * @function toJSON
         * @memberof Msg.HeartBeatResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HeartBeatResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.HeartBeatResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        HeartBeatResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return HeartBeatResp;
    })();

    Msg.LoginReq = (function() {

        /**
         * Properties of a LoginReq.
         * @memberof Msg
         * @interface ILoginReq
         * @property {string|null} [username] LoginReq username
         * @property {string|null} [password] LoginReq password
         */

        /**
         * Constructs a new LoginReq.
         * @memberof Msg
         * @classdesc Represents a LoginReq.
         * @implements ILoginReq
         * @constructor
         * @param {Msg.ILoginReq=} [properties] Properties to set
         */
        function LoginReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginReq username.
         * @member {string} username
         * @memberof Msg.LoginReq
         * @instance
         */
        LoginReq.prototype.username = "";

        /**
         * LoginReq password.
         * @member {string} password
         * @memberof Msg.LoginReq
         * @instance
         */
        LoginReq.prototype.password = "";

        /**
         * Creates a new LoginReq instance using the specified properties.
         * @function create
         * @memberof Msg.LoginReq
         * @static
         * @param {Msg.ILoginReq=} [properties] Properties to set
         * @returns {Msg.LoginReq} LoginReq instance
         */
        LoginReq.create = function create(properties) {
            return new LoginReq(properties);
        };

        /**
         * Encodes the specified LoginReq message. Does not implicitly {@link Msg.LoginReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.LoginReq
         * @static
         * @param {Msg.ILoginReq} message LoginReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
            if (message.password != null && message.hasOwnProperty("password"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
            return writer;
        };

        /**
         * Encodes the specified LoginReq message, length delimited. Does not implicitly {@link Msg.LoginReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.LoginReq
         * @static
         * @param {Msg.ILoginReq} message LoginReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.LoginReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.LoginReq} LoginReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.LoginReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.username = reader.string();
                    break;
                case 2:
                    message.password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.LoginReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.LoginReq} LoginReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginReq message.
         * @function verify
         * @memberof Msg.LoginReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            return null;
        };

        /**
         * Creates a LoginReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.LoginReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.LoginReq} LoginReq
         */
        LoginReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.LoginReq)
                return object;
            var message = new $root.Msg.LoginReq();
            if (object.username != null)
                message.username = String(object.username);
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };

        /**
         * Creates a plain object from a LoginReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.LoginReq
         * @static
         * @param {Msg.LoginReq} message LoginReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.username = "";
                object.password = "";
            }
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            return object;
        };

        /**
         * Converts this LoginReq to JSON.
         * @function toJSON
         * @memberof Msg.LoginReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LoginReq;
    })();

    Msg.LoginResp = (function() {

        /**
         * Properties of a LoginResp.
         * @memberof Msg
         * @interface ILoginResp
         * @property {Msg.LoginResp.Result|null} [result] LoginResp result
         * @property {string|null} [playerID] LoginResp playerID
         */

        /**
         * Constructs a new LoginResp.
         * @memberof Msg
         * @classdesc Represents a LoginResp.
         * @implements ILoginResp
         * @constructor
         * @param {Msg.ILoginResp=} [properties] Properties to set
         */
        function LoginResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginResp result.
         * @member {Msg.LoginResp.Result} result
         * @memberof Msg.LoginResp
         * @instance
         */
        LoginResp.prototype.result = 0;

        /**
         * LoginResp playerID.
         * @member {string} playerID
         * @memberof Msg.LoginResp
         * @instance
         */
        LoginResp.prototype.playerID = "";

        /**
         * Creates a new LoginResp instance using the specified properties.
         * @function create
         * @memberof Msg.LoginResp
         * @static
         * @param {Msg.ILoginResp=} [properties] Properties to set
         * @returns {Msg.LoginResp} LoginResp instance
         */
        LoginResp.create = function create(properties) {
            return new LoginResp(properties);
        };

        /**
         * Encodes the specified LoginResp message. Does not implicitly {@link Msg.LoginResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.LoginResp
         * @static
         * @param {Msg.ILoginResp} message LoginResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified LoginResp message, length delimited. Does not implicitly {@link Msg.LoginResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.LoginResp
         * @static
         * @param {Msg.ILoginResp} message LoginResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.LoginResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.LoginResp} LoginResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.LoginResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.LoginResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.LoginResp} LoginResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginResp message.
         * @function verify
         * @memberof Msg.LoginResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a LoginResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.LoginResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.LoginResp} LoginResp
         */
        LoginResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.LoginResp)
                return object;
            var message = new $root.Msg.LoginResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a LoginResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.LoginResp
         * @static
         * @param {Msg.LoginResp} message LoginResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "Internal" : 0;
                object.playerID = "";
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.LoginResp.Result[message.result] : message.result;
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this LoginResp to JSON.
         * @function toJSON
         * @memberof Msg.LoginResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.LoginResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        LoginResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return LoginResp;
    })();

    Msg.WXLoginReq = (function() {

        /**
         * Properties of a WXLoginReq.
         * @memberof Msg
         * @interface IWXLoginReq
         * @property {string|null} [code] WXLoginReq code
         * @property {string|null} [encryptedData] WXLoginReq encryptedData
         * @property {string|null} [iv] WXLoginReq iv
         */

        /**
         * Constructs a new WXLoginReq.
         * @memberof Msg
         * @classdesc Represents a WXLoginReq.
         * @implements IWXLoginReq
         * @constructor
         * @param {Msg.IWXLoginReq=} [properties] Properties to set
         */
        function WXLoginReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WXLoginReq code.
         * @member {string} code
         * @memberof Msg.WXLoginReq
         * @instance
         */
        WXLoginReq.prototype.code = "";

        /**
         * WXLoginReq encryptedData.
         * @member {string} encryptedData
         * @memberof Msg.WXLoginReq
         * @instance
         */
        WXLoginReq.prototype.encryptedData = "";

        /**
         * WXLoginReq iv.
         * @member {string} iv
         * @memberof Msg.WXLoginReq
         * @instance
         */
        WXLoginReq.prototype.iv = "";

        /**
         * Creates a new WXLoginReq instance using the specified properties.
         * @function create
         * @memberof Msg.WXLoginReq
         * @static
         * @param {Msg.IWXLoginReq=} [properties] Properties to set
         * @returns {Msg.WXLoginReq} WXLoginReq instance
         */
        WXLoginReq.create = function create(properties) {
            return new WXLoginReq(properties);
        };

        /**
         * Encodes the specified WXLoginReq message. Does not implicitly {@link Msg.WXLoginReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.WXLoginReq
         * @static
         * @param {Msg.IWXLoginReq} message WXLoginReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WXLoginReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && message.hasOwnProperty("code"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.encryptedData);
            if (message.iv != null && message.hasOwnProperty("iv"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.iv);
            return writer;
        };

        /**
         * Encodes the specified WXLoginReq message, length delimited. Does not implicitly {@link Msg.WXLoginReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.WXLoginReq
         * @static
         * @param {Msg.IWXLoginReq} message WXLoginReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WXLoginReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WXLoginReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.WXLoginReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.WXLoginReq} WXLoginReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WXLoginReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.WXLoginReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.string();
                    break;
                case 2:
                    message.encryptedData = reader.string();
                    break;
                case 3:
                    message.iv = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WXLoginReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.WXLoginReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.WXLoginReq} WXLoginReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WXLoginReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WXLoginReq message.
         * @function verify
         * @memberof Msg.WXLoginReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WXLoginReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isString(message.code))
                    return "code: string expected";
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                if (!$util.isString(message.encryptedData))
                    return "encryptedData: string expected";
            if (message.iv != null && message.hasOwnProperty("iv"))
                if (!$util.isString(message.iv))
                    return "iv: string expected";
            return null;
        };

        /**
         * Creates a WXLoginReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.WXLoginReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.WXLoginReq} WXLoginReq
         */
        WXLoginReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.WXLoginReq)
                return object;
            var message = new $root.Msg.WXLoginReq();
            if (object.code != null)
                message.code = String(object.code);
            if (object.encryptedData != null)
                message.encryptedData = String(object.encryptedData);
            if (object.iv != null)
                message.iv = String(object.iv);
            return message;
        };

        /**
         * Creates a plain object from a WXLoginReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.WXLoginReq
         * @static
         * @param {Msg.WXLoginReq} message WXLoginReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WXLoginReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.code = "";
                object.encryptedData = "";
                object.iv = "";
            }
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                object.encryptedData = message.encryptedData;
            if (message.iv != null && message.hasOwnProperty("iv"))
                object.iv = message.iv;
            return object;
        };

        /**
         * Converts this WXLoginReq to JSON.
         * @function toJSON
         * @memberof Msg.WXLoginReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WXLoginReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WXLoginReq;
    })();

    Msg.WXLoginResp = (function() {

        /**
         * Properties of a WXLoginResp.
         * @memberof Msg
         * @interface IWXLoginResp
         * @property {Msg.WXLoginResp.Result|null} [result] WXLoginResp result
         * @property {string|null} [playerID] WXLoginResp playerID
         */

        /**
         * Constructs a new WXLoginResp.
         * @memberof Msg
         * @classdesc Represents a WXLoginResp.
         * @implements IWXLoginResp
         * @constructor
         * @param {Msg.IWXLoginResp=} [properties] Properties to set
         */
        function WXLoginResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WXLoginResp result.
         * @member {Msg.WXLoginResp.Result} result
         * @memberof Msg.WXLoginResp
         * @instance
         */
        WXLoginResp.prototype.result = 0;

        /**
         * WXLoginResp playerID.
         * @member {string} playerID
         * @memberof Msg.WXLoginResp
         * @instance
         */
        WXLoginResp.prototype.playerID = "";

        /**
         * Creates a new WXLoginResp instance using the specified properties.
         * @function create
         * @memberof Msg.WXLoginResp
         * @static
         * @param {Msg.IWXLoginResp=} [properties] Properties to set
         * @returns {Msg.WXLoginResp} WXLoginResp instance
         */
        WXLoginResp.create = function create(properties) {
            return new WXLoginResp(properties);
        };

        /**
         * Encodes the specified WXLoginResp message. Does not implicitly {@link Msg.WXLoginResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.WXLoginResp
         * @static
         * @param {Msg.IWXLoginResp} message WXLoginResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WXLoginResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified WXLoginResp message, length delimited. Does not implicitly {@link Msg.WXLoginResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.WXLoginResp
         * @static
         * @param {Msg.IWXLoginResp} message WXLoginResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WXLoginResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WXLoginResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.WXLoginResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.WXLoginResp} WXLoginResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WXLoginResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.WXLoginResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WXLoginResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.WXLoginResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.WXLoginResp} WXLoginResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WXLoginResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WXLoginResp message.
         * @function verify
         * @memberof Msg.WXLoginResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WXLoginResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a WXLoginResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.WXLoginResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.WXLoginResp} WXLoginResp
         */
        WXLoginResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.WXLoginResp)
                return object;
            var message = new $root.Msg.WXLoginResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a WXLoginResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.WXLoginResp
         * @static
         * @param {Msg.WXLoginResp} message WXLoginResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WXLoginResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "Internal" : 0;
                object.playerID = "";
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.WXLoginResp.Result[message.result] : message.result;
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this WXLoginResp to JSON.
         * @function toJSON
         * @memberof Msg.WXLoginResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WXLoginResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.WXLoginResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        WXLoginResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return WXLoginResp;
    })();

    Msg.GetGlobalMailReq = (function() {

        /**
         * Properties of a GetGlobalMailReq.
         * @memberof Msg
         * @interface IGetGlobalMailReq
         * @property {number|Long|null} [playerID] GetGlobalMailReq playerID
         */

        /**
         * Constructs a new GetGlobalMailReq.
         * @memberof Msg
         * @classdesc Represents a GetGlobalMailReq.
         * @implements IGetGlobalMailReq
         * @constructor
         * @param {Msg.IGetGlobalMailReq=} [properties] Properties to set
         */
        function GetGlobalMailReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetGlobalMailReq playerID.
         * @member {number|Long} playerID
         * @memberof Msg.GetGlobalMailReq
         * @instance
         */
        GetGlobalMailReq.prototype.playerID = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GetGlobalMailReq instance using the specified properties.
         * @function create
         * @memberof Msg.GetGlobalMailReq
         * @static
         * @param {Msg.IGetGlobalMailReq=} [properties] Properties to set
         * @returns {Msg.GetGlobalMailReq} GetGlobalMailReq instance
         */
        GetGlobalMailReq.create = function create(properties) {
            return new GetGlobalMailReq(properties);
        };

        /**
         * Encodes the specified GetGlobalMailReq message. Does not implicitly {@link Msg.GetGlobalMailReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetGlobalMailReq
         * @static
         * @param {Msg.IGetGlobalMailReq} message GetGlobalMailReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetGlobalMailReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified GetGlobalMailReq message, length delimited. Does not implicitly {@link Msg.GetGlobalMailReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetGlobalMailReq
         * @static
         * @param {Msg.IGetGlobalMailReq} message GetGlobalMailReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetGlobalMailReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetGlobalMailReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetGlobalMailReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetGlobalMailReq} GetGlobalMailReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetGlobalMailReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetGlobalMailReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetGlobalMailReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetGlobalMailReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetGlobalMailReq} GetGlobalMailReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetGlobalMailReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetGlobalMailReq message.
         * @function verify
         * @memberof Msg.GetGlobalMailReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetGlobalMailReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isInteger(message.playerID) && !(message.playerID && $util.isInteger(message.playerID.low) && $util.isInteger(message.playerID.high)))
                    return "playerID: integer|Long expected";
            return null;
        };

        /**
         * Creates a GetGlobalMailReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetGlobalMailReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetGlobalMailReq} GetGlobalMailReq
         */
        GetGlobalMailReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetGlobalMailReq)
                return object;
            var message = new $root.Msg.GetGlobalMailReq();
            if (object.playerID != null)
                if ($util.Long)
                    (message.playerID = $util.Long.fromValue(object.playerID)).unsigned = false;
                else if (typeof object.playerID === "string")
                    message.playerID = parseInt(object.playerID, 10);
                else if (typeof object.playerID === "number")
                    message.playerID = object.playerID;
                else if (typeof object.playerID === "object")
                    message.playerID = new $util.LongBits(object.playerID.low >>> 0, object.playerID.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GetGlobalMailReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetGlobalMailReq
         * @static
         * @param {Msg.GetGlobalMailReq} message GetGlobalMailReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetGlobalMailReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.playerID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.playerID = options.longs === String ? "0" : 0;
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (typeof message.playerID === "number")
                    object.playerID = options.longs === String ? String(message.playerID) : message.playerID;
                else
                    object.playerID = options.longs === String ? $util.Long.prototype.toString.call(message.playerID) : options.longs === Number ? new $util.LongBits(message.playerID.low >>> 0, message.playerID.high >>> 0).toNumber() : message.playerID;
            return object;
        };

        /**
         * Converts this GetGlobalMailReq to JSON.
         * @function toJSON
         * @memberof Msg.GetGlobalMailReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetGlobalMailReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetGlobalMailReq;
    })();

    Msg.GetGlobalMailResp = (function() {

        /**
         * Properties of a GetGlobalMailResp.
         * @memberof Msg
         * @interface IGetGlobalMailResp
         * @property {Msg.IStatus|null} [status] GetGlobalMailResp status
         * @property {Array.<Msg.GetGlobalMailResp.IMail>|null} [mails] GetGlobalMailResp mails
         * @property {number|Long|null} [now] GetGlobalMailResp now
         * @property {number|Long|null} [latestCreatedTime] GetGlobalMailResp latestCreatedTime
         */

        /**
         * Constructs a new GetGlobalMailResp.
         * @memberof Msg
         * @classdesc Represents a GetGlobalMailResp.
         * @implements IGetGlobalMailResp
         * @constructor
         * @param {Msg.IGetGlobalMailResp=} [properties] Properties to set
         */
        function GetGlobalMailResp(properties) {
            this.mails = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetGlobalMailResp status.
         * @member {Msg.IStatus|null|undefined} status
         * @memberof Msg.GetGlobalMailResp
         * @instance
         */
        GetGlobalMailResp.prototype.status = null;

        /**
         * GetGlobalMailResp mails.
         * @member {Array.<Msg.GetGlobalMailResp.IMail>} mails
         * @memberof Msg.GetGlobalMailResp
         * @instance
         */
        GetGlobalMailResp.prototype.mails = $util.emptyArray;

        /**
         * GetGlobalMailResp now.
         * @member {number|Long} now
         * @memberof Msg.GetGlobalMailResp
         * @instance
         */
        GetGlobalMailResp.prototype.now = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GetGlobalMailResp latestCreatedTime.
         * @member {number|Long} latestCreatedTime
         * @memberof Msg.GetGlobalMailResp
         * @instance
         */
        GetGlobalMailResp.prototype.latestCreatedTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GetGlobalMailResp instance using the specified properties.
         * @function create
         * @memberof Msg.GetGlobalMailResp
         * @static
         * @param {Msg.IGetGlobalMailResp=} [properties] Properties to set
         * @returns {Msg.GetGlobalMailResp} GetGlobalMailResp instance
         */
        GetGlobalMailResp.create = function create(properties) {
            return new GetGlobalMailResp(properties);
        };

        /**
         * Encodes the specified GetGlobalMailResp message. Does not implicitly {@link Msg.GetGlobalMailResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetGlobalMailResp
         * @static
         * @param {Msg.IGetGlobalMailResp} message GetGlobalMailResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetGlobalMailResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && message.hasOwnProperty("status"))
                $root.Msg.Status.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.mails != null && message.mails.length)
                for (var i = 0; i < message.mails.length; ++i)
                    $root.Msg.GetGlobalMailResp.Mail.encode(message.mails[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.now != null && message.hasOwnProperty("now"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.now);
            if (message.latestCreatedTime != null && message.hasOwnProperty("latestCreatedTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.latestCreatedTime);
            return writer;
        };

        /**
         * Encodes the specified GetGlobalMailResp message, length delimited. Does not implicitly {@link Msg.GetGlobalMailResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetGlobalMailResp
         * @static
         * @param {Msg.IGetGlobalMailResp} message GetGlobalMailResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetGlobalMailResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetGlobalMailResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetGlobalMailResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetGlobalMailResp} GetGlobalMailResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetGlobalMailResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetGlobalMailResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = $root.Msg.Status.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.mails && message.mails.length))
                        message.mails = [];
                    message.mails.push($root.Msg.GetGlobalMailResp.Mail.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.now = reader.int64();
                    break;
                case 4:
                    message.latestCreatedTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetGlobalMailResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetGlobalMailResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetGlobalMailResp} GetGlobalMailResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetGlobalMailResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetGlobalMailResp message.
         * @function verify
         * @memberof Msg.GetGlobalMailResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetGlobalMailResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.Msg.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.mails != null && message.hasOwnProperty("mails")) {
                if (!Array.isArray(message.mails))
                    return "mails: array expected";
                for (var i = 0; i < message.mails.length; ++i) {
                    var error = $root.Msg.GetGlobalMailResp.Mail.verify(message.mails[i]);
                    if (error)
                        return "mails." + error;
                }
            }
            if (message.now != null && message.hasOwnProperty("now"))
                if (!$util.isInteger(message.now) && !(message.now && $util.isInteger(message.now.low) && $util.isInteger(message.now.high)))
                    return "now: integer|Long expected";
            if (message.latestCreatedTime != null && message.hasOwnProperty("latestCreatedTime"))
                if (!$util.isInteger(message.latestCreatedTime) && !(message.latestCreatedTime && $util.isInteger(message.latestCreatedTime.low) && $util.isInteger(message.latestCreatedTime.high)))
                    return "latestCreatedTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a GetGlobalMailResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetGlobalMailResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetGlobalMailResp} GetGlobalMailResp
         */
        GetGlobalMailResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetGlobalMailResp)
                return object;
            var message = new $root.Msg.GetGlobalMailResp();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".Msg.GetGlobalMailResp.status: object expected");
                message.status = $root.Msg.Status.fromObject(object.status);
            }
            if (object.mails) {
                if (!Array.isArray(object.mails))
                    throw TypeError(".Msg.GetGlobalMailResp.mails: array expected");
                message.mails = [];
                for (var i = 0; i < object.mails.length; ++i) {
                    if (typeof object.mails[i] !== "object")
                        throw TypeError(".Msg.GetGlobalMailResp.mails: object expected");
                    message.mails[i] = $root.Msg.GetGlobalMailResp.Mail.fromObject(object.mails[i]);
                }
            }
            if (object.now != null)
                if ($util.Long)
                    (message.now = $util.Long.fromValue(object.now)).unsigned = false;
                else if (typeof object.now === "string")
                    message.now = parseInt(object.now, 10);
                else if (typeof object.now === "number")
                    message.now = object.now;
                else if (typeof object.now === "object")
                    message.now = new $util.LongBits(object.now.low >>> 0, object.now.high >>> 0).toNumber();
            if (object.latestCreatedTime != null)
                if ($util.Long)
                    (message.latestCreatedTime = $util.Long.fromValue(object.latestCreatedTime)).unsigned = false;
                else if (typeof object.latestCreatedTime === "string")
                    message.latestCreatedTime = parseInt(object.latestCreatedTime, 10);
                else if (typeof object.latestCreatedTime === "number")
                    message.latestCreatedTime = object.latestCreatedTime;
                else if (typeof object.latestCreatedTime === "object")
                    message.latestCreatedTime = new $util.LongBits(object.latestCreatedTime.low >>> 0, object.latestCreatedTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GetGlobalMailResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetGlobalMailResp
         * @static
         * @param {Msg.GetGlobalMailResp} message GetGlobalMailResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetGlobalMailResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mails = [];
            if (options.defaults) {
                object.status = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.now = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.now = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestCreatedTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestCreatedTime = options.longs === String ? "0" : 0;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.Msg.Status.toObject(message.status, options);
            if (message.mails && message.mails.length) {
                object.mails = [];
                for (var j = 0; j < message.mails.length; ++j)
                    object.mails[j] = $root.Msg.GetGlobalMailResp.Mail.toObject(message.mails[j], options);
            }
            if (message.now != null && message.hasOwnProperty("now"))
                if (typeof message.now === "number")
                    object.now = options.longs === String ? String(message.now) : message.now;
                else
                    object.now = options.longs === String ? $util.Long.prototype.toString.call(message.now) : options.longs === Number ? new $util.LongBits(message.now.low >>> 0, message.now.high >>> 0).toNumber() : message.now;
            if (message.latestCreatedTime != null && message.hasOwnProperty("latestCreatedTime"))
                if (typeof message.latestCreatedTime === "number")
                    object.latestCreatedTime = options.longs === String ? String(message.latestCreatedTime) : message.latestCreatedTime;
                else
                    object.latestCreatedTime = options.longs === String ? $util.Long.prototype.toString.call(message.latestCreatedTime) : options.longs === Number ? new $util.LongBits(message.latestCreatedTime.low >>> 0, message.latestCreatedTime.high >>> 0).toNumber() : message.latestCreatedTime;
            return object;
        };

        /**
         * Converts this GetGlobalMailResp to JSON.
         * @function toJSON
         * @memberof Msg.GetGlobalMailResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetGlobalMailResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        GetGlobalMailResp.Mail = (function() {

            /**
             * Properties of a Mail.
             * @memberof Msg.GetGlobalMailResp
             * @interface IMail
             * @property {number|null} [id] Mail id
             * @property {number|Long|null} [indate] Mail indate
             * @property {number|Long|null} [createdAt] Mail createdAt
             * @property {number|null} [icon] Mail icon
             * @property {string|null} [title] Mail title
             * @property {string|null} [content] Mail content
             * @property {Array.<Msg.IAwardItem>|null} [award] Mail award
             * @property {boolean|null} [received] Mail received
             */

            /**
             * Constructs a new Mail.
             * @memberof Msg.GetGlobalMailResp
             * @classdesc Represents a Mail.
             * @implements IMail
             * @constructor
             * @param {Msg.GetGlobalMailResp.IMail=} [properties] Properties to set
             */
            function Mail(properties) {
                this.award = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Mail id.
             * @member {number} id
             * @memberof Msg.GetGlobalMailResp.Mail
             * @instance
             */
            Mail.prototype.id = 0;

            /**
             * Mail indate.
             * @member {number|Long} indate
             * @memberof Msg.GetGlobalMailResp.Mail
             * @instance
             */
            Mail.prototype.indate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Mail createdAt.
             * @member {number|Long} createdAt
             * @memberof Msg.GetGlobalMailResp.Mail
             * @instance
             */
            Mail.prototype.createdAt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Mail icon.
             * @member {number} icon
             * @memberof Msg.GetGlobalMailResp.Mail
             * @instance
             */
            Mail.prototype.icon = 0;

            /**
             * Mail title.
             * @member {string} title
             * @memberof Msg.GetGlobalMailResp.Mail
             * @instance
             */
            Mail.prototype.title = "";

            /**
             * Mail content.
             * @member {string} content
             * @memberof Msg.GetGlobalMailResp.Mail
             * @instance
             */
            Mail.prototype.content = "";

            /**
             * Mail award.
             * @member {Array.<Msg.IAwardItem>} award
             * @memberof Msg.GetGlobalMailResp.Mail
             * @instance
             */
            Mail.prototype.award = $util.emptyArray;

            /**
             * Mail received.
             * @member {boolean} received
             * @memberof Msg.GetGlobalMailResp.Mail
             * @instance
             */
            Mail.prototype.received = false;

            /**
             * Creates a new Mail instance using the specified properties.
             * @function create
             * @memberof Msg.GetGlobalMailResp.Mail
             * @static
             * @param {Msg.GetGlobalMailResp.IMail=} [properties] Properties to set
             * @returns {Msg.GetGlobalMailResp.Mail} Mail instance
             */
            Mail.create = function create(properties) {
                return new Mail(properties);
            };

            /**
             * Encodes the specified Mail message. Does not implicitly {@link Msg.GetGlobalMailResp.Mail.verify|verify} messages.
             * @function encode
             * @memberof Msg.GetGlobalMailResp.Mail
             * @static
             * @param {Msg.GetGlobalMailResp.IMail} message Mail message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Mail.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                if (message.indate != null && message.hasOwnProperty("indate"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.indate);
                if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.createdAt);
                if (message.icon != null && message.hasOwnProperty("icon"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.icon);
                if (message.title != null && message.hasOwnProperty("title"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.title);
                if (message.content != null && message.hasOwnProperty("content"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.content);
                if (message.award != null && message.award.length)
                    for (var i = 0; i < message.award.length; ++i)
                        $root.Msg.AwardItem.encode(message.award[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.received != null && message.hasOwnProperty("received"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.received);
                return writer;
            };

            /**
             * Encodes the specified Mail message, length delimited. Does not implicitly {@link Msg.GetGlobalMailResp.Mail.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.GetGlobalMailResp.Mail
             * @static
             * @param {Msg.GetGlobalMailResp.IMail} message Mail message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Mail.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Mail message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.GetGlobalMailResp.Mail
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.GetGlobalMailResp.Mail} Mail
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Mail.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetGlobalMailResp.Mail();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.indate = reader.int64();
                        break;
                    case 3:
                        message.createdAt = reader.int64();
                        break;
                    case 4:
                        message.icon = reader.int32();
                        break;
                    case 5:
                        message.title = reader.string();
                        break;
                    case 6:
                        message.content = reader.string();
                        break;
                    case 7:
                        if (!(message.award && message.award.length))
                            message.award = [];
                        message.award.push($root.Msg.AwardItem.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.received = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Mail message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.GetGlobalMailResp.Mail
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.GetGlobalMailResp.Mail} Mail
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Mail.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Mail message.
             * @function verify
             * @memberof Msg.GetGlobalMailResp.Mail
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Mail.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.indate != null && message.hasOwnProperty("indate"))
                    if (!$util.isInteger(message.indate) && !(message.indate && $util.isInteger(message.indate.low) && $util.isInteger(message.indate.high)))
                        return "indate: integer|Long expected";
                if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                    if (!$util.isInteger(message.createdAt) && !(message.createdAt && $util.isInteger(message.createdAt.low) && $util.isInteger(message.createdAt.high)))
                        return "createdAt: integer|Long expected";
                if (message.icon != null && message.hasOwnProperty("icon"))
                    if (!$util.isInteger(message.icon))
                        return "icon: integer expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!$util.isString(message.content))
                        return "content: string expected";
                if (message.award != null && message.hasOwnProperty("award")) {
                    if (!Array.isArray(message.award))
                        return "award: array expected";
                    for (var i = 0; i < message.award.length; ++i) {
                        var error = $root.Msg.AwardItem.verify(message.award[i]);
                        if (error)
                            return "award." + error;
                    }
                }
                if (message.received != null && message.hasOwnProperty("received"))
                    if (typeof message.received !== "boolean")
                        return "received: boolean expected";
                return null;
            };

            /**
             * Creates a Mail message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.GetGlobalMailResp.Mail
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.GetGlobalMailResp.Mail} Mail
             */
            Mail.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.GetGlobalMailResp.Mail)
                    return object;
                var message = new $root.Msg.GetGlobalMailResp.Mail();
                if (object.id != null)
                    message.id = object.id | 0;
                if (object.indate != null)
                    if ($util.Long)
                        (message.indate = $util.Long.fromValue(object.indate)).unsigned = false;
                    else if (typeof object.indate === "string")
                        message.indate = parseInt(object.indate, 10);
                    else if (typeof object.indate === "number")
                        message.indate = object.indate;
                    else if (typeof object.indate === "object")
                        message.indate = new $util.LongBits(object.indate.low >>> 0, object.indate.high >>> 0).toNumber();
                if (object.createdAt != null)
                    if ($util.Long)
                        (message.createdAt = $util.Long.fromValue(object.createdAt)).unsigned = false;
                    else if (typeof object.createdAt === "string")
                        message.createdAt = parseInt(object.createdAt, 10);
                    else if (typeof object.createdAt === "number")
                        message.createdAt = object.createdAt;
                    else if (typeof object.createdAt === "object")
                        message.createdAt = new $util.LongBits(object.createdAt.low >>> 0, object.createdAt.high >>> 0).toNumber();
                if (object.icon != null)
                    message.icon = object.icon | 0;
                if (object.title != null)
                    message.title = String(object.title);
                if (object.content != null)
                    message.content = String(object.content);
                if (object.award) {
                    if (!Array.isArray(object.award))
                        throw TypeError(".Msg.GetGlobalMailResp.Mail.award: array expected");
                    message.award = [];
                    for (var i = 0; i < object.award.length; ++i) {
                        if (typeof object.award[i] !== "object")
                            throw TypeError(".Msg.GetGlobalMailResp.Mail.award: object expected");
                        message.award[i] = $root.Msg.AwardItem.fromObject(object.award[i]);
                    }
                }
                if (object.received != null)
                    message.received = Boolean(object.received);
                return message;
            };

            /**
             * Creates a plain object from a Mail message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.GetGlobalMailResp.Mail
             * @static
             * @param {Msg.GetGlobalMailResp.Mail} message Mail
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Mail.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.award = [];
                if (options.defaults) {
                    object.id = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.indate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.indate = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.createdAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.createdAt = options.longs === String ? "0" : 0;
                    object.icon = 0;
                    object.title = "";
                    object.content = "";
                    object.received = false;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.indate != null && message.hasOwnProperty("indate"))
                    if (typeof message.indate === "number")
                        object.indate = options.longs === String ? String(message.indate) : message.indate;
                    else
                        object.indate = options.longs === String ? $util.Long.prototype.toString.call(message.indate) : options.longs === Number ? new $util.LongBits(message.indate.low >>> 0, message.indate.high >>> 0).toNumber() : message.indate;
                if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                    if (typeof message.createdAt === "number")
                        object.createdAt = options.longs === String ? String(message.createdAt) : message.createdAt;
                    else
                        object.createdAt = options.longs === String ? $util.Long.prototype.toString.call(message.createdAt) : options.longs === Number ? new $util.LongBits(message.createdAt.low >>> 0, message.createdAt.high >>> 0).toNumber() : message.createdAt;
                if (message.icon != null && message.hasOwnProperty("icon"))
                    object.icon = message.icon;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = message.content;
                if (message.award && message.award.length) {
                    object.award = [];
                    for (var j = 0; j < message.award.length; ++j)
                        object.award[j] = $root.Msg.AwardItem.toObject(message.award[j], options);
                }
                if (message.received != null && message.hasOwnProperty("received"))
                    object.received = message.received;
                return object;
            };

            /**
             * Converts this Mail to JSON.
             * @function toJSON
             * @memberof Msg.GetGlobalMailResp.Mail
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Mail.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Mail;
        })();

        return GetGlobalMailResp;
    })();

    Msg.GetGlobalMailAwardReq = (function() {

        /**
         * Properties of a GetGlobalMailAwardReq.
         * @memberof Msg
         * @interface IGetGlobalMailAwardReq
         * @property {number|Long|null} [playerID] GetGlobalMailAwardReq playerID
         * @property {boolean|null} [isAll] GetGlobalMailAwardReq isAll
         * @property {number|null} [mailID] GetGlobalMailAwardReq mailID
         */

        /**
         * Constructs a new GetGlobalMailAwardReq.
         * @memberof Msg
         * @classdesc Represents a GetGlobalMailAwardReq.
         * @implements IGetGlobalMailAwardReq
         * @constructor
         * @param {Msg.IGetGlobalMailAwardReq=} [properties] Properties to set
         */
        function GetGlobalMailAwardReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetGlobalMailAwardReq playerID.
         * @member {number|Long} playerID
         * @memberof Msg.GetGlobalMailAwardReq
         * @instance
         */
        GetGlobalMailAwardReq.prototype.playerID = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GetGlobalMailAwardReq isAll.
         * @member {boolean} isAll
         * @memberof Msg.GetGlobalMailAwardReq
         * @instance
         */
        GetGlobalMailAwardReq.prototype.isAll = false;

        /**
         * GetGlobalMailAwardReq mailID.
         * @member {number} mailID
         * @memberof Msg.GetGlobalMailAwardReq
         * @instance
         */
        GetGlobalMailAwardReq.prototype.mailID = 0;

        /**
         * Creates a new GetGlobalMailAwardReq instance using the specified properties.
         * @function create
         * @memberof Msg.GetGlobalMailAwardReq
         * @static
         * @param {Msg.IGetGlobalMailAwardReq=} [properties] Properties to set
         * @returns {Msg.GetGlobalMailAwardReq} GetGlobalMailAwardReq instance
         */
        GetGlobalMailAwardReq.create = function create(properties) {
            return new GetGlobalMailAwardReq(properties);
        };

        /**
         * Encodes the specified GetGlobalMailAwardReq message. Does not implicitly {@link Msg.GetGlobalMailAwardReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetGlobalMailAwardReq
         * @static
         * @param {Msg.IGetGlobalMailAwardReq} message GetGlobalMailAwardReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetGlobalMailAwardReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.playerID);
            if (message.isAll != null && message.hasOwnProperty("isAll"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isAll);
            if (message.mailID != null && message.hasOwnProperty("mailID"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.mailID);
            return writer;
        };

        /**
         * Encodes the specified GetGlobalMailAwardReq message, length delimited. Does not implicitly {@link Msg.GetGlobalMailAwardReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetGlobalMailAwardReq
         * @static
         * @param {Msg.IGetGlobalMailAwardReq} message GetGlobalMailAwardReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetGlobalMailAwardReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetGlobalMailAwardReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetGlobalMailAwardReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetGlobalMailAwardReq} GetGlobalMailAwardReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetGlobalMailAwardReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetGlobalMailAwardReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.int64();
                    break;
                case 2:
                    message.isAll = reader.bool();
                    break;
                case 3:
                    message.mailID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetGlobalMailAwardReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetGlobalMailAwardReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetGlobalMailAwardReq} GetGlobalMailAwardReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetGlobalMailAwardReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetGlobalMailAwardReq message.
         * @function verify
         * @memberof Msg.GetGlobalMailAwardReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetGlobalMailAwardReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isInteger(message.playerID) && !(message.playerID && $util.isInteger(message.playerID.low) && $util.isInteger(message.playerID.high)))
                    return "playerID: integer|Long expected";
            if (message.isAll != null && message.hasOwnProperty("isAll"))
                if (typeof message.isAll !== "boolean")
                    return "isAll: boolean expected";
            if (message.mailID != null && message.hasOwnProperty("mailID"))
                if (!$util.isInteger(message.mailID))
                    return "mailID: integer expected";
            return null;
        };

        /**
         * Creates a GetGlobalMailAwardReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetGlobalMailAwardReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetGlobalMailAwardReq} GetGlobalMailAwardReq
         */
        GetGlobalMailAwardReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetGlobalMailAwardReq)
                return object;
            var message = new $root.Msg.GetGlobalMailAwardReq();
            if (object.playerID != null)
                if ($util.Long)
                    (message.playerID = $util.Long.fromValue(object.playerID)).unsigned = false;
                else if (typeof object.playerID === "string")
                    message.playerID = parseInt(object.playerID, 10);
                else if (typeof object.playerID === "number")
                    message.playerID = object.playerID;
                else if (typeof object.playerID === "object")
                    message.playerID = new $util.LongBits(object.playerID.low >>> 0, object.playerID.high >>> 0).toNumber();
            if (object.isAll != null)
                message.isAll = Boolean(object.isAll);
            if (object.mailID != null)
                message.mailID = object.mailID | 0;
            return message;
        };

        /**
         * Creates a plain object from a GetGlobalMailAwardReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetGlobalMailAwardReq
         * @static
         * @param {Msg.GetGlobalMailAwardReq} message GetGlobalMailAwardReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetGlobalMailAwardReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.playerID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.playerID = options.longs === String ? "0" : 0;
                object.isAll = false;
                object.mailID = 0;
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (typeof message.playerID === "number")
                    object.playerID = options.longs === String ? String(message.playerID) : message.playerID;
                else
                    object.playerID = options.longs === String ? $util.Long.prototype.toString.call(message.playerID) : options.longs === Number ? new $util.LongBits(message.playerID.low >>> 0, message.playerID.high >>> 0).toNumber() : message.playerID;
            if (message.isAll != null && message.hasOwnProperty("isAll"))
                object.isAll = message.isAll;
            if (message.mailID != null && message.hasOwnProperty("mailID"))
                object.mailID = message.mailID;
            return object;
        };

        /**
         * Converts this GetGlobalMailAwardReq to JSON.
         * @function toJSON
         * @memberof Msg.GetGlobalMailAwardReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetGlobalMailAwardReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetGlobalMailAwardReq;
    })();

    Msg.GetGlobalMailAwardResp = (function() {

        /**
         * Properties of a GetGlobalMailAwardResp.
         * @memberof Msg
         * @interface IGetGlobalMailAwardResp
         * @property {Msg.IStatus|null} [status] GetGlobalMailAwardResp status
         * @property {Array.<Msg.IAwardItem>|null} [award] GetGlobalMailAwardResp award
         * @property {number|Long|null} [latestAwardTime] GetGlobalMailAwardResp latestAwardTime
         */

        /**
         * Constructs a new GetGlobalMailAwardResp.
         * @memberof Msg
         * @classdesc Represents a GetGlobalMailAwardResp.
         * @implements IGetGlobalMailAwardResp
         * @constructor
         * @param {Msg.IGetGlobalMailAwardResp=} [properties] Properties to set
         */
        function GetGlobalMailAwardResp(properties) {
            this.award = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetGlobalMailAwardResp status.
         * @member {Msg.IStatus|null|undefined} status
         * @memberof Msg.GetGlobalMailAwardResp
         * @instance
         */
        GetGlobalMailAwardResp.prototype.status = null;

        /**
         * GetGlobalMailAwardResp award.
         * @member {Array.<Msg.IAwardItem>} award
         * @memberof Msg.GetGlobalMailAwardResp
         * @instance
         */
        GetGlobalMailAwardResp.prototype.award = $util.emptyArray;

        /**
         * GetGlobalMailAwardResp latestAwardTime.
         * @member {number|Long} latestAwardTime
         * @memberof Msg.GetGlobalMailAwardResp
         * @instance
         */
        GetGlobalMailAwardResp.prototype.latestAwardTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GetGlobalMailAwardResp instance using the specified properties.
         * @function create
         * @memberof Msg.GetGlobalMailAwardResp
         * @static
         * @param {Msg.IGetGlobalMailAwardResp=} [properties] Properties to set
         * @returns {Msg.GetGlobalMailAwardResp} GetGlobalMailAwardResp instance
         */
        GetGlobalMailAwardResp.create = function create(properties) {
            return new GetGlobalMailAwardResp(properties);
        };

        /**
         * Encodes the specified GetGlobalMailAwardResp message. Does not implicitly {@link Msg.GetGlobalMailAwardResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetGlobalMailAwardResp
         * @static
         * @param {Msg.IGetGlobalMailAwardResp} message GetGlobalMailAwardResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetGlobalMailAwardResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && message.hasOwnProperty("status"))
                $root.Msg.Status.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.award != null && message.award.length)
                for (var i = 0; i < message.award.length; ++i)
                    $root.Msg.AwardItem.encode(message.award[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.latestAwardTime != null && message.hasOwnProperty("latestAwardTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.latestAwardTime);
            return writer;
        };

        /**
         * Encodes the specified GetGlobalMailAwardResp message, length delimited. Does not implicitly {@link Msg.GetGlobalMailAwardResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetGlobalMailAwardResp
         * @static
         * @param {Msg.IGetGlobalMailAwardResp} message GetGlobalMailAwardResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetGlobalMailAwardResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetGlobalMailAwardResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetGlobalMailAwardResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetGlobalMailAwardResp} GetGlobalMailAwardResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetGlobalMailAwardResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetGlobalMailAwardResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = $root.Msg.Status.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.award && message.award.length))
                        message.award = [];
                    message.award.push($root.Msg.AwardItem.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.latestAwardTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetGlobalMailAwardResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetGlobalMailAwardResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetGlobalMailAwardResp} GetGlobalMailAwardResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetGlobalMailAwardResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetGlobalMailAwardResp message.
         * @function verify
         * @memberof Msg.GetGlobalMailAwardResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetGlobalMailAwardResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.Msg.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.award != null && message.hasOwnProperty("award")) {
                if (!Array.isArray(message.award))
                    return "award: array expected";
                for (var i = 0; i < message.award.length; ++i) {
                    var error = $root.Msg.AwardItem.verify(message.award[i]);
                    if (error)
                        return "award." + error;
                }
            }
            if (message.latestAwardTime != null && message.hasOwnProperty("latestAwardTime"))
                if (!$util.isInteger(message.latestAwardTime) && !(message.latestAwardTime && $util.isInteger(message.latestAwardTime.low) && $util.isInteger(message.latestAwardTime.high)))
                    return "latestAwardTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a GetGlobalMailAwardResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetGlobalMailAwardResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetGlobalMailAwardResp} GetGlobalMailAwardResp
         */
        GetGlobalMailAwardResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetGlobalMailAwardResp)
                return object;
            var message = new $root.Msg.GetGlobalMailAwardResp();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".Msg.GetGlobalMailAwardResp.status: object expected");
                message.status = $root.Msg.Status.fromObject(object.status);
            }
            if (object.award) {
                if (!Array.isArray(object.award))
                    throw TypeError(".Msg.GetGlobalMailAwardResp.award: array expected");
                message.award = [];
                for (var i = 0; i < object.award.length; ++i) {
                    if (typeof object.award[i] !== "object")
                        throw TypeError(".Msg.GetGlobalMailAwardResp.award: object expected");
                    message.award[i] = $root.Msg.AwardItem.fromObject(object.award[i]);
                }
            }
            if (object.latestAwardTime != null)
                if ($util.Long)
                    (message.latestAwardTime = $util.Long.fromValue(object.latestAwardTime)).unsigned = false;
                else if (typeof object.latestAwardTime === "string")
                    message.latestAwardTime = parseInt(object.latestAwardTime, 10);
                else if (typeof object.latestAwardTime === "number")
                    message.latestAwardTime = object.latestAwardTime;
                else if (typeof object.latestAwardTime === "object")
                    message.latestAwardTime = new $util.LongBits(object.latestAwardTime.low >>> 0, object.latestAwardTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GetGlobalMailAwardResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetGlobalMailAwardResp
         * @static
         * @param {Msg.GetGlobalMailAwardResp} message GetGlobalMailAwardResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetGlobalMailAwardResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.award = [];
            if (options.defaults) {
                object.status = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestAwardTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestAwardTime = options.longs === String ? "0" : 0;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.Msg.Status.toObject(message.status, options);
            if (message.award && message.award.length) {
                object.award = [];
                for (var j = 0; j < message.award.length; ++j)
                    object.award[j] = $root.Msg.AwardItem.toObject(message.award[j], options);
            }
            if (message.latestAwardTime != null && message.hasOwnProperty("latestAwardTime"))
                if (typeof message.latestAwardTime === "number")
                    object.latestAwardTime = options.longs === String ? String(message.latestAwardTime) : message.latestAwardTime;
                else
                    object.latestAwardTime = options.longs === String ? $util.Long.prototype.toString.call(message.latestAwardTime) : options.longs === Number ? new $util.LongBits(message.latestAwardTime.low >>> 0, message.latestAwardTime.high >>> 0).toNumber() : message.latestAwardTime;
            return object;
        };

        /**
         * Converts this GetGlobalMailAwardResp to JSON.
         * @function toJSON
         * @memberof Msg.GetGlobalMailAwardResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetGlobalMailAwardResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetGlobalMailAwardResp;
    })();

    Msg.GetPlayerAttributeReq = (function() {

        /**
         * Properties of a GetPlayerAttributeReq.
         * @memberof Msg
         * @interface IGetPlayerAttributeReq
         * @property {string|null} [playerID] GetPlayerAttributeReq playerID
         */

        /**
         * Constructs a new GetPlayerAttributeReq.
         * @memberof Msg
         * @classdesc Represents a GetPlayerAttributeReq.
         * @implements IGetPlayerAttributeReq
         * @constructor
         * @param {Msg.IGetPlayerAttributeReq=} [properties] Properties to set
         */
        function GetPlayerAttributeReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlayerAttributeReq playerID.
         * @member {string} playerID
         * @memberof Msg.GetPlayerAttributeReq
         * @instance
         */
        GetPlayerAttributeReq.prototype.playerID = "";

        /**
         * Creates a new GetPlayerAttributeReq instance using the specified properties.
         * @function create
         * @memberof Msg.GetPlayerAttributeReq
         * @static
         * @param {Msg.IGetPlayerAttributeReq=} [properties] Properties to set
         * @returns {Msg.GetPlayerAttributeReq} GetPlayerAttributeReq instance
         */
        GetPlayerAttributeReq.create = function create(properties) {
            return new GetPlayerAttributeReq(properties);
        };

        /**
         * Encodes the specified GetPlayerAttributeReq message. Does not implicitly {@link Msg.GetPlayerAttributeReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetPlayerAttributeReq
         * @static
         * @param {Msg.IGetPlayerAttributeReq} message GetPlayerAttributeReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerAttributeReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified GetPlayerAttributeReq message, length delimited. Does not implicitly {@link Msg.GetPlayerAttributeReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetPlayerAttributeReq
         * @static
         * @param {Msg.IGetPlayerAttributeReq} message GetPlayerAttributeReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerAttributeReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlayerAttributeReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetPlayerAttributeReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetPlayerAttributeReq} GetPlayerAttributeReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerAttributeReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetPlayerAttributeReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlayerAttributeReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetPlayerAttributeReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetPlayerAttributeReq} GetPlayerAttributeReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerAttributeReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlayerAttributeReq message.
         * @function verify
         * @memberof Msg.GetPlayerAttributeReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlayerAttributeReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a GetPlayerAttributeReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetPlayerAttributeReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetPlayerAttributeReq} GetPlayerAttributeReq
         */
        GetPlayerAttributeReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetPlayerAttributeReq)
                return object;
            var message = new $root.Msg.GetPlayerAttributeReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a GetPlayerAttributeReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetPlayerAttributeReq
         * @static
         * @param {Msg.GetPlayerAttributeReq} message GetPlayerAttributeReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlayerAttributeReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playerID = "";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this GetPlayerAttributeReq to JSON.
         * @function toJSON
         * @memberof Msg.GetPlayerAttributeReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlayerAttributeReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetPlayerAttributeReq;
    })();

    Msg.GetPlayerAttributeResp = (function() {

        /**
         * Properties of a GetPlayerAttributeResp.
         * @memberof Msg
         * @interface IGetPlayerAttributeResp
         * @property {Msg.IStatus|null} [status] GetPlayerAttributeResp status
         * @property {Msg.IPlayerAttribute|null} [attr] GetPlayerAttributeResp attr
         */

        /**
         * Constructs a new GetPlayerAttributeResp.
         * @memberof Msg
         * @classdesc Represents a GetPlayerAttributeResp.
         * @implements IGetPlayerAttributeResp
         * @constructor
         * @param {Msg.IGetPlayerAttributeResp=} [properties] Properties to set
         */
        function GetPlayerAttributeResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlayerAttributeResp status.
         * @member {Msg.IStatus|null|undefined} status
         * @memberof Msg.GetPlayerAttributeResp
         * @instance
         */
        GetPlayerAttributeResp.prototype.status = null;

        /**
         * GetPlayerAttributeResp attr.
         * @member {Msg.IPlayerAttribute|null|undefined} attr
         * @memberof Msg.GetPlayerAttributeResp
         * @instance
         */
        GetPlayerAttributeResp.prototype.attr = null;

        /**
         * Creates a new GetPlayerAttributeResp instance using the specified properties.
         * @function create
         * @memberof Msg.GetPlayerAttributeResp
         * @static
         * @param {Msg.IGetPlayerAttributeResp=} [properties] Properties to set
         * @returns {Msg.GetPlayerAttributeResp} GetPlayerAttributeResp instance
         */
        GetPlayerAttributeResp.create = function create(properties) {
            return new GetPlayerAttributeResp(properties);
        };

        /**
         * Encodes the specified GetPlayerAttributeResp message. Does not implicitly {@link Msg.GetPlayerAttributeResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetPlayerAttributeResp
         * @static
         * @param {Msg.IGetPlayerAttributeResp} message GetPlayerAttributeResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerAttributeResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && message.hasOwnProperty("status"))
                $root.Msg.Status.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.attr != null && message.hasOwnProperty("attr"))
                $root.Msg.PlayerAttribute.encode(message.attr, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetPlayerAttributeResp message, length delimited. Does not implicitly {@link Msg.GetPlayerAttributeResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetPlayerAttributeResp
         * @static
         * @param {Msg.IGetPlayerAttributeResp} message GetPlayerAttributeResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerAttributeResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlayerAttributeResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetPlayerAttributeResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetPlayerAttributeResp} GetPlayerAttributeResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerAttributeResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetPlayerAttributeResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = $root.Msg.Status.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.attr = $root.Msg.PlayerAttribute.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlayerAttributeResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetPlayerAttributeResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetPlayerAttributeResp} GetPlayerAttributeResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerAttributeResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlayerAttributeResp message.
         * @function verify
         * @memberof Msg.GetPlayerAttributeResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlayerAttributeResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.Msg.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.attr != null && message.hasOwnProperty("attr")) {
                var error = $root.Msg.PlayerAttribute.verify(message.attr);
                if (error)
                    return "attr." + error;
            }
            return null;
        };

        /**
         * Creates a GetPlayerAttributeResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetPlayerAttributeResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetPlayerAttributeResp} GetPlayerAttributeResp
         */
        GetPlayerAttributeResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetPlayerAttributeResp)
                return object;
            var message = new $root.Msg.GetPlayerAttributeResp();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".Msg.GetPlayerAttributeResp.status: object expected");
                message.status = $root.Msg.Status.fromObject(object.status);
            }
            if (object.attr != null) {
                if (typeof object.attr !== "object")
                    throw TypeError(".Msg.GetPlayerAttributeResp.attr: object expected");
                message.attr = $root.Msg.PlayerAttribute.fromObject(object.attr);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetPlayerAttributeResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetPlayerAttributeResp
         * @static
         * @param {Msg.GetPlayerAttributeResp} message GetPlayerAttributeResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlayerAttributeResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.status = null;
                object.attr = null;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.Msg.Status.toObject(message.status, options);
            if (message.attr != null && message.hasOwnProperty("attr"))
                object.attr = $root.Msg.PlayerAttribute.toObject(message.attr, options);
            return object;
        };

        /**
         * Converts this GetPlayerAttributeResp to JSON.
         * @function toJSON
         * @memberof Msg.GetPlayerAttributeResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlayerAttributeResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetPlayerAttributeResp;
    })();

    Msg.GetPlayerFashionsReq = (function() {

        /**
         * Properties of a GetPlayerFashionsReq.
         * @memberof Msg
         * @interface IGetPlayerFashionsReq
         * @property {string|null} [playerID] GetPlayerFashionsReq playerID
         */

        /**
         * Constructs a new GetPlayerFashionsReq.
         * @memberof Msg
         * @classdesc Represents a GetPlayerFashionsReq.
         * @implements IGetPlayerFashionsReq
         * @constructor
         * @param {Msg.IGetPlayerFashionsReq=} [properties] Properties to set
         */
        function GetPlayerFashionsReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlayerFashionsReq playerID.
         * @member {string} playerID
         * @memberof Msg.GetPlayerFashionsReq
         * @instance
         */
        GetPlayerFashionsReq.prototype.playerID = "";

        /**
         * Creates a new GetPlayerFashionsReq instance using the specified properties.
         * @function create
         * @memberof Msg.GetPlayerFashionsReq
         * @static
         * @param {Msg.IGetPlayerFashionsReq=} [properties] Properties to set
         * @returns {Msg.GetPlayerFashionsReq} GetPlayerFashionsReq instance
         */
        GetPlayerFashionsReq.create = function create(properties) {
            return new GetPlayerFashionsReq(properties);
        };

        /**
         * Encodes the specified GetPlayerFashionsReq message. Does not implicitly {@link Msg.GetPlayerFashionsReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetPlayerFashionsReq
         * @static
         * @param {Msg.IGetPlayerFashionsReq} message GetPlayerFashionsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerFashionsReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified GetPlayerFashionsReq message, length delimited. Does not implicitly {@link Msg.GetPlayerFashionsReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetPlayerFashionsReq
         * @static
         * @param {Msg.IGetPlayerFashionsReq} message GetPlayerFashionsReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerFashionsReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlayerFashionsReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetPlayerFashionsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetPlayerFashionsReq} GetPlayerFashionsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerFashionsReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetPlayerFashionsReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlayerFashionsReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetPlayerFashionsReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetPlayerFashionsReq} GetPlayerFashionsReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerFashionsReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlayerFashionsReq message.
         * @function verify
         * @memberof Msg.GetPlayerFashionsReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlayerFashionsReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a GetPlayerFashionsReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetPlayerFashionsReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetPlayerFashionsReq} GetPlayerFashionsReq
         */
        GetPlayerFashionsReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetPlayerFashionsReq)
                return object;
            var message = new $root.Msg.GetPlayerFashionsReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a GetPlayerFashionsReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetPlayerFashionsReq
         * @static
         * @param {Msg.GetPlayerFashionsReq} message GetPlayerFashionsReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlayerFashionsReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playerID = "";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this GetPlayerFashionsReq to JSON.
         * @function toJSON
         * @memberof Msg.GetPlayerFashionsReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlayerFashionsReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetPlayerFashionsReq;
    })();

    Msg.GetPlayerFashionsResp = (function() {

        /**
         * Properties of a GetPlayerFashionsResp.
         * @memberof Msg
         * @interface IGetPlayerFashionsResp
         * @property {Msg.GetPlayerFashionsResp.Result|null} [result] GetPlayerFashionsResp result
         * @property {string|null} [fashions] GetPlayerFashionsResp fashions
         * @property {Object.<string,number|Long>|null} [treasures] GetPlayerFashionsResp treasures
         */

        /**
         * Constructs a new GetPlayerFashionsResp.
         * @memberof Msg
         * @classdesc Represents a GetPlayerFashionsResp.
         * @implements IGetPlayerFashionsResp
         * @constructor
         * @param {Msg.IGetPlayerFashionsResp=} [properties] Properties to set
         */
        function GetPlayerFashionsResp(properties) {
            this.treasures = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlayerFashionsResp result.
         * @member {Msg.GetPlayerFashionsResp.Result} result
         * @memberof Msg.GetPlayerFashionsResp
         * @instance
         */
        GetPlayerFashionsResp.prototype.result = 0;

        /**
         * GetPlayerFashionsResp fashions.
         * @member {string} fashions
         * @memberof Msg.GetPlayerFashionsResp
         * @instance
         */
        GetPlayerFashionsResp.prototype.fashions = "";

        /**
         * GetPlayerFashionsResp treasures.
         * @member {Object.<string,number|Long>} treasures
         * @memberof Msg.GetPlayerFashionsResp
         * @instance
         */
        GetPlayerFashionsResp.prototype.treasures = $util.emptyObject;

        /**
         * Creates a new GetPlayerFashionsResp instance using the specified properties.
         * @function create
         * @memberof Msg.GetPlayerFashionsResp
         * @static
         * @param {Msg.IGetPlayerFashionsResp=} [properties] Properties to set
         * @returns {Msg.GetPlayerFashionsResp} GetPlayerFashionsResp instance
         */
        GetPlayerFashionsResp.create = function create(properties) {
            return new GetPlayerFashionsResp(properties);
        };

        /**
         * Encodes the specified GetPlayerFashionsResp message. Does not implicitly {@link Msg.GetPlayerFashionsResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetPlayerFashionsResp
         * @static
         * @param {Msg.IGetPlayerFashionsResp} message GetPlayerFashionsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerFashionsResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.fashions != null && message.hasOwnProperty("fashions"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fashions);
            if (message.treasures != null && message.hasOwnProperty("treasures"))
                for (var keys = Object.keys(message.treasures), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.treasures[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetPlayerFashionsResp message, length delimited. Does not implicitly {@link Msg.GetPlayerFashionsResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetPlayerFashionsResp
         * @static
         * @param {Msg.IGetPlayerFashionsResp} message GetPlayerFashionsResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerFashionsResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlayerFashionsResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetPlayerFashionsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetPlayerFashionsResp} GetPlayerFashionsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerFashionsResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetPlayerFashionsResp(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.fashions = reader.string();
                    break;
                case 3:
                    reader.skip().pos++;
                    if (message.treasures === $util.emptyObject)
                        message.treasures = {};
                    key = reader.string();
                    reader.pos++;
                    message.treasures[key] = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlayerFashionsResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetPlayerFashionsResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetPlayerFashionsResp} GetPlayerFashionsResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerFashionsResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlayerFashionsResp message.
         * @function verify
         * @memberof Msg.GetPlayerFashionsResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlayerFashionsResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.fashions != null && message.hasOwnProperty("fashions"))
                if (!$util.isString(message.fashions))
                    return "fashions: string expected";
            if (message.treasures != null && message.hasOwnProperty("treasures")) {
                if (!$util.isObject(message.treasures))
                    return "treasures: object expected";
                var key = Object.keys(message.treasures);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.treasures[key[i]]) && !(message.treasures[key[i]] && $util.isInteger(message.treasures[key[i]].low) && $util.isInteger(message.treasures[key[i]].high)))
                        return "treasures: integer|Long{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a GetPlayerFashionsResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetPlayerFashionsResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetPlayerFashionsResp} GetPlayerFashionsResp
         */
        GetPlayerFashionsResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetPlayerFashionsResp)
                return object;
            var message = new $root.Msg.GetPlayerFashionsResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            if (object.fashions != null)
                message.fashions = String(object.fashions);
            if (object.treasures) {
                if (typeof object.treasures !== "object")
                    throw TypeError(".Msg.GetPlayerFashionsResp.treasures: object expected");
                message.treasures = {};
                for (var keys = Object.keys(object.treasures), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.treasures[keys[i]] = $util.Long.fromValue(object.treasures[keys[i]])).unsigned = false;
                    else if (typeof object.treasures[keys[i]] === "string")
                        message.treasures[keys[i]] = parseInt(object.treasures[keys[i]], 10);
                    else if (typeof object.treasures[keys[i]] === "number")
                        message.treasures[keys[i]] = object.treasures[keys[i]];
                    else if (typeof object.treasures[keys[i]] === "object")
                        message.treasures[keys[i]] = new $util.LongBits(object.treasures[keys[i]].low >>> 0, object.treasures[keys[i]].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a GetPlayerFashionsResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetPlayerFashionsResp
         * @static
         * @param {Msg.GetPlayerFashionsResp} message GetPlayerFashionsResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlayerFashionsResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.treasures = {};
            if (options.defaults) {
                object.result = options.enums === String ? "Internal" : 0;
                object.fashions = "";
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.GetPlayerFashionsResp.Result[message.result] : message.result;
            if (message.fashions != null && message.hasOwnProperty("fashions"))
                object.fashions = message.fashions;
            var keys2;
            if (message.treasures && (keys2 = Object.keys(message.treasures)).length) {
                object.treasures = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.treasures[keys2[j]] === "number")
                        object.treasures[keys2[j]] = options.longs === String ? String(message.treasures[keys2[j]]) : message.treasures[keys2[j]];
                    else
                        object.treasures[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.treasures[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.treasures[keys2[j]].low >>> 0, message.treasures[keys2[j]].high >>> 0).toNumber() : message.treasures[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this GetPlayerFashionsResp to JSON.
         * @function toJSON
         * @memberof Msg.GetPlayerFashionsResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlayerFashionsResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.GetPlayerFashionsResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        GetPlayerFashionsResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return GetPlayerFashionsResp;
    })();

    Msg.GetPlayerWeaponReq = (function() {

        /**
         * Properties of a GetPlayerWeaponReq.
         * @memberof Msg
         * @interface IGetPlayerWeaponReq
         * @property {string|null} [playerID] GetPlayerWeaponReq playerID
         */

        /**
         * Constructs a new GetPlayerWeaponReq.
         * @memberof Msg
         * @classdesc Represents a GetPlayerWeaponReq.
         * @implements IGetPlayerWeaponReq
         * @constructor
         * @param {Msg.IGetPlayerWeaponReq=} [properties] Properties to set
         */
        function GetPlayerWeaponReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlayerWeaponReq playerID.
         * @member {string} playerID
         * @memberof Msg.GetPlayerWeaponReq
         * @instance
         */
        GetPlayerWeaponReq.prototype.playerID = "";

        /**
         * Creates a new GetPlayerWeaponReq instance using the specified properties.
         * @function create
         * @memberof Msg.GetPlayerWeaponReq
         * @static
         * @param {Msg.IGetPlayerWeaponReq=} [properties] Properties to set
         * @returns {Msg.GetPlayerWeaponReq} GetPlayerWeaponReq instance
         */
        GetPlayerWeaponReq.create = function create(properties) {
            return new GetPlayerWeaponReq(properties);
        };

        /**
         * Encodes the specified GetPlayerWeaponReq message. Does not implicitly {@link Msg.GetPlayerWeaponReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetPlayerWeaponReq
         * @static
         * @param {Msg.IGetPlayerWeaponReq} message GetPlayerWeaponReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerWeaponReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified GetPlayerWeaponReq message, length delimited. Does not implicitly {@link Msg.GetPlayerWeaponReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetPlayerWeaponReq
         * @static
         * @param {Msg.IGetPlayerWeaponReq} message GetPlayerWeaponReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerWeaponReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlayerWeaponReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetPlayerWeaponReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetPlayerWeaponReq} GetPlayerWeaponReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerWeaponReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetPlayerWeaponReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlayerWeaponReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetPlayerWeaponReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetPlayerWeaponReq} GetPlayerWeaponReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerWeaponReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlayerWeaponReq message.
         * @function verify
         * @memberof Msg.GetPlayerWeaponReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlayerWeaponReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a GetPlayerWeaponReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetPlayerWeaponReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetPlayerWeaponReq} GetPlayerWeaponReq
         */
        GetPlayerWeaponReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetPlayerWeaponReq)
                return object;
            var message = new $root.Msg.GetPlayerWeaponReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a GetPlayerWeaponReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetPlayerWeaponReq
         * @static
         * @param {Msg.GetPlayerWeaponReq} message GetPlayerWeaponReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlayerWeaponReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playerID = "";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this GetPlayerWeaponReq to JSON.
         * @function toJSON
         * @memberof Msg.GetPlayerWeaponReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlayerWeaponReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetPlayerWeaponReq;
    })();

    Msg.GetPlayerWeaponResp = (function() {

        /**
         * Properties of a GetPlayerWeaponResp.
         * @memberof Msg
         * @interface IGetPlayerWeaponResp
         * @property {Msg.IStatus|null} [status] GetPlayerWeaponResp status
         * @property {string|null} [weapons] GetPlayerWeaponResp weapons
         */

        /**
         * Constructs a new GetPlayerWeaponResp.
         * @memberof Msg
         * @classdesc Represents a GetPlayerWeaponResp.
         * @implements IGetPlayerWeaponResp
         * @constructor
         * @param {Msg.IGetPlayerWeaponResp=} [properties] Properties to set
         */
        function GetPlayerWeaponResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlayerWeaponResp status.
         * @member {Msg.IStatus|null|undefined} status
         * @memberof Msg.GetPlayerWeaponResp
         * @instance
         */
        GetPlayerWeaponResp.prototype.status = null;

        /**
         * GetPlayerWeaponResp weapons.
         * @member {string} weapons
         * @memberof Msg.GetPlayerWeaponResp
         * @instance
         */
        GetPlayerWeaponResp.prototype.weapons = "";

        /**
         * Creates a new GetPlayerWeaponResp instance using the specified properties.
         * @function create
         * @memberof Msg.GetPlayerWeaponResp
         * @static
         * @param {Msg.IGetPlayerWeaponResp=} [properties] Properties to set
         * @returns {Msg.GetPlayerWeaponResp} GetPlayerWeaponResp instance
         */
        GetPlayerWeaponResp.create = function create(properties) {
            return new GetPlayerWeaponResp(properties);
        };

        /**
         * Encodes the specified GetPlayerWeaponResp message. Does not implicitly {@link Msg.GetPlayerWeaponResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetPlayerWeaponResp
         * @static
         * @param {Msg.IGetPlayerWeaponResp} message GetPlayerWeaponResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerWeaponResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && message.hasOwnProperty("status"))
                $root.Msg.Status.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.weapons != null && message.hasOwnProperty("weapons"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.weapons);
            return writer;
        };

        /**
         * Encodes the specified GetPlayerWeaponResp message, length delimited. Does not implicitly {@link Msg.GetPlayerWeaponResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetPlayerWeaponResp
         * @static
         * @param {Msg.IGetPlayerWeaponResp} message GetPlayerWeaponResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerWeaponResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlayerWeaponResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetPlayerWeaponResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetPlayerWeaponResp} GetPlayerWeaponResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerWeaponResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetPlayerWeaponResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = $root.Msg.Status.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.weapons = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlayerWeaponResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetPlayerWeaponResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetPlayerWeaponResp} GetPlayerWeaponResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerWeaponResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlayerWeaponResp message.
         * @function verify
         * @memberof Msg.GetPlayerWeaponResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlayerWeaponResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.Msg.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.weapons != null && message.hasOwnProperty("weapons"))
                if (!$util.isString(message.weapons))
                    return "weapons: string expected";
            return null;
        };

        /**
         * Creates a GetPlayerWeaponResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetPlayerWeaponResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetPlayerWeaponResp} GetPlayerWeaponResp
         */
        GetPlayerWeaponResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetPlayerWeaponResp)
                return object;
            var message = new $root.Msg.GetPlayerWeaponResp();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".Msg.GetPlayerWeaponResp.status: object expected");
                message.status = $root.Msg.Status.fromObject(object.status);
            }
            if (object.weapons != null)
                message.weapons = String(object.weapons);
            return message;
        };

        /**
         * Creates a plain object from a GetPlayerWeaponResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetPlayerWeaponResp
         * @static
         * @param {Msg.GetPlayerWeaponResp} message GetPlayerWeaponResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlayerWeaponResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.status = null;
                object.weapons = "";
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.Msg.Status.toObject(message.status, options);
            if (message.weapons != null && message.hasOwnProperty("weapons"))
                object.weapons = message.weapons;
            return object;
        };

        /**
         * Converts this GetPlayerWeaponResp to JSON.
         * @function toJSON
         * @memberof Msg.GetPlayerWeaponResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlayerWeaponResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetPlayerWeaponResp;
    })();

    Msg.GetPlayerBufReq = (function() {

        /**
         * Properties of a GetPlayerBufReq.
         * @memberof Msg
         * @interface IGetPlayerBufReq
         * @property {string|null} [playerID] GetPlayerBufReq playerID
         */

        /**
         * Constructs a new GetPlayerBufReq.
         * @memberof Msg
         * @classdesc Represents a GetPlayerBufReq.
         * @implements IGetPlayerBufReq
         * @constructor
         * @param {Msg.IGetPlayerBufReq=} [properties] Properties to set
         */
        function GetPlayerBufReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlayerBufReq playerID.
         * @member {string} playerID
         * @memberof Msg.GetPlayerBufReq
         * @instance
         */
        GetPlayerBufReq.prototype.playerID = "";

        /**
         * Creates a new GetPlayerBufReq instance using the specified properties.
         * @function create
         * @memberof Msg.GetPlayerBufReq
         * @static
         * @param {Msg.IGetPlayerBufReq=} [properties] Properties to set
         * @returns {Msg.GetPlayerBufReq} GetPlayerBufReq instance
         */
        GetPlayerBufReq.create = function create(properties) {
            return new GetPlayerBufReq(properties);
        };

        /**
         * Encodes the specified GetPlayerBufReq message. Does not implicitly {@link Msg.GetPlayerBufReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetPlayerBufReq
         * @static
         * @param {Msg.IGetPlayerBufReq} message GetPlayerBufReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerBufReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified GetPlayerBufReq message, length delimited. Does not implicitly {@link Msg.GetPlayerBufReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetPlayerBufReq
         * @static
         * @param {Msg.IGetPlayerBufReq} message GetPlayerBufReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerBufReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlayerBufReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetPlayerBufReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetPlayerBufReq} GetPlayerBufReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerBufReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetPlayerBufReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlayerBufReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetPlayerBufReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetPlayerBufReq} GetPlayerBufReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerBufReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlayerBufReq message.
         * @function verify
         * @memberof Msg.GetPlayerBufReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlayerBufReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a GetPlayerBufReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetPlayerBufReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetPlayerBufReq} GetPlayerBufReq
         */
        GetPlayerBufReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetPlayerBufReq)
                return object;
            var message = new $root.Msg.GetPlayerBufReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a GetPlayerBufReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetPlayerBufReq
         * @static
         * @param {Msg.GetPlayerBufReq} message GetPlayerBufReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlayerBufReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playerID = "";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this GetPlayerBufReq to JSON.
         * @function toJSON
         * @memberof Msg.GetPlayerBufReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlayerBufReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetPlayerBufReq;
    })();

    Msg.GetPlayerBufResp = (function() {

        /**
         * Properties of a GetPlayerBufResp.
         * @memberof Msg
         * @interface IGetPlayerBufResp
         * @property {Msg.IStatus|null} [status] GetPlayerBufResp status
         * @property {string|null} [buffers] GetPlayerBufResp buffers
         */

        /**
         * Constructs a new GetPlayerBufResp.
         * @memberof Msg
         * @classdesc Represents a GetPlayerBufResp.
         * @implements IGetPlayerBufResp
         * @constructor
         * @param {Msg.IGetPlayerBufResp=} [properties] Properties to set
         */
        function GetPlayerBufResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlayerBufResp status.
         * @member {Msg.IStatus|null|undefined} status
         * @memberof Msg.GetPlayerBufResp
         * @instance
         */
        GetPlayerBufResp.prototype.status = null;

        /**
         * GetPlayerBufResp buffers.
         * @member {string} buffers
         * @memberof Msg.GetPlayerBufResp
         * @instance
         */
        GetPlayerBufResp.prototype.buffers = "";

        /**
         * Creates a new GetPlayerBufResp instance using the specified properties.
         * @function create
         * @memberof Msg.GetPlayerBufResp
         * @static
         * @param {Msg.IGetPlayerBufResp=} [properties] Properties to set
         * @returns {Msg.GetPlayerBufResp} GetPlayerBufResp instance
         */
        GetPlayerBufResp.create = function create(properties) {
            return new GetPlayerBufResp(properties);
        };

        /**
         * Encodes the specified GetPlayerBufResp message. Does not implicitly {@link Msg.GetPlayerBufResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetPlayerBufResp
         * @static
         * @param {Msg.IGetPlayerBufResp} message GetPlayerBufResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerBufResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && message.hasOwnProperty("status"))
                $root.Msg.Status.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.buffers != null && message.hasOwnProperty("buffers"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.buffers);
            return writer;
        };

        /**
         * Encodes the specified GetPlayerBufResp message, length delimited. Does not implicitly {@link Msg.GetPlayerBufResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetPlayerBufResp
         * @static
         * @param {Msg.IGetPlayerBufResp} message GetPlayerBufResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerBufResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlayerBufResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetPlayerBufResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetPlayerBufResp} GetPlayerBufResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerBufResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetPlayerBufResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = $root.Msg.Status.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.buffers = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlayerBufResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetPlayerBufResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetPlayerBufResp} GetPlayerBufResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerBufResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlayerBufResp message.
         * @function verify
         * @memberof Msg.GetPlayerBufResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlayerBufResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.Msg.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.buffers != null && message.hasOwnProperty("buffers"))
                if (!$util.isString(message.buffers))
                    return "buffers: string expected";
            return null;
        };

        /**
         * Creates a GetPlayerBufResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetPlayerBufResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetPlayerBufResp} GetPlayerBufResp
         */
        GetPlayerBufResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetPlayerBufResp)
                return object;
            var message = new $root.Msg.GetPlayerBufResp();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".Msg.GetPlayerBufResp.status: object expected");
                message.status = $root.Msg.Status.fromObject(object.status);
            }
            if (object.buffers != null)
                message.buffers = String(object.buffers);
            return message;
        };

        /**
         * Creates a plain object from a GetPlayerBufResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetPlayerBufResp
         * @static
         * @param {Msg.GetPlayerBufResp} message GetPlayerBufResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlayerBufResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.status = null;
                object.buffers = "";
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.Msg.Status.toObject(message.status, options);
            if (message.buffers != null && message.hasOwnProperty("buffers"))
                object.buffers = message.buffers;
            return object;
        };

        /**
         * Converts this GetPlayerBufResp to JSON.
         * @function toJSON
         * @memberof Msg.GetPlayerBufResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlayerBufResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetPlayerBufResp;
    })();

    Msg.Protocol = (function() {

        /**
         * Properties of a Protocol.
         * @memberof Msg
         * @interface IProtocol
         */

        /**
         * Constructs a new Protocol.
         * @memberof Msg
         * @classdesc Represents a Protocol.
         * @implements IProtocol
         * @constructor
         * @param {Msg.IProtocol=} [properties] Properties to set
         */
        function Protocol(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Protocol instance using the specified properties.
         * @function create
         * @memberof Msg.Protocol
         * @static
         * @param {Msg.IProtocol=} [properties] Properties to set
         * @returns {Msg.Protocol} Protocol instance
         */
        Protocol.create = function create(properties) {
            return new Protocol(properties);
        };

        /**
         * Encodes the specified Protocol message. Does not implicitly {@link Msg.Protocol.verify|verify} messages.
         * @function encode
         * @memberof Msg.Protocol
         * @static
         * @param {Msg.IProtocol} message Protocol message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Protocol.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Protocol message, length delimited. Does not implicitly {@link Msg.Protocol.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.Protocol
         * @static
         * @param {Msg.IProtocol} message Protocol message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Protocol.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Protocol message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.Protocol
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.Protocol} Protocol
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Protocol.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.Protocol();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Protocol message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.Protocol
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.Protocol} Protocol
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Protocol.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Protocol message.
         * @function verify
         * @memberof Msg.Protocol
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Protocol.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Protocol message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.Protocol
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.Protocol} Protocol
         */
        Protocol.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.Protocol)
                return object;
            return new $root.Msg.Protocol();
        };

        /**
         * Creates a plain object from a Protocol message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.Protocol
         * @static
         * @param {Msg.Protocol} message Protocol
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Protocol.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Protocol to JSON.
         * @function toJSON
         * @memberof Msg.Protocol
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Protocol.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Id enum.
         * @name Msg.Protocol.Id
         * @enum {string}
         * @property {number} LoginReq=0 LoginReq value
         * @property {number} LoginResp=1 LoginResp value
         * @property {number} WXLoginReq=2 WXLoginReq value
         * @property {number} WXLoginResp=3 WXLoginResp value
         * @property {number} GetFinishedStagesReq=4 GetFinishedStagesReq value
         * @property {number} GetFinishedStagesResp=5 GetFinishedStagesResp value
         * @property {number} BattleReportReq=6 BattleReportReq value
         * @property {number} BattleReportResp=7 BattleReportResp value
         * @property {number} PvpStartReq=8 PvpStartReq value
         * @property {number} PvpStartResp=9 PvpStartResp value
         * @property {number} PvpEnterRoomReq=10 PvpEnterRoomReq value
         * @property {number} PvpEnterRoomResp=11 PvpEnterRoomResp value
         * @property {number} PvpShootReq=12 PvpShootReq value
         * @property {number} PvpShootResp=13 PvpShootResp value
         * @property {number} LastPvpReq=14 LastPvpReq value
         * @property {number} LastPvpResp=15 LastPvpResp value
         * @property {number} PvpOnMatched=16 PvpOnMatched value
         * @property {number} GetPlayerAttributeReq=18 GetPlayerAttributeReq value
         * @property {number} GetPlayerAttributeResp=19 GetPlayerAttributeResp value
         * @property {number} GetPlayerAchievementReq=20 GetPlayerAchievementReq value
         * @property {number} GetPlayerAchievementResp=21 GetPlayerAchievementResp value
         * @property {number} StartPveReq=22 StartPveReq value
         * @property {number} StartPveResp=23 StartPveResp value
         * @property {number} GetPlayerDailyReq=24 GetPlayerDailyReq value
         * @property {number} GetPlayerDailyResp=25 GetPlayerDailyResp value
         * @property {number} DailyAwardReq=26 DailyAwardReq value
         * @property {number} DailyAwardResp=27 DailyAwardResp value
         * @property {number} AchievementAwardReq=28 AchievementAwardReq value
         * @property {number} AchievementAwardResp=29 AchievementAwardResp value
         * @property {number} GetPlayerWeaponReq=30 GetPlayerWeaponReq value
         * @property {number} GetPlayerWeaponResp=31 GetPlayerWeaponResp value
         * @property {number} GetPlayerFashionsReq=32 GetPlayerFashionsReq value
         * @property {number} GetPlayerFashionsResp=33 GetPlayerFashionsResp value
         * @property {number} UpdateWeaponReq=34 UpdateWeaponReq value
         * @property {number} UpdateWeaponResp=35 UpdateWeaponResp value
         * @property {number} UpdateBuyWeaponReq=36 UpdateBuyWeaponReq value
         * @property {number} UpdateBuyWeaponResp=37 UpdateBuyWeaponResp value
         * @property {number} UpdatePlayerFashionReq=38 UpdatePlayerFashionReq value
         * @property {number} UpdatePlayerFashionResp=39 UpdatePlayerFashionResp value
         * @property {number} ExchangeTreasureReq=40 ExchangeTreasureReq value
         * @property {number} ExchangeTreasureResp=41 ExchangeTreasureResp value
         * @property {number} OpenTreasureReq=42 OpenTreasureReq value
         * @property {number} OpenTreasureResp=43 OpenTreasureResp value
         * @property {number} QuitRoomReq=44 QuitRoomReq value
         * @property {number} QuitRoomResp=45 QuitRoomResp value
         * @property {number} BattleStatusACK=46 BattleStatusACK value
         * @property {number} PvpBattleStatus=47 PvpBattleStatus value
         * @property {number} PvpStopMatchReq=50 PvpStopMatchReq value
         * @property {number} PvpStopMatchResp=51 PvpStopMatchResp value
         * @property {number} PvpSurrenderReq=52 PvpSurrenderReq value
         * @property {number} PvpSurrenderResp=53 PvpSurrenderResp value
         * @property {number} GetRankListReq=54 GetRankListReq value
         * @property {number} GetRankListResp=55 GetRankListResp value
         * @property {number} GetPlayerBufReq=56 GetPlayerBufReq value
         * @property {number} GetPlayerBufResp=57 GetPlayerBufResp value
         * @property {number} GetPlayerTreasuresReq=58 GetPlayerTreasuresReq value
         * @property {number} GetPlayerTreasuresResp=59 GetPlayerTreasuresResp value
         * @property {number} GetGlobalMailReq=60 GetGlobalMailReq value
         * @property {number} GetGlobalMailResp=61 GetGlobalMailResp value
         * @property {number} GetGlobalMailAwardReq=62 GetGlobalMailAwardReq value
         * @property {number} GetGlobalMailAwardResp=63 GetGlobalMailAwardResp value
         * @property {number} GetCryptKeyReq=900 GetCryptKeyReq value
         * @property {number} GetCryptKeyResp=901 GetCryptKeyResp value
         * @property {number} HeartBeatReq=97 HeartBeatReq value
         * @property {number} HeartBeatResp=98 HeartBeatResp value
         * @property {number} PlayerDailySignInfoReq=101 PlayerDailySignInfoReq value
         * @property {number} PlayerDailySignInfoResp=102 PlayerDailySignInfoResp value
         * @property {number} PlayerDailySignReq=103 PlayerDailySignReq value
         * @property {number} PlayerDailySignResp=104 PlayerDailySignResp value
         * @property {number} GateError=99 GateError value
         */
        Protocol.Id = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LoginReq"] = 0;
            values[valuesById[1] = "LoginResp"] = 1;
            values[valuesById[2] = "WXLoginReq"] = 2;
            values[valuesById[3] = "WXLoginResp"] = 3;
            values[valuesById[4] = "GetFinishedStagesReq"] = 4;
            values[valuesById[5] = "GetFinishedStagesResp"] = 5;
            values[valuesById[6] = "BattleReportReq"] = 6;
            values[valuesById[7] = "BattleReportResp"] = 7;
            values[valuesById[8] = "PvpStartReq"] = 8;
            values[valuesById[9] = "PvpStartResp"] = 9;
            values[valuesById[10] = "PvpEnterRoomReq"] = 10;
            values[valuesById[11] = "PvpEnterRoomResp"] = 11;
            values[valuesById[12] = "PvpShootReq"] = 12;
            values[valuesById[13] = "PvpShootResp"] = 13;
            values[valuesById[14] = "LastPvpReq"] = 14;
            values[valuesById[15] = "LastPvpResp"] = 15;
            values[valuesById[16] = "PvpOnMatched"] = 16;
            values[valuesById[18] = "GetPlayerAttributeReq"] = 18;
            values[valuesById[19] = "GetPlayerAttributeResp"] = 19;
            values[valuesById[20] = "GetPlayerAchievementReq"] = 20;
            values[valuesById[21] = "GetPlayerAchievementResp"] = 21;
            values[valuesById[22] = "StartPveReq"] = 22;
            values[valuesById[23] = "StartPveResp"] = 23;
            values[valuesById[24] = "GetPlayerDailyReq"] = 24;
            values[valuesById[25] = "GetPlayerDailyResp"] = 25;
            values[valuesById[26] = "DailyAwardReq"] = 26;
            values[valuesById[27] = "DailyAwardResp"] = 27;
            values[valuesById[28] = "AchievementAwardReq"] = 28;
            values[valuesById[29] = "AchievementAwardResp"] = 29;
            values[valuesById[30] = "GetPlayerWeaponReq"] = 30;
            values[valuesById[31] = "GetPlayerWeaponResp"] = 31;
            values[valuesById[32] = "GetPlayerFashionsReq"] = 32;
            values[valuesById[33] = "GetPlayerFashionsResp"] = 33;
            values[valuesById[34] = "UpdateWeaponReq"] = 34;
            values[valuesById[35] = "UpdateWeaponResp"] = 35;
            values[valuesById[36] = "UpdateBuyWeaponReq"] = 36;
            values[valuesById[37] = "UpdateBuyWeaponResp"] = 37;
            values[valuesById[38] = "UpdatePlayerFashionReq"] = 38;
            values[valuesById[39] = "UpdatePlayerFashionResp"] = 39;
            values[valuesById[40] = "ExchangeTreasureReq"] = 40;
            values[valuesById[41] = "ExchangeTreasureResp"] = 41;
            values[valuesById[42] = "OpenTreasureReq"] = 42;
            values[valuesById[43] = "OpenTreasureResp"] = 43;
            values[valuesById[44] = "QuitRoomReq"] = 44;
            values[valuesById[45] = "QuitRoomResp"] = 45;
            values[valuesById[46] = "BattleStatusACK"] = 46;
            values[valuesById[47] = "PvpBattleStatus"] = 47;
            values[valuesById[50] = "PvpStopMatchReq"] = 50;
            values[valuesById[51] = "PvpStopMatchResp"] = 51;
            values[valuesById[52] = "PvpSurrenderReq"] = 52;
            values[valuesById[53] = "PvpSurrenderResp"] = 53;
            values[valuesById[54] = "GetRankListReq"] = 54;
            values[valuesById[55] = "GetRankListResp"] = 55;
            values[valuesById[56] = "GetPlayerBufReq"] = 56;
            values[valuesById[57] = "GetPlayerBufResp"] = 57;
            values[valuesById[58] = "GetPlayerTreasuresReq"] = 58;
            values[valuesById[59] = "GetPlayerTreasuresResp"] = 59;
            values[valuesById[60] = "GetGlobalMailReq"] = 60;
            values[valuesById[61] = "GetGlobalMailResp"] = 61;
            values[valuesById[62] = "GetGlobalMailAwardReq"] = 62;
            values[valuesById[63] = "GetGlobalMailAwardResp"] = 63;
            values[valuesById[900] = "GetCryptKeyReq"] = 900;
            values[valuesById[901] = "GetCryptKeyResp"] = 901;
            values[valuesById[97] = "HeartBeatReq"] = 97;
            values[valuesById[98] = "HeartBeatResp"] = 98;
            values[valuesById[101] = "PlayerDailySignInfoReq"] = 101;
            values[valuesById[102] = "PlayerDailySignInfoResp"] = 102;
            values[valuesById[103] = "PlayerDailySignReq"] = 103;
            values[valuesById[104] = "PlayerDailySignResp"] = 104;
            values[valuesById[99] = "GateError"] = 99;
            return values;
        })();

        return Protocol;
    })();

    Msg.GetFinishedStagesReq = (function() {

        /**
         * Properties of a GetFinishedStagesReq.
         * @memberof Msg
         * @interface IGetFinishedStagesReq
         * @property {string|null} [playerID] GetFinishedStagesReq playerID
         */

        /**
         * Constructs a new GetFinishedStagesReq.
         * @memberof Msg
         * @classdesc Represents a GetFinishedStagesReq.
         * @implements IGetFinishedStagesReq
         * @constructor
         * @param {Msg.IGetFinishedStagesReq=} [properties] Properties to set
         */
        function GetFinishedStagesReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetFinishedStagesReq playerID.
         * @member {string} playerID
         * @memberof Msg.GetFinishedStagesReq
         * @instance
         */
        GetFinishedStagesReq.prototype.playerID = "";

        /**
         * Creates a new GetFinishedStagesReq instance using the specified properties.
         * @function create
         * @memberof Msg.GetFinishedStagesReq
         * @static
         * @param {Msg.IGetFinishedStagesReq=} [properties] Properties to set
         * @returns {Msg.GetFinishedStagesReq} GetFinishedStagesReq instance
         */
        GetFinishedStagesReq.create = function create(properties) {
            return new GetFinishedStagesReq(properties);
        };

        /**
         * Encodes the specified GetFinishedStagesReq message. Does not implicitly {@link Msg.GetFinishedStagesReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetFinishedStagesReq
         * @static
         * @param {Msg.IGetFinishedStagesReq} message GetFinishedStagesReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFinishedStagesReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified GetFinishedStagesReq message, length delimited. Does not implicitly {@link Msg.GetFinishedStagesReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetFinishedStagesReq
         * @static
         * @param {Msg.IGetFinishedStagesReq} message GetFinishedStagesReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFinishedStagesReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetFinishedStagesReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetFinishedStagesReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetFinishedStagesReq} GetFinishedStagesReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFinishedStagesReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetFinishedStagesReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetFinishedStagesReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetFinishedStagesReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetFinishedStagesReq} GetFinishedStagesReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFinishedStagesReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetFinishedStagesReq message.
         * @function verify
         * @memberof Msg.GetFinishedStagesReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetFinishedStagesReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a GetFinishedStagesReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetFinishedStagesReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetFinishedStagesReq} GetFinishedStagesReq
         */
        GetFinishedStagesReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetFinishedStagesReq)
                return object;
            var message = new $root.Msg.GetFinishedStagesReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a GetFinishedStagesReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetFinishedStagesReq
         * @static
         * @param {Msg.GetFinishedStagesReq} message GetFinishedStagesReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetFinishedStagesReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playerID = "";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this GetFinishedStagesReq to JSON.
         * @function toJSON
         * @memberof Msg.GetFinishedStagesReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetFinishedStagesReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetFinishedStagesReq;
    })();

    Msg.GetFinishedStagesResp = (function() {

        /**
         * Properties of a GetFinishedStagesResp.
         * @memberof Msg
         * @interface IGetFinishedStagesResp
         * @property {Msg.GetFinishedStagesResp.Result|null} [result] GetFinishedStagesResp result
         * @property {Array.<Msg.IFinishedStatus>|null} [stages] GetFinishedStagesResp stages
         * @property {number|Long|null} [star] GetFinishedStagesResp star
         */

        /**
         * Constructs a new GetFinishedStagesResp.
         * @memberof Msg
         * @classdesc Represents a GetFinishedStagesResp.
         * @implements IGetFinishedStagesResp
         * @constructor
         * @param {Msg.IGetFinishedStagesResp=} [properties] Properties to set
         */
        function GetFinishedStagesResp(properties) {
            this.stages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetFinishedStagesResp result.
         * @member {Msg.GetFinishedStagesResp.Result} result
         * @memberof Msg.GetFinishedStagesResp
         * @instance
         */
        GetFinishedStagesResp.prototype.result = 0;

        /**
         * GetFinishedStagesResp stages.
         * @member {Array.<Msg.IFinishedStatus>} stages
         * @memberof Msg.GetFinishedStagesResp
         * @instance
         */
        GetFinishedStagesResp.prototype.stages = $util.emptyArray;

        /**
         * GetFinishedStagesResp star.
         * @member {number|Long} star
         * @memberof Msg.GetFinishedStagesResp
         * @instance
         */
        GetFinishedStagesResp.prototype.star = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GetFinishedStagesResp instance using the specified properties.
         * @function create
         * @memberof Msg.GetFinishedStagesResp
         * @static
         * @param {Msg.IGetFinishedStagesResp=} [properties] Properties to set
         * @returns {Msg.GetFinishedStagesResp} GetFinishedStagesResp instance
         */
        GetFinishedStagesResp.create = function create(properties) {
            return new GetFinishedStagesResp(properties);
        };

        /**
         * Encodes the specified GetFinishedStagesResp message. Does not implicitly {@link Msg.GetFinishedStagesResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetFinishedStagesResp
         * @static
         * @param {Msg.IGetFinishedStagesResp} message GetFinishedStagesResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFinishedStagesResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.stages != null && message.stages.length)
                for (var i = 0; i < message.stages.length; ++i)
                    $root.Msg.FinishedStatus.encode(message.stages[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.star != null && message.hasOwnProperty("star"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.star);
            return writer;
        };

        /**
         * Encodes the specified GetFinishedStagesResp message, length delimited. Does not implicitly {@link Msg.GetFinishedStagesResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetFinishedStagesResp
         * @static
         * @param {Msg.IGetFinishedStagesResp} message GetFinishedStagesResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFinishedStagesResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetFinishedStagesResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetFinishedStagesResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetFinishedStagesResp} GetFinishedStagesResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFinishedStagesResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetFinishedStagesResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.stages && message.stages.length))
                        message.stages = [];
                    message.stages.push($root.Msg.FinishedStatus.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.star = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetFinishedStagesResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetFinishedStagesResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetFinishedStagesResp} GetFinishedStagesResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFinishedStagesResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetFinishedStagesResp message.
         * @function verify
         * @memberof Msg.GetFinishedStagesResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetFinishedStagesResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.stages != null && message.hasOwnProperty("stages")) {
                if (!Array.isArray(message.stages))
                    return "stages: array expected";
                for (var i = 0; i < message.stages.length; ++i) {
                    var error = $root.Msg.FinishedStatus.verify(message.stages[i]);
                    if (error)
                        return "stages." + error;
                }
            }
            if (message.star != null && message.hasOwnProperty("star"))
                if (!$util.isInteger(message.star) && !(message.star && $util.isInteger(message.star.low) && $util.isInteger(message.star.high)))
                    return "star: integer|Long expected";
            return null;
        };

        /**
         * Creates a GetFinishedStagesResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetFinishedStagesResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetFinishedStagesResp} GetFinishedStagesResp
         */
        GetFinishedStagesResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetFinishedStagesResp)
                return object;
            var message = new $root.Msg.GetFinishedStagesResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            if (object.stages) {
                if (!Array.isArray(object.stages))
                    throw TypeError(".Msg.GetFinishedStagesResp.stages: array expected");
                message.stages = [];
                for (var i = 0; i < object.stages.length; ++i) {
                    if (typeof object.stages[i] !== "object")
                        throw TypeError(".Msg.GetFinishedStagesResp.stages: object expected");
                    message.stages[i] = $root.Msg.FinishedStatus.fromObject(object.stages[i]);
                }
            }
            if (object.star != null)
                if ($util.Long)
                    (message.star = $util.Long.fromValue(object.star)).unsigned = false;
                else if (typeof object.star === "string")
                    message.star = parseInt(object.star, 10);
                else if (typeof object.star === "number")
                    message.star = object.star;
                else if (typeof object.star === "object")
                    message.star = new $util.LongBits(object.star.low >>> 0, object.star.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a GetFinishedStagesResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetFinishedStagesResp
         * @static
         * @param {Msg.GetFinishedStagesResp} message GetFinishedStagesResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetFinishedStagesResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.stages = [];
            if (options.defaults) {
                object.result = options.enums === String ? "Internal" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.star = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.star = options.longs === String ? "0" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.GetFinishedStagesResp.Result[message.result] : message.result;
            if (message.stages && message.stages.length) {
                object.stages = [];
                for (var j = 0; j < message.stages.length; ++j)
                    object.stages[j] = $root.Msg.FinishedStatus.toObject(message.stages[j], options);
            }
            if (message.star != null && message.hasOwnProperty("star"))
                if (typeof message.star === "number")
                    object.star = options.longs === String ? String(message.star) : message.star;
                else
                    object.star = options.longs === String ? $util.Long.prototype.toString.call(message.star) : options.longs === Number ? new $util.LongBits(message.star.low >>> 0, message.star.high >>> 0).toNumber() : message.star;
            return object;
        };

        /**
         * Converts this GetFinishedStagesResp to JSON.
         * @function toJSON
         * @memberof Msg.GetFinishedStagesResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetFinishedStagesResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.GetFinishedStagesResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        GetFinishedStagesResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return GetFinishedStagesResp;
    })();

    Msg.BattleReportReq = (function() {

        /**
         * Properties of a BattleReportReq.
         * @memberof Msg
         * @interface IBattleReportReq
         * @property {string|null} [playerID] BattleReportReq playerID
         * @property {string|null} [stageID] BattleReportReq stageID
         * @property {number|Long|null} [star] BattleReportReq star
         * @property {number|Long|null} [score] BattleReportReq score
         * @property {number|Long|null} [bullseye] BattleReportReq bullseye
         * @property {number|Long|null} [miss] BattleReportReq miss
         */

        /**
         * Constructs a new BattleReportReq.
         * @memberof Msg
         * @classdesc Represents a BattleReportReq.
         * @implements IBattleReportReq
         * @constructor
         * @param {Msg.IBattleReportReq=} [properties] Properties to set
         */
        function BattleReportReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleReportReq playerID.
         * @member {string} playerID
         * @memberof Msg.BattleReportReq
         * @instance
         */
        BattleReportReq.prototype.playerID = "";

        /**
         * BattleReportReq stageID.
         * @member {string} stageID
         * @memberof Msg.BattleReportReq
         * @instance
         */
        BattleReportReq.prototype.stageID = "";

        /**
         * BattleReportReq star.
         * @member {number|Long} star
         * @memberof Msg.BattleReportReq
         * @instance
         */
        BattleReportReq.prototype.star = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BattleReportReq score.
         * @member {number|Long} score
         * @memberof Msg.BattleReportReq
         * @instance
         */
        BattleReportReq.prototype.score = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BattleReportReq bullseye.
         * @member {number|Long} bullseye
         * @memberof Msg.BattleReportReq
         * @instance
         */
        BattleReportReq.prototype.bullseye = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BattleReportReq miss.
         * @member {number|Long} miss
         * @memberof Msg.BattleReportReq
         * @instance
         */
        BattleReportReq.prototype.miss = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BattleReportReq instance using the specified properties.
         * @function create
         * @memberof Msg.BattleReportReq
         * @static
         * @param {Msg.IBattleReportReq=} [properties] Properties to set
         * @returns {Msg.BattleReportReq} BattleReportReq instance
         */
        BattleReportReq.create = function create(properties) {
            return new BattleReportReq(properties);
        };

        /**
         * Encodes the specified BattleReportReq message. Does not implicitly {@link Msg.BattleReportReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.BattleReportReq
         * @static
         * @param {Msg.IBattleReportReq} message BattleReportReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleReportReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            if (message.stageID != null && message.hasOwnProperty("stageID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.stageID);
            if (message.star != null && message.hasOwnProperty("star"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.star);
            if (message.score != null && message.hasOwnProperty("score"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.score);
            if (message.bullseye != null && message.hasOwnProperty("bullseye"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.bullseye);
            if (message.miss != null && message.hasOwnProperty("miss"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.miss);
            return writer;
        };

        /**
         * Encodes the specified BattleReportReq message, length delimited. Does not implicitly {@link Msg.BattleReportReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.BattleReportReq
         * @static
         * @param {Msg.IBattleReportReq} message BattleReportReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleReportReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleReportReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.BattleReportReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.BattleReportReq} BattleReportReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleReportReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.BattleReportReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                case 2:
                    message.stageID = reader.string();
                    break;
                case 3:
                    message.star = reader.int64();
                    break;
                case 4:
                    message.score = reader.int64();
                    break;
                case 5:
                    message.bullseye = reader.int64();
                    break;
                case 6:
                    message.miss = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleReportReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.BattleReportReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.BattleReportReq} BattleReportReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleReportReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleReportReq message.
         * @function verify
         * @memberof Msg.BattleReportReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleReportReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            if (message.stageID != null && message.hasOwnProperty("stageID"))
                if (!$util.isString(message.stageID))
                    return "stageID: string expected";
            if (message.star != null && message.hasOwnProperty("star"))
                if (!$util.isInteger(message.star) && !(message.star && $util.isInteger(message.star.low) && $util.isInteger(message.star.high)))
                    return "star: integer|Long expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score) && !(message.score && $util.isInteger(message.score.low) && $util.isInteger(message.score.high)))
                    return "score: integer|Long expected";
            if (message.bullseye != null && message.hasOwnProperty("bullseye"))
                if (!$util.isInteger(message.bullseye) && !(message.bullseye && $util.isInteger(message.bullseye.low) && $util.isInteger(message.bullseye.high)))
                    return "bullseye: integer|Long expected";
            if (message.miss != null && message.hasOwnProperty("miss"))
                if (!$util.isInteger(message.miss) && !(message.miss && $util.isInteger(message.miss.low) && $util.isInteger(message.miss.high)))
                    return "miss: integer|Long expected";
            return null;
        };

        /**
         * Creates a BattleReportReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.BattleReportReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.BattleReportReq} BattleReportReq
         */
        BattleReportReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.BattleReportReq)
                return object;
            var message = new $root.Msg.BattleReportReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            if (object.stageID != null)
                message.stageID = String(object.stageID);
            if (object.star != null)
                if ($util.Long)
                    (message.star = $util.Long.fromValue(object.star)).unsigned = false;
                else if (typeof object.star === "string")
                    message.star = parseInt(object.star, 10);
                else if (typeof object.star === "number")
                    message.star = object.star;
                else if (typeof object.star === "object")
                    message.star = new $util.LongBits(object.star.low >>> 0, object.star.high >>> 0).toNumber();
            if (object.score != null)
                if ($util.Long)
                    (message.score = $util.Long.fromValue(object.score)).unsigned = false;
                else if (typeof object.score === "string")
                    message.score = parseInt(object.score, 10);
                else if (typeof object.score === "number")
                    message.score = object.score;
                else if (typeof object.score === "object")
                    message.score = new $util.LongBits(object.score.low >>> 0, object.score.high >>> 0).toNumber();
            if (object.bullseye != null)
                if ($util.Long)
                    (message.bullseye = $util.Long.fromValue(object.bullseye)).unsigned = false;
                else if (typeof object.bullseye === "string")
                    message.bullseye = parseInt(object.bullseye, 10);
                else if (typeof object.bullseye === "number")
                    message.bullseye = object.bullseye;
                else if (typeof object.bullseye === "object")
                    message.bullseye = new $util.LongBits(object.bullseye.low >>> 0, object.bullseye.high >>> 0).toNumber();
            if (object.miss != null)
                if ($util.Long)
                    (message.miss = $util.Long.fromValue(object.miss)).unsigned = false;
                else if (typeof object.miss === "string")
                    message.miss = parseInt(object.miss, 10);
                else if (typeof object.miss === "number")
                    message.miss = object.miss;
                else if (typeof object.miss === "object")
                    message.miss = new $util.LongBits(object.miss.low >>> 0, object.miss.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BattleReportReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.BattleReportReq
         * @static
         * @param {Msg.BattleReportReq} message BattleReportReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BattleReportReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerID = "";
                object.stageID = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.star = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.star = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.score = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.score = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.bullseye = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bullseye = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.miss = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.miss = options.longs === String ? "0" : 0;
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.stageID != null && message.hasOwnProperty("stageID"))
                object.stageID = message.stageID;
            if (message.star != null && message.hasOwnProperty("star"))
                if (typeof message.star === "number")
                    object.star = options.longs === String ? String(message.star) : message.star;
                else
                    object.star = options.longs === String ? $util.Long.prototype.toString.call(message.star) : options.longs === Number ? new $util.LongBits(message.star.low >>> 0, message.star.high >>> 0).toNumber() : message.star;
            if (message.score != null && message.hasOwnProperty("score"))
                if (typeof message.score === "number")
                    object.score = options.longs === String ? String(message.score) : message.score;
                else
                    object.score = options.longs === String ? $util.Long.prototype.toString.call(message.score) : options.longs === Number ? new $util.LongBits(message.score.low >>> 0, message.score.high >>> 0).toNumber() : message.score;
            if (message.bullseye != null && message.hasOwnProperty("bullseye"))
                if (typeof message.bullseye === "number")
                    object.bullseye = options.longs === String ? String(message.bullseye) : message.bullseye;
                else
                    object.bullseye = options.longs === String ? $util.Long.prototype.toString.call(message.bullseye) : options.longs === Number ? new $util.LongBits(message.bullseye.low >>> 0, message.bullseye.high >>> 0).toNumber() : message.bullseye;
            if (message.miss != null && message.hasOwnProperty("miss"))
                if (typeof message.miss === "number")
                    object.miss = options.longs === String ? String(message.miss) : message.miss;
                else
                    object.miss = options.longs === String ? $util.Long.prototype.toString.call(message.miss) : options.longs === Number ? new $util.LongBits(message.miss.low >>> 0, message.miss.high >>> 0).toNumber() : message.miss;
            return object;
        };

        /**
         * Converts this BattleReportReq to JSON.
         * @function toJSON
         * @memberof Msg.BattleReportReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BattleReportReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BattleReportReq;
    })();

    Msg.BattleReportResp = (function() {

        /**
         * Properties of a BattleReportResp.
         * @memberof Msg
         * @interface IBattleReportResp
         * @property {Msg.BattleReportResp.Result|null} [result] BattleReportResp result
         */

        /**
         * Constructs a new BattleReportResp.
         * @memberof Msg
         * @classdesc Represents a BattleReportResp.
         * @implements IBattleReportResp
         * @constructor
         * @param {Msg.IBattleReportResp=} [properties] Properties to set
         */
        function BattleReportResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleReportResp result.
         * @member {Msg.BattleReportResp.Result} result
         * @memberof Msg.BattleReportResp
         * @instance
         */
        BattleReportResp.prototype.result = 0;

        /**
         * Creates a new BattleReportResp instance using the specified properties.
         * @function create
         * @memberof Msg.BattleReportResp
         * @static
         * @param {Msg.IBattleReportResp=} [properties] Properties to set
         * @returns {Msg.BattleReportResp} BattleReportResp instance
         */
        BattleReportResp.create = function create(properties) {
            return new BattleReportResp(properties);
        };

        /**
         * Encodes the specified BattleReportResp message. Does not implicitly {@link Msg.BattleReportResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.BattleReportResp
         * @static
         * @param {Msg.IBattleReportResp} message BattleReportResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleReportResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified BattleReportResp message, length delimited. Does not implicitly {@link Msg.BattleReportResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.BattleReportResp
         * @static
         * @param {Msg.IBattleReportResp} message BattleReportResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleReportResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleReportResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.BattleReportResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.BattleReportResp} BattleReportResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleReportResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.BattleReportResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleReportResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.BattleReportResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.BattleReportResp} BattleReportResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleReportResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleReportResp message.
         * @function verify
         * @memberof Msg.BattleReportResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleReportResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a BattleReportResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.BattleReportResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.BattleReportResp} BattleReportResp
         */
        BattleReportResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.BattleReportResp)
                return object;
            var message = new $root.Msg.BattleReportResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "InvaildGrade":
            case 2:
                message.result = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a BattleReportResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.BattleReportResp
         * @static
         * @param {Msg.BattleReportResp} message BattleReportResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BattleReportResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "Internal" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.BattleReportResp.Result[message.result] : message.result;
            return object;
        };

        /**
         * Converts this BattleReportResp to JSON.
         * @function toJSON
         * @memberof Msg.BattleReportResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BattleReportResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.BattleReportResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         * @property {number} InvaildGrade=2 InvaildGrade value
         */
        BattleReportResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "InvaildGrade"] = 2;
            return values;
        })();

        return BattleReportResp;
    })();

    Msg.StartPveReq = (function() {

        /**
         * Properties of a StartPveReq.
         * @memberof Msg
         * @interface IStartPveReq
         * @property {string|null} [playerID] StartPveReq playerID
         * @property {string|null} [stageID] StartPveReq stageID
         */

        /**
         * Constructs a new StartPveReq.
         * @memberof Msg
         * @classdesc Represents a StartPveReq.
         * @implements IStartPveReq
         * @constructor
         * @param {Msg.IStartPveReq=} [properties] Properties to set
         */
        function StartPveReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartPveReq playerID.
         * @member {string} playerID
         * @memberof Msg.StartPveReq
         * @instance
         */
        StartPveReq.prototype.playerID = "";

        /**
         * StartPveReq stageID.
         * @member {string} stageID
         * @memberof Msg.StartPveReq
         * @instance
         */
        StartPveReq.prototype.stageID = "";

        /**
         * Creates a new StartPveReq instance using the specified properties.
         * @function create
         * @memberof Msg.StartPveReq
         * @static
         * @param {Msg.IStartPveReq=} [properties] Properties to set
         * @returns {Msg.StartPveReq} StartPveReq instance
         */
        StartPveReq.create = function create(properties) {
            return new StartPveReq(properties);
        };

        /**
         * Encodes the specified StartPveReq message. Does not implicitly {@link Msg.StartPveReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.StartPveReq
         * @static
         * @param {Msg.IStartPveReq} message StartPveReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartPveReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            if (message.stageID != null && message.hasOwnProperty("stageID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.stageID);
            return writer;
        };

        /**
         * Encodes the specified StartPveReq message, length delimited. Does not implicitly {@link Msg.StartPveReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.StartPveReq
         * @static
         * @param {Msg.IStartPveReq} message StartPveReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartPveReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartPveReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.StartPveReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.StartPveReq} StartPveReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartPveReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.StartPveReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                case 2:
                    message.stageID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartPveReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.StartPveReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.StartPveReq} StartPveReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartPveReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartPveReq message.
         * @function verify
         * @memberof Msg.StartPveReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartPveReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            if (message.stageID != null && message.hasOwnProperty("stageID"))
                if (!$util.isString(message.stageID))
                    return "stageID: string expected";
            return null;
        };

        /**
         * Creates a StartPveReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.StartPveReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.StartPveReq} StartPveReq
         */
        StartPveReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.StartPveReq)
                return object;
            var message = new $root.Msg.StartPveReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            if (object.stageID != null)
                message.stageID = String(object.stageID);
            return message;
        };

        /**
         * Creates a plain object from a StartPveReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.StartPveReq
         * @static
         * @param {Msg.StartPveReq} message StartPveReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartPveReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerID = "";
                object.stageID = "";
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.stageID != null && message.hasOwnProperty("stageID"))
                object.stageID = message.stageID;
            return object;
        };

        /**
         * Converts this StartPveReq to JSON.
         * @function toJSON
         * @memberof Msg.StartPveReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartPveReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StartPveReq;
    })();

    Msg.StartPveResp = (function() {

        /**
         * Properties of a StartPveResp.
         * @memberof Msg
         * @interface IStartPveResp
         * @property {Msg.StartPveResp.Result|null} [result] StartPveResp result
         */

        /**
         * Constructs a new StartPveResp.
         * @memberof Msg
         * @classdesc Represents a StartPveResp.
         * @implements IStartPveResp
         * @constructor
         * @param {Msg.IStartPveResp=} [properties] Properties to set
         */
        function StartPveResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartPveResp result.
         * @member {Msg.StartPveResp.Result} result
         * @memberof Msg.StartPveResp
         * @instance
         */
        StartPveResp.prototype.result = 0;

        /**
         * Creates a new StartPveResp instance using the specified properties.
         * @function create
         * @memberof Msg.StartPveResp
         * @static
         * @param {Msg.IStartPveResp=} [properties] Properties to set
         * @returns {Msg.StartPveResp} StartPveResp instance
         */
        StartPveResp.create = function create(properties) {
            return new StartPveResp(properties);
        };

        /**
         * Encodes the specified StartPveResp message. Does not implicitly {@link Msg.StartPveResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.StartPveResp
         * @static
         * @param {Msg.IStartPveResp} message StartPveResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartPveResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified StartPveResp message, length delimited. Does not implicitly {@link Msg.StartPveResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.StartPveResp
         * @static
         * @param {Msg.IStartPveResp} message StartPveResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartPveResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartPveResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.StartPveResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.StartPveResp} StartPveResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartPveResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.StartPveResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartPveResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.StartPveResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.StartPveResp} StartPveResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartPveResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartPveResp message.
         * @function verify
         * @memberof Msg.StartPveResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartPveResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a StartPveResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.StartPveResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.StartPveResp} StartPveResp
         */
        StartPveResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.StartPveResp)
                return object;
            var message = new $root.Msg.StartPveResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "LackStrength":
            case 2:
                message.result = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a StartPveResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.StartPveResp
         * @static
         * @param {Msg.StartPveResp} message StartPveResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartPveResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "Internal" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.StartPveResp.Result[message.result] : message.result;
            return object;
        };

        /**
         * Converts this StartPveResp to JSON.
         * @function toJSON
         * @memberof Msg.StartPveResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartPveResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.StartPveResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         * @property {number} LackStrength=2 LackStrength value
         */
        StartPveResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "LackStrength"] = 2;
            return values;
        })();

        return StartPveResp;
    })();

    Msg.LastPvpReq = (function() {

        /**
         * Properties of a LastPvpReq.
         * @memberof Msg
         * @interface ILastPvpReq
         * @property {string|null} [playerID] LastPvpReq playerID
         */

        /**
         * Constructs a new LastPvpReq.
         * @memberof Msg
         * @classdesc Represents a LastPvpReq.
         * @implements ILastPvpReq
         * @constructor
         * @param {Msg.ILastPvpReq=} [properties] Properties to set
         */
        function LastPvpReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LastPvpReq playerID.
         * @member {string} playerID
         * @memberof Msg.LastPvpReq
         * @instance
         */
        LastPvpReq.prototype.playerID = "";

        /**
         * Creates a new LastPvpReq instance using the specified properties.
         * @function create
         * @memberof Msg.LastPvpReq
         * @static
         * @param {Msg.ILastPvpReq=} [properties] Properties to set
         * @returns {Msg.LastPvpReq} LastPvpReq instance
         */
        LastPvpReq.create = function create(properties) {
            return new LastPvpReq(properties);
        };

        /**
         * Encodes the specified LastPvpReq message. Does not implicitly {@link Msg.LastPvpReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.LastPvpReq
         * @static
         * @param {Msg.ILastPvpReq} message LastPvpReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LastPvpReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified LastPvpReq message, length delimited. Does not implicitly {@link Msg.LastPvpReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.LastPvpReq
         * @static
         * @param {Msg.ILastPvpReq} message LastPvpReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LastPvpReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LastPvpReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.LastPvpReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.LastPvpReq} LastPvpReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LastPvpReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.LastPvpReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LastPvpReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.LastPvpReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.LastPvpReq} LastPvpReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LastPvpReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LastPvpReq message.
         * @function verify
         * @memberof Msg.LastPvpReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LastPvpReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a LastPvpReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.LastPvpReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.LastPvpReq} LastPvpReq
         */
        LastPvpReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.LastPvpReq)
                return object;
            var message = new $root.Msg.LastPvpReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a LastPvpReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.LastPvpReq
         * @static
         * @param {Msg.LastPvpReq} message LastPvpReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LastPvpReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playerID = "";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this LastPvpReq to JSON.
         * @function toJSON
         * @memberof Msg.LastPvpReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LastPvpReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LastPvpReq;
    })();

    Msg.LastPvpResp = (function() {

        /**
         * Properties of a LastPvpResp.
         * @memberof Msg
         * @interface ILastPvpResp
         * @property {Msg.LastPvpResp.Result|null} [result] LastPvpResp result
         * @property {string|null} [roomID] LastPvpResp roomID
         * @property {Msg.IPlayerAttribute|null} [player1] LastPvpResp player1
         * @property {Msg.IPlayerAttribute|null} [player2] LastPvpResp player2
         * @property {Msg.IPvpBattle|null} [pvp] LastPvpResp pvp
         */

        /**
         * Constructs a new LastPvpResp.
         * @memberof Msg
         * @classdesc Represents a LastPvpResp.
         * @implements ILastPvpResp
         * @constructor
         * @param {Msg.ILastPvpResp=} [properties] Properties to set
         */
        function LastPvpResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LastPvpResp result.
         * @member {Msg.LastPvpResp.Result} result
         * @memberof Msg.LastPvpResp
         * @instance
         */
        LastPvpResp.prototype.result = 0;

        /**
         * LastPvpResp roomID.
         * @member {string} roomID
         * @memberof Msg.LastPvpResp
         * @instance
         */
        LastPvpResp.prototype.roomID = "";

        /**
         * LastPvpResp player1.
         * @member {Msg.IPlayerAttribute|null|undefined} player1
         * @memberof Msg.LastPvpResp
         * @instance
         */
        LastPvpResp.prototype.player1 = null;

        /**
         * LastPvpResp player2.
         * @member {Msg.IPlayerAttribute|null|undefined} player2
         * @memberof Msg.LastPvpResp
         * @instance
         */
        LastPvpResp.prototype.player2 = null;

        /**
         * LastPvpResp pvp.
         * @member {Msg.IPvpBattle|null|undefined} pvp
         * @memberof Msg.LastPvpResp
         * @instance
         */
        LastPvpResp.prototype.pvp = null;

        /**
         * Creates a new LastPvpResp instance using the specified properties.
         * @function create
         * @memberof Msg.LastPvpResp
         * @static
         * @param {Msg.ILastPvpResp=} [properties] Properties to set
         * @returns {Msg.LastPvpResp} LastPvpResp instance
         */
        LastPvpResp.create = function create(properties) {
            return new LastPvpResp(properties);
        };

        /**
         * Encodes the specified LastPvpResp message. Does not implicitly {@link Msg.LastPvpResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.LastPvpResp
         * @static
         * @param {Msg.ILastPvpResp} message LastPvpResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LastPvpResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.roomID);
            if (message.player1 != null && message.hasOwnProperty("player1"))
                $root.Msg.PlayerAttribute.encode(message.player1, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.player2 != null && message.hasOwnProperty("player2"))
                $root.Msg.PlayerAttribute.encode(message.player2, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.pvp != null && message.hasOwnProperty("pvp"))
                $root.Msg.PvpBattle.encode(message.pvp, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LastPvpResp message, length delimited. Does not implicitly {@link Msg.LastPvpResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.LastPvpResp
         * @static
         * @param {Msg.ILastPvpResp} message LastPvpResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LastPvpResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LastPvpResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.LastPvpResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.LastPvpResp} LastPvpResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LastPvpResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.LastPvpResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.roomID = reader.string();
                    break;
                case 3:
                    message.player1 = $root.Msg.PlayerAttribute.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.player2 = $root.Msg.PlayerAttribute.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.pvp = $root.Msg.PvpBattle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LastPvpResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.LastPvpResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.LastPvpResp} LastPvpResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LastPvpResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LastPvpResp message.
         * @function verify
         * @memberof Msg.LastPvpResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LastPvpResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                if (!$util.isString(message.roomID))
                    return "roomID: string expected";
            if (message.player1 != null && message.hasOwnProperty("player1")) {
                var error = $root.Msg.PlayerAttribute.verify(message.player1);
                if (error)
                    return "player1." + error;
            }
            if (message.player2 != null && message.hasOwnProperty("player2")) {
                var error = $root.Msg.PlayerAttribute.verify(message.player2);
                if (error)
                    return "player2." + error;
            }
            if (message.pvp != null && message.hasOwnProperty("pvp")) {
                var error = $root.Msg.PvpBattle.verify(message.pvp);
                if (error)
                    return "pvp." + error;
            }
            return null;
        };

        /**
         * Creates a LastPvpResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.LastPvpResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.LastPvpResp} LastPvpResp
         */
        LastPvpResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.LastPvpResp)
                return object;
            var message = new $root.Msg.LastPvpResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "None":
            case 2:
                message.result = 2;
                break;
            }
            if (object.roomID != null)
                message.roomID = String(object.roomID);
            if (object.player1 != null) {
                if (typeof object.player1 !== "object")
                    throw TypeError(".Msg.LastPvpResp.player1: object expected");
                message.player1 = $root.Msg.PlayerAttribute.fromObject(object.player1);
            }
            if (object.player2 != null) {
                if (typeof object.player2 !== "object")
                    throw TypeError(".Msg.LastPvpResp.player2: object expected");
                message.player2 = $root.Msg.PlayerAttribute.fromObject(object.player2);
            }
            if (object.pvp != null) {
                if (typeof object.pvp !== "object")
                    throw TypeError(".Msg.LastPvpResp.pvp: object expected");
                message.pvp = $root.Msg.PvpBattle.fromObject(object.pvp);
            }
            return message;
        };

        /**
         * Creates a plain object from a LastPvpResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.LastPvpResp
         * @static
         * @param {Msg.LastPvpResp} message LastPvpResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LastPvpResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "Internal" : 0;
                object.roomID = "";
                object.player1 = null;
                object.player2 = null;
                object.pvp = null;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.LastPvpResp.Result[message.result] : message.result;
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                object.roomID = message.roomID;
            if (message.player1 != null && message.hasOwnProperty("player1"))
                object.player1 = $root.Msg.PlayerAttribute.toObject(message.player1, options);
            if (message.player2 != null && message.hasOwnProperty("player2"))
                object.player2 = $root.Msg.PlayerAttribute.toObject(message.player2, options);
            if (message.pvp != null && message.hasOwnProperty("pvp"))
                object.pvp = $root.Msg.PvpBattle.toObject(message.pvp, options);
            return object;
        };

        /**
         * Converts this LastPvpResp to JSON.
         * @function toJSON
         * @memberof Msg.LastPvpResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LastPvpResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.LastPvpResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         * @property {number} None=2 None value
         */
        LastPvpResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "None"] = 2;
            return values;
        })();

        return LastPvpResp;
    })();

    /**
     * ShootTurn enum.
     * @name Msg.ShootTurn
     * @enum {string}
     * @property {number} both=0 both value
     * @property {number} player1=1 player1 value
     * @property {number} player2=2 player2 value
     * @property {number} neither=3 neither value
     */
    Msg.ShootTurn = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "both"] = 0;
        values[valuesById[1] = "player1"] = 1;
        values[valuesById[2] = "player2"] = 2;
        values[valuesById[3] = "neither"] = 3;
        return values;
    })();

    Msg.PvpBattle = (function() {

        /**
         * Properties of a PvpBattle.
         * @memberof Msg
         * @interface IPvpBattle
         * @property {Msg.PvpBattle.Type|null} [type] PvpBattle type
         * @property {number|Long|null} [limit] PvpBattle limit
         * @property {string|null} [stageID] PvpBattle stageID
         */

        /**
         * Constructs a new PvpBattle.
         * @memberof Msg
         * @classdesc Represents a PvpBattle.
         * @implements IPvpBattle
         * @constructor
         * @param {Msg.IPvpBattle=} [properties] Properties to set
         */
        function PvpBattle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PvpBattle type.
         * @member {Msg.PvpBattle.Type} type
         * @memberof Msg.PvpBattle
         * @instance
         */
        PvpBattle.prototype.type = 0;

        /**
         * PvpBattle limit.
         * @member {number|Long} limit
         * @memberof Msg.PvpBattle
         * @instance
         */
        PvpBattle.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PvpBattle stageID.
         * @member {string} stageID
         * @memberof Msg.PvpBattle
         * @instance
         */
        PvpBattle.prototype.stageID = "";

        /**
         * Creates a new PvpBattle instance using the specified properties.
         * @function create
         * @memberof Msg.PvpBattle
         * @static
         * @param {Msg.IPvpBattle=} [properties] Properties to set
         * @returns {Msg.PvpBattle} PvpBattle instance
         */
        PvpBattle.create = function create(properties) {
            return new PvpBattle(properties);
        };

        /**
         * Encodes the specified PvpBattle message. Does not implicitly {@link Msg.PvpBattle.verify|verify} messages.
         * @function encode
         * @memberof Msg.PvpBattle
         * @static
         * @param {Msg.IPvpBattle} message PvpBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpBattle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.limit != null && message.hasOwnProperty("limit"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.limit);
            if (message.stageID != null && message.hasOwnProperty("stageID"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stageID);
            return writer;
        };

        /**
         * Encodes the specified PvpBattle message, length delimited. Does not implicitly {@link Msg.PvpBattle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PvpBattle
         * @static
         * @param {Msg.IPvpBattle} message PvpBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpBattle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PvpBattle message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PvpBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PvpBattle} PvpBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpBattle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PvpBattle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.limit = reader.int64();
                    break;
                case 3:
                    message.stageID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PvpBattle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PvpBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PvpBattle} PvpBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpBattle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PvpBattle message.
         * @function verify
         * @memberof Msg.PvpBattle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PvpBattle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                    return "limit: integer|Long expected";
            if (message.stageID != null && message.hasOwnProperty("stageID"))
                if (!$util.isString(message.stageID))
                    return "stageID: string expected";
            return null;
        };

        /**
         * Creates a PvpBattle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PvpBattle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PvpBattle} PvpBattle
         */
        PvpBattle.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PvpBattle)
                return object;
            var message = new $root.Msg.PvpBattle();
            switch (object.type) {
            case "time":
            case 0:
                message.type = 0;
                break;
            case "round":
            case 1:
                message.type = 1;
                break;
            }
            if (object.limit != null)
                if ($util.Long)
                    (message.limit = $util.Long.fromValue(object.limit)).unsigned = false;
                else if (typeof object.limit === "string")
                    message.limit = parseInt(object.limit, 10);
                else if (typeof object.limit === "number")
                    message.limit = object.limit;
                else if (typeof object.limit === "object")
                    message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber();
            if (object.stageID != null)
                message.stageID = String(object.stageID);
            return message;
        };

        /**
         * Creates a plain object from a PvpBattle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PvpBattle
         * @static
         * @param {Msg.PvpBattle} message PvpBattle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PvpBattle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "time" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.limit = options.longs === String ? "0" : 0;
                object.stageID = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.Msg.PvpBattle.Type[message.type] : message.type;
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (typeof message.limit === "number")
                    object.limit = options.longs === String ? String(message.limit) : message.limit;
                else
                    object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber() : message.limit;
            if (message.stageID != null && message.hasOwnProperty("stageID"))
                object.stageID = message.stageID;
            return object;
        };

        /**
         * Converts this PvpBattle to JSON.
         * @function toJSON
         * @memberof Msg.PvpBattle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PvpBattle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name Msg.PvpBattle.Type
         * @enum {string}
         * @property {number} time=0 time value
         * @property {number} round=1 round value
         */
        PvpBattle.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "time"] = 0;
            values[valuesById[1] = "round"] = 1;
            return values;
        })();

        return PvpBattle;
    })();

    Msg.Shoot = (function() {

        /**
         * Properties of a Shoot.
         * @memberof Msg
         * @interface IShoot
         * @property {number|Long|null} [index] Shoot index
         * @property {number|null} [score] Shoot score
         * @property {boolean|null} [isLastFrame] Shoot isLastFrame
         * @property {string|null} [data] Shoot data
         */

        /**
         * Constructs a new Shoot.
         * @memberof Msg
         * @classdesc Represents a Shoot.
         * @implements IShoot
         * @constructor
         * @param {Msg.IShoot=} [properties] Properties to set
         */
        function Shoot(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Shoot index.
         * @member {number|Long} index
         * @memberof Msg.Shoot
         * @instance
         */
        Shoot.prototype.index = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Shoot score.
         * @member {number} score
         * @memberof Msg.Shoot
         * @instance
         */
        Shoot.prototype.score = 0;

        /**
         * Shoot isLastFrame.
         * @member {boolean} isLastFrame
         * @memberof Msg.Shoot
         * @instance
         */
        Shoot.prototype.isLastFrame = false;

        /**
         * Shoot data.
         * @member {string} data
         * @memberof Msg.Shoot
         * @instance
         */
        Shoot.prototype.data = "";

        /**
         * Creates a new Shoot instance using the specified properties.
         * @function create
         * @memberof Msg.Shoot
         * @static
         * @param {Msg.IShoot=} [properties] Properties to set
         * @returns {Msg.Shoot} Shoot instance
         */
        Shoot.create = function create(properties) {
            return new Shoot(properties);
        };

        /**
         * Encodes the specified Shoot message. Does not implicitly {@link Msg.Shoot.verify|verify} messages.
         * @function encode
         * @memberof Msg.Shoot
         * @static
         * @param {Msg.IShoot} message Shoot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Shoot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.index);
            if (message.score != null && message.hasOwnProperty("score"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.score);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.data);
            if (message.isLastFrame != null && message.hasOwnProperty("isLastFrame"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isLastFrame);
            return writer;
        };

        /**
         * Encodes the specified Shoot message, length delimited. Does not implicitly {@link Msg.Shoot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.Shoot
         * @static
         * @param {Msg.IShoot} message Shoot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Shoot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Shoot message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.Shoot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.Shoot} Shoot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Shoot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.Shoot();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int64();
                    break;
                case 2:
                    message.score = reader.float();
                    break;
                case 4:
                    message.isLastFrame = reader.bool();
                    break;
                case 3:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Shoot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.Shoot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.Shoot} Shoot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Shoot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Shoot message.
         * @function verify
         * @memberof Msg.Shoot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Shoot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                    return "index: integer|Long expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (typeof message.score !== "number")
                    return "score: number expected";
            if (message.isLastFrame != null && message.hasOwnProperty("isLastFrame"))
                if (typeof message.isLastFrame !== "boolean")
                    return "isLastFrame: boolean expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isString(message.data))
                    return "data: string expected";
            return null;
        };

        /**
         * Creates a Shoot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.Shoot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.Shoot} Shoot
         */
        Shoot.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.Shoot)
                return object;
            var message = new $root.Msg.Shoot();
            if (object.index != null)
                if ($util.Long)
                    (message.index = $util.Long.fromValue(object.index)).unsigned = false;
                else if (typeof object.index === "string")
                    message.index = parseInt(object.index, 10);
                else if (typeof object.index === "number")
                    message.index = object.index;
                else if (typeof object.index === "object")
                    message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber();
            if (object.score != null)
                message.score = Number(object.score);
            if (object.isLastFrame != null)
                message.isLastFrame = Boolean(object.isLastFrame);
            if (object.data != null)
                message.data = String(object.data);
            return message;
        };

        /**
         * Creates a plain object from a Shoot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.Shoot
         * @static
         * @param {Msg.Shoot} message Shoot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Shoot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.index = options.longs === String ? "0" : 0;
                object.score = 0;
                object.data = "";
                object.isLastFrame = false;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                if (typeof message.index === "number")
                    object.index = options.longs === String ? String(message.index) : message.index;
                else
                    object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber() : message.index;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            if (message.isLastFrame != null && message.hasOwnProperty("isLastFrame"))
                object.isLastFrame = message.isLastFrame;
            return object;
        };

        /**
         * Converts this Shoot to JSON.
         * @function toJSON
         * @memberof Msg.Shoot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Shoot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Shoot;
    })();

    Msg.PvpStartReq = (function() {

        /**
         * Properties of a PvpStartReq.
         * @memberof Msg
         * @interface IPvpStartReq
         * @property {string|null} [playerID] PvpStartReq playerID
         */

        /**
         * Constructs a new PvpStartReq.
         * @memberof Msg
         * @classdesc Represents a PvpStartReq.
         * @implements IPvpStartReq
         * @constructor
         * @param {Msg.IPvpStartReq=} [properties] Properties to set
         */
        function PvpStartReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PvpStartReq playerID.
         * @member {string} playerID
         * @memberof Msg.PvpStartReq
         * @instance
         */
        PvpStartReq.prototype.playerID = "";

        /**
         * Creates a new PvpStartReq instance using the specified properties.
         * @function create
         * @memberof Msg.PvpStartReq
         * @static
         * @param {Msg.IPvpStartReq=} [properties] Properties to set
         * @returns {Msg.PvpStartReq} PvpStartReq instance
         */
        PvpStartReq.create = function create(properties) {
            return new PvpStartReq(properties);
        };

        /**
         * Encodes the specified PvpStartReq message. Does not implicitly {@link Msg.PvpStartReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.PvpStartReq
         * @static
         * @param {Msg.IPvpStartReq} message PvpStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpStartReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified PvpStartReq message, length delimited. Does not implicitly {@link Msg.PvpStartReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PvpStartReq
         * @static
         * @param {Msg.IPvpStartReq} message PvpStartReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpStartReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PvpStartReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PvpStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PvpStartReq} PvpStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpStartReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PvpStartReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PvpStartReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PvpStartReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PvpStartReq} PvpStartReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpStartReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PvpStartReq message.
         * @function verify
         * @memberof Msg.PvpStartReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PvpStartReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a PvpStartReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PvpStartReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PvpStartReq} PvpStartReq
         */
        PvpStartReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PvpStartReq)
                return object;
            var message = new $root.Msg.PvpStartReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a PvpStartReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PvpStartReq
         * @static
         * @param {Msg.PvpStartReq} message PvpStartReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PvpStartReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playerID = "";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this PvpStartReq to JSON.
         * @function toJSON
         * @memberof Msg.PvpStartReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PvpStartReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PvpStartReq;
    })();

    Msg.PvpStartResp = (function() {

        /**
         * Properties of a PvpStartResp.
         * @memberof Msg
         * @interface IPvpStartResp
         * @property {Msg.PvpStartResp.Result|null} [result] PvpStartResp result
         */

        /**
         * Constructs a new PvpStartResp.
         * @memberof Msg
         * @classdesc Represents a PvpStartResp.
         * @implements IPvpStartResp
         * @constructor
         * @param {Msg.IPvpStartResp=} [properties] Properties to set
         */
        function PvpStartResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PvpStartResp result.
         * @member {Msg.PvpStartResp.Result} result
         * @memberof Msg.PvpStartResp
         * @instance
         */
        PvpStartResp.prototype.result = 0;

        /**
         * Creates a new PvpStartResp instance using the specified properties.
         * @function create
         * @memberof Msg.PvpStartResp
         * @static
         * @param {Msg.IPvpStartResp=} [properties] Properties to set
         * @returns {Msg.PvpStartResp} PvpStartResp instance
         */
        PvpStartResp.create = function create(properties) {
            return new PvpStartResp(properties);
        };

        /**
         * Encodes the specified PvpStartResp message. Does not implicitly {@link Msg.PvpStartResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.PvpStartResp
         * @static
         * @param {Msg.IPvpStartResp} message PvpStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpStartResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified PvpStartResp message, length delimited. Does not implicitly {@link Msg.PvpStartResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PvpStartResp
         * @static
         * @param {Msg.IPvpStartResp} message PvpStartResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpStartResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PvpStartResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PvpStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PvpStartResp} PvpStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpStartResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PvpStartResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PvpStartResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PvpStartResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PvpStartResp} PvpStartResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpStartResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PvpStartResp message.
         * @function verify
         * @memberof Msg.PvpStartResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PvpStartResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a PvpStartResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PvpStartResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PvpStartResp} PvpStartResp
         */
        PvpStartResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PvpStartResp)
                return object;
            var message = new $root.Msg.PvpStartResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "AlreadyInPool":
            case 2:
                message.result = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PvpStartResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PvpStartResp
         * @static
         * @param {Msg.PvpStartResp} message PvpStartResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PvpStartResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "Internal" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.PvpStartResp.Result[message.result] : message.result;
            return object;
        };

        /**
         * Converts this PvpStartResp to JSON.
         * @function toJSON
         * @memberof Msg.PvpStartResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PvpStartResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.PvpStartResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         * @property {number} AlreadyInPool=2 AlreadyInPool value
         */
        PvpStartResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "AlreadyInPool"] = 2;
            return values;
        })();

        return PvpStartResp;
    })();

    Msg.PvpStopMatchReq = (function() {

        /**
         * Properties of a PvpStopMatchReq.
         * @memberof Msg
         * @interface IPvpStopMatchReq
         * @property {string|null} [playerID] PvpStopMatchReq playerID
         */

        /**
         * Constructs a new PvpStopMatchReq.
         * @memberof Msg
         * @classdesc Represents a PvpStopMatchReq.
         * @implements IPvpStopMatchReq
         * @constructor
         * @param {Msg.IPvpStopMatchReq=} [properties] Properties to set
         */
        function PvpStopMatchReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PvpStopMatchReq playerID.
         * @member {string} playerID
         * @memberof Msg.PvpStopMatchReq
         * @instance
         */
        PvpStopMatchReq.prototype.playerID = "";

        /**
         * Creates a new PvpStopMatchReq instance using the specified properties.
         * @function create
         * @memberof Msg.PvpStopMatchReq
         * @static
         * @param {Msg.IPvpStopMatchReq=} [properties] Properties to set
         * @returns {Msg.PvpStopMatchReq} PvpStopMatchReq instance
         */
        PvpStopMatchReq.create = function create(properties) {
            return new PvpStopMatchReq(properties);
        };

        /**
         * Encodes the specified PvpStopMatchReq message. Does not implicitly {@link Msg.PvpStopMatchReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.PvpStopMatchReq
         * @static
         * @param {Msg.IPvpStopMatchReq} message PvpStopMatchReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpStopMatchReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified PvpStopMatchReq message, length delimited. Does not implicitly {@link Msg.PvpStopMatchReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PvpStopMatchReq
         * @static
         * @param {Msg.IPvpStopMatchReq} message PvpStopMatchReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpStopMatchReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PvpStopMatchReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PvpStopMatchReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PvpStopMatchReq} PvpStopMatchReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpStopMatchReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PvpStopMatchReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PvpStopMatchReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PvpStopMatchReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PvpStopMatchReq} PvpStopMatchReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpStopMatchReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PvpStopMatchReq message.
         * @function verify
         * @memberof Msg.PvpStopMatchReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PvpStopMatchReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a PvpStopMatchReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PvpStopMatchReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PvpStopMatchReq} PvpStopMatchReq
         */
        PvpStopMatchReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PvpStopMatchReq)
                return object;
            var message = new $root.Msg.PvpStopMatchReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a PvpStopMatchReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PvpStopMatchReq
         * @static
         * @param {Msg.PvpStopMatchReq} message PvpStopMatchReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PvpStopMatchReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playerID = "";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this PvpStopMatchReq to JSON.
         * @function toJSON
         * @memberof Msg.PvpStopMatchReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PvpStopMatchReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PvpStopMatchReq;
    })();

    Msg.PvpStopMatchResp = (function() {

        /**
         * Properties of a PvpStopMatchResp.
         * @memberof Msg
         * @interface IPvpStopMatchResp
         * @property {Msg.PvpStopMatchResp.Result|null} [result] PvpStopMatchResp result
         */

        /**
         * Constructs a new PvpStopMatchResp.
         * @memberof Msg
         * @classdesc Represents a PvpStopMatchResp.
         * @implements IPvpStopMatchResp
         * @constructor
         * @param {Msg.IPvpStopMatchResp=} [properties] Properties to set
         */
        function PvpStopMatchResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PvpStopMatchResp result.
         * @member {Msg.PvpStopMatchResp.Result} result
         * @memberof Msg.PvpStopMatchResp
         * @instance
         */
        PvpStopMatchResp.prototype.result = 0;

        /**
         * Creates a new PvpStopMatchResp instance using the specified properties.
         * @function create
         * @memberof Msg.PvpStopMatchResp
         * @static
         * @param {Msg.IPvpStopMatchResp=} [properties] Properties to set
         * @returns {Msg.PvpStopMatchResp} PvpStopMatchResp instance
         */
        PvpStopMatchResp.create = function create(properties) {
            return new PvpStopMatchResp(properties);
        };

        /**
         * Encodes the specified PvpStopMatchResp message. Does not implicitly {@link Msg.PvpStopMatchResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.PvpStopMatchResp
         * @static
         * @param {Msg.IPvpStopMatchResp} message PvpStopMatchResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpStopMatchResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified PvpStopMatchResp message, length delimited. Does not implicitly {@link Msg.PvpStopMatchResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PvpStopMatchResp
         * @static
         * @param {Msg.IPvpStopMatchResp} message PvpStopMatchResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpStopMatchResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PvpStopMatchResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PvpStopMatchResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PvpStopMatchResp} PvpStopMatchResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpStopMatchResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PvpStopMatchResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PvpStopMatchResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PvpStopMatchResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PvpStopMatchResp} PvpStopMatchResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpStopMatchResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PvpStopMatchResp message.
         * @function verify
         * @memberof Msg.PvpStopMatchResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PvpStopMatchResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a PvpStopMatchResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PvpStopMatchResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PvpStopMatchResp} PvpStopMatchResp
         */
        PvpStopMatchResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PvpStopMatchResp)
                return object;
            var message = new $root.Msg.PvpStopMatchResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PvpStopMatchResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PvpStopMatchResp
         * @static
         * @param {Msg.PvpStopMatchResp} message PvpStopMatchResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PvpStopMatchResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "Internal" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.PvpStopMatchResp.Result[message.result] : message.result;
            return object;
        };

        /**
         * Converts this PvpStopMatchResp to JSON.
         * @function toJSON
         * @memberof Msg.PvpStopMatchResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PvpStopMatchResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.PvpStopMatchResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        PvpStopMatchResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return PvpStopMatchResp;
    })();

    Msg.PvpEnterRoomReq = (function() {

        /**
         * Properties of a PvpEnterRoomReq.
         * @memberof Msg
         * @interface IPvpEnterRoomReq
         * @property {string|null} [playerID] PvpEnterRoomReq playerID
         * @property {string|null} [RoomID] PvpEnterRoomReq RoomID
         */

        /**
         * Constructs a new PvpEnterRoomReq.
         * @memberof Msg
         * @classdesc Represents a PvpEnterRoomReq.
         * @implements IPvpEnterRoomReq
         * @constructor
         * @param {Msg.IPvpEnterRoomReq=} [properties] Properties to set
         */
        function PvpEnterRoomReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PvpEnterRoomReq playerID.
         * @member {string} playerID
         * @memberof Msg.PvpEnterRoomReq
         * @instance
         */
        PvpEnterRoomReq.prototype.playerID = "";

        /**
         * PvpEnterRoomReq RoomID.
         * @member {string} RoomID
         * @memberof Msg.PvpEnterRoomReq
         * @instance
         */
        PvpEnterRoomReq.prototype.RoomID = "";

        /**
         * Creates a new PvpEnterRoomReq instance using the specified properties.
         * @function create
         * @memberof Msg.PvpEnterRoomReq
         * @static
         * @param {Msg.IPvpEnterRoomReq=} [properties] Properties to set
         * @returns {Msg.PvpEnterRoomReq} PvpEnterRoomReq instance
         */
        PvpEnterRoomReq.create = function create(properties) {
            return new PvpEnterRoomReq(properties);
        };

        /**
         * Encodes the specified PvpEnterRoomReq message. Does not implicitly {@link Msg.PvpEnterRoomReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.PvpEnterRoomReq
         * @static
         * @param {Msg.IPvpEnterRoomReq} message PvpEnterRoomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpEnterRoomReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            if (message.RoomID != null && message.hasOwnProperty("RoomID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.RoomID);
            return writer;
        };

        /**
         * Encodes the specified PvpEnterRoomReq message, length delimited. Does not implicitly {@link Msg.PvpEnterRoomReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PvpEnterRoomReq
         * @static
         * @param {Msg.IPvpEnterRoomReq} message PvpEnterRoomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpEnterRoomReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PvpEnterRoomReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PvpEnterRoomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PvpEnterRoomReq} PvpEnterRoomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpEnterRoomReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PvpEnterRoomReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                case 2:
                    message.RoomID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PvpEnterRoomReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PvpEnterRoomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PvpEnterRoomReq} PvpEnterRoomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpEnterRoomReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PvpEnterRoomReq message.
         * @function verify
         * @memberof Msg.PvpEnterRoomReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PvpEnterRoomReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            if (message.RoomID != null && message.hasOwnProperty("RoomID"))
                if (!$util.isString(message.RoomID))
                    return "RoomID: string expected";
            return null;
        };

        /**
         * Creates a PvpEnterRoomReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PvpEnterRoomReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PvpEnterRoomReq} PvpEnterRoomReq
         */
        PvpEnterRoomReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PvpEnterRoomReq)
                return object;
            var message = new $root.Msg.PvpEnterRoomReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            if (object.RoomID != null)
                message.RoomID = String(object.RoomID);
            return message;
        };

        /**
         * Creates a plain object from a PvpEnterRoomReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PvpEnterRoomReq
         * @static
         * @param {Msg.PvpEnterRoomReq} message PvpEnterRoomReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PvpEnterRoomReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerID = "";
                object.RoomID = "";
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.RoomID != null && message.hasOwnProperty("RoomID"))
                object.RoomID = message.RoomID;
            return object;
        };

        /**
         * Converts this PvpEnterRoomReq to JSON.
         * @function toJSON
         * @memberof Msg.PvpEnterRoomReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PvpEnterRoomReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PvpEnterRoomReq;
    })();

    Msg.PvpEnterRoomResp = (function() {

        /**
         * Properties of a PvpEnterRoomResp.
         * @memberof Msg
         * @interface IPvpEnterRoomResp
         * @property {Msg.PvpEnterRoomResp.Result|null} [result] PvpEnterRoomResp result
         * @property {number|Long|null} [timeStamp] PvpEnterRoomResp timeStamp
         */

        /**
         * Constructs a new PvpEnterRoomResp.
         * @memberof Msg
         * @classdesc Represents a PvpEnterRoomResp.
         * @implements IPvpEnterRoomResp
         * @constructor
         * @param {Msg.IPvpEnterRoomResp=} [properties] Properties to set
         */
        function PvpEnterRoomResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PvpEnterRoomResp result.
         * @member {Msg.PvpEnterRoomResp.Result} result
         * @memberof Msg.PvpEnterRoomResp
         * @instance
         */
        PvpEnterRoomResp.prototype.result = 0;

        /**
         * PvpEnterRoomResp timeStamp.
         * @member {number|Long} timeStamp
         * @memberof Msg.PvpEnterRoomResp
         * @instance
         */
        PvpEnterRoomResp.prototype.timeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PvpEnterRoomResp instance using the specified properties.
         * @function create
         * @memberof Msg.PvpEnterRoomResp
         * @static
         * @param {Msg.IPvpEnterRoomResp=} [properties] Properties to set
         * @returns {Msg.PvpEnterRoomResp} PvpEnterRoomResp instance
         */
        PvpEnterRoomResp.create = function create(properties) {
            return new PvpEnterRoomResp(properties);
        };

        /**
         * Encodes the specified PvpEnterRoomResp message. Does not implicitly {@link Msg.PvpEnterRoomResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.PvpEnterRoomResp
         * @static
         * @param {Msg.IPvpEnterRoomResp} message PvpEnterRoomResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpEnterRoomResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timeStamp);
            return writer;
        };

        /**
         * Encodes the specified PvpEnterRoomResp message, length delimited. Does not implicitly {@link Msg.PvpEnterRoomResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PvpEnterRoomResp
         * @static
         * @param {Msg.IPvpEnterRoomResp} message PvpEnterRoomResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpEnterRoomResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PvpEnterRoomResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PvpEnterRoomResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PvpEnterRoomResp} PvpEnterRoomResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpEnterRoomResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PvpEnterRoomResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.timeStamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PvpEnterRoomResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PvpEnterRoomResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PvpEnterRoomResp} PvpEnterRoomResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpEnterRoomResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PvpEnterRoomResp message.
         * @function verify
         * @memberof Msg.PvpEnterRoomResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PvpEnterRoomResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                if (!$util.isInteger(message.timeStamp) && !(message.timeStamp && $util.isInteger(message.timeStamp.low) && $util.isInteger(message.timeStamp.high)))
                    return "timeStamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a PvpEnterRoomResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PvpEnterRoomResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PvpEnterRoomResp} PvpEnterRoomResp
         */
        PvpEnterRoomResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PvpEnterRoomResp)
                return object;
            var message = new $root.Msg.PvpEnterRoomResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "TimeOut":
            case 2:
                message.result = 2;
                break;
            }
            if (object.timeStamp != null)
                if ($util.Long)
                    (message.timeStamp = $util.Long.fromValue(object.timeStamp)).unsigned = false;
                else if (typeof object.timeStamp === "string")
                    message.timeStamp = parseInt(object.timeStamp, 10);
                else if (typeof object.timeStamp === "number")
                    message.timeStamp = object.timeStamp;
                else if (typeof object.timeStamp === "object")
                    message.timeStamp = new $util.LongBits(object.timeStamp.low >>> 0, object.timeStamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PvpEnterRoomResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PvpEnterRoomResp
         * @static
         * @param {Msg.PvpEnterRoomResp} message PvpEnterRoomResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PvpEnterRoomResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "Internal" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeStamp = options.longs === String ? "0" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.PvpEnterRoomResp.Result[message.result] : message.result;
            if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                if (typeof message.timeStamp === "number")
                    object.timeStamp = options.longs === String ? String(message.timeStamp) : message.timeStamp;
                else
                    object.timeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.timeStamp) : options.longs === Number ? new $util.LongBits(message.timeStamp.low >>> 0, message.timeStamp.high >>> 0).toNumber() : message.timeStamp;
            return object;
        };

        /**
         * Converts this PvpEnterRoomResp to JSON.
         * @function toJSON
         * @memberof Msg.PvpEnterRoomResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PvpEnterRoomResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.PvpEnterRoomResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         * @property {number} TimeOut=2 TimeOut value
         */
        PvpEnterRoomResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "TimeOut"] = 2;
            return values;
        })();

        return PvpEnterRoomResp;
    })();

    Msg.PvpShootReq = (function() {

        /**
         * Properties of a PvpShootReq.
         * @memberof Msg
         * @interface IPvpShootReq
         * @property {string|null} [roomID] PvpShootReq roomID
         * @property {string|null} [playerID] PvpShootReq playerID
         * @property {Array.<Msg.IShoot>|null} [shoots] PvpShootReq shoots
         */

        /**
         * Constructs a new PvpShootReq.
         * @memberof Msg
         * @classdesc Represents a PvpShootReq.
         * @implements IPvpShootReq
         * @constructor
         * @param {Msg.IPvpShootReq=} [properties] Properties to set
         */
        function PvpShootReq(properties) {
            this.shoots = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PvpShootReq roomID.
         * @member {string} roomID
         * @memberof Msg.PvpShootReq
         * @instance
         */
        PvpShootReq.prototype.roomID = "";

        /**
         * PvpShootReq playerID.
         * @member {string} playerID
         * @memberof Msg.PvpShootReq
         * @instance
         */
        PvpShootReq.prototype.playerID = "";

        /**
         * PvpShootReq shoots.
         * @member {Array.<Msg.IShoot>} shoots
         * @memberof Msg.PvpShootReq
         * @instance
         */
        PvpShootReq.prototype.shoots = $util.emptyArray;

        /**
         * Creates a new PvpShootReq instance using the specified properties.
         * @function create
         * @memberof Msg.PvpShootReq
         * @static
         * @param {Msg.IPvpShootReq=} [properties] Properties to set
         * @returns {Msg.PvpShootReq} PvpShootReq instance
         */
        PvpShootReq.create = function create(properties) {
            return new PvpShootReq(properties);
        };

        /**
         * Encodes the specified PvpShootReq message. Does not implicitly {@link Msg.PvpShootReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.PvpShootReq
         * @static
         * @param {Msg.IPvpShootReq} message PvpShootReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpShootReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.roomID);
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.playerID);
            if (message.shoots != null && message.shoots.length)
                for (var i = 0; i < message.shoots.length; ++i)
                    $root.Msg.Shoot.encode(message.shoots[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PvpShootReq message, length delimited. Does not implicitly {@link Msg.PvpShootReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PvpShootReq
         * @static
         * @param {Msg.IPvpShootReq} message PvpShootReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpShootReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PvpShootReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PvpShootReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PvpShootReq} PvpShootReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpShootReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PvpShootReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomID = reader.string();
                    break;
                case 2:
                    message.playerID = reader.string();
                    break;
                case 3:
                    if (!(message.shoots && message.shoots.length))
                        message.shoots = [];
                    message.shoots.push($root.Msg.Shoot.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PvpShootReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PvpShootReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PvpShootReq} PvpShootReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpShootReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PvpShootReq message.
         * @function verify
         * @memberof Msg.PvpShootReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PvpShootReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                if (!$util.isString(message.roomID))
                    return "roomID: string expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            if (message.shoots != null && message.hasOwnProperty("shoots")) {
                if (!Array.isArray(message.shoots))
                    return "shoots: array expected";
                for (var i = 0; i < message.shoots.length; ++i) {
                    var error = $root.Msg.Shoot.verify(message.shoots[i]);
                    if (error)
                        return "shoots." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PvpShootReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PvpShootReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PvpShootReq} PvpShootReq
         */
        PvpShootReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PvpShootReq)
                return object;
            var message = new $root.Msg.PvpShootReq();
            if (object.roomID != null)
                message.roomID = String(object.roomID);
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            if (object.shoots) {
                if (!Array.isArray(object.shoots))
                    throw TypeError(".Msg.PvpShootReq.shoots: array expected");
                message.shoots = [];
                for (var i = 0; i < object.shoots.length; ++i) {
                    if (typeof object.shoots[i] !== "object")
                        throw TypeError(".Msg.PvpShootReq.shoots: object expected");
                    message.shoots[i] = $root.Msg.Shoot.fromObject(object.shoots[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PvpShootReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PvpShootReq
         * @static
         * @param {Msg.PvpShootReq} message PvpShootReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PvpShootReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.shoots = [];
            if (options.defaults) {
                object.roomID = "";
                object.playerID = "";
            }
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                object.roomID = message.roomID;
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.shoots && message.shoots.length) {
                object.shoots = [];
                for (var j = 0; j < message.shoots.length; ++j)
                    object.shoots[j] = $root.Msg.Shoot.toObject(message.shoots[j], options);
            }
            return object;
        };

        /**
         * Converts this PvpShootReq to JSON.
         * @function toJSON
         * @memberof Msg.PvpShootReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PvpShootReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PvpShootReq;
    })();

    Msg.PvpShootResp = (function() {

        /**
         * Properties of a PvpShootResp.
         * @memberof Msg
         * @interface IPvpShootResp
         * @property {Msg.PvpShootResp.Result|null} [result] PvpShootResp result
         * @property {number|Long|null} [recIndex] PvpShootResp recIndex
         * @property {Msg.PvpShootResp.OppStatus|null} [oppoStatus] PvpShootResp oppoStatus
         */

        /**
         * Constructs a new PvpShootResp.
         * @memberof Msg
         * @classdesc Represents a PvpShootResp.
         * @implements IPvpShootResp
         * @constructor
         * @param {Msg.IPvpShootResp=} [properties] Properties to set
         */
        function PvpShootResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PvpShootResp result.
         * @member {Msg.PvpShootResp.Result} result
         * @memberof Msg.PvpShootResp
         * @instance
         */
        PvpShootResp.prototype.result = 0;

        /**
         * PvpShootResp recIndex.
         * @member {number|Long} recIndex
         * @memberof Msg.PvpShootResp
         * @instance
         */
        PvpShootResp.prototype.recIndex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PvpShootResp oppoStatus.
         * @member {Msg.PvpShootResp.OppStatus} oppoStatus
         * @memberof Msg.PvpShootResp
         * @instance
         */
        PvpShootResp.prototype.oppoStatus = 0;

        /**
         * Creates a new PvpShootResp instance using the specified properties.
         * @function create
         * @memberof Msg.PvpShootResp
         * @static
         * @param {Msg.IPvpShootResp=} [properties] Properties to set
         * @returns {Msg.PvpShootResp} PvpShootResp instance
         */
        PvpShootResp.create = function create(properties) {
            return new PvpShootResp(properties);
        };

        /**
         * Encodes the specified PvpShootResp message. Does not implicitly {@link Msg.PvpShootResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.PvpShootResp
         * @static
         * @param {Msg.IPvpShootResp} message PvpShootResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpShootResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.recIndex != null && message.hasOwnProperty("recIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.recIndex);
            if (message.oppoStatus != null && message.hasOwnProperty("oppoStatus"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.oppoStatus);
            return writer;
        };

        /**
         * Encodes the specified PvpShootResp message, length delimited. Does not implicitly {@link Msg.PvpShootResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PvpShootResp
         * @static
         * @param {Msg.IPvpShootResp} message PvpShootResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpShootResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PvpShootResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PvpShootResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PvpShootResp} PvpShootResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpShootResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PvpShootResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.recIndex = reader.int64();
                    break;
                case 3:
                    message.oppoStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PvpShootResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PvpShootResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PvpShootResp} PvpShootResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpShootResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PvpShootResp message.
         * @function verify
         * @memberof Msg.PvpShootResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PvpShootResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.recIndex != null && message.hasOwnProperty("recIndex"))
                if (!$util.isInteger(message.recIndex) && !(message.recIndex && $util.isInteger(message.recIndex.low) && $util.isInteger(message.recIndex.high)))
                    return "recIndex: integer|Long expected";
            if (message.oppoStatus != null && message.hasOwnProperty("oppoStatus"))
                switch (message.oppoStatus) {
                default:
                    return "oppoStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a PvpShootResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PvpShootResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PvpShootResp} PvpShootResp
         */
        PvpShootResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PvpShootResp)
                return object;
            var message = new $root.Msg.PvpShootResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "WrongTurn":
            case 2:
                message.result = 2;
                break;
            case "InvalidRoomID":
            case 3:
                message.result = 3;
                break;
            }
            if (object.recIndex != null)
                if ($util.Long)
                    (message.recIndex = $util.Long.fromValue(object.recIndex)).unsigned = false;
                else if (typeof object.recIndex === "string")
                    message.recIndex = parseInt(object.recIndex, 10);
                else if (typeof object.recIndex === "number")
                    message.recIndex = object.recIndex;
                else if (typeof object.recIndex === "object")
                    message.recIndex = new $util.LongBits(object.recIndex.low >>> 0, object.recIndex.high >>> 0).toNumber();
            switch (object.oppoStatus) {
            case "online":
            case 0:
                message.oppoStatus = 0;
                break;
            case "reconnect":
            case 1:
                message.oppoStatus = 1;
                break;
            case "surrender":
            case 2:
                message.oppoStatus = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PvpShootResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PvpShootResp
         * @static
         * @param {Msg.PvpShootResp} message PvpShootResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PvpShootResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "Internal" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.recIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.recIndex = options.longs === String ? "0" : 0;
                object.oppoStatus = options.enums === String ? "online" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.PvpShootResp.Result[message.result] : message.result;
            if (message.recIndex != null && message.hasOwnProperty("recIndex"))
                if (typeof message.recIndex === "number")
                    object.recIndex = options.longs === String ? String(message.recIndex) : message.recIndex;
                else
                    object.recIndex = options.longs === String ? $util.Long.prototype.toString.call(message.recIndex) : options.longs === Number ? new $util.LongBits(message.recIndex.low >>> 0, message.recIndex.high >>> 0).toNumber() : message.recIndex;
            if (message.oppoStatus != null && message.hasOwnProperty("oppoStatus"))
                object.oppoStatus = options.enums === String ? $root.Msg.PvpShootResp.OppStatus[message.oppoStatus] : message.oppoStatus;
            return object;
        };

        /**
         * Converts this PvpShootResp to JSON.
         * @function toJSON
         * @memberof Msg.PvpShootResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PvpShootResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.PvpShootResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         * @property {number} WrongTurn=2 WrongTurn value
         * @property {number} InvalidRoomID=3 InvalidRoomID value
         */
        PvpShootResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "WrongTurn"] = 2;
            values[valuesById[3] = "InvalidRoomID"] = 3;
            return values;
        })();

        /**
         * OppStatus enum.
         * @name Msg.PvpShootResp.OppStatus
         * @enum {string}
         * @property {number} online=0 online value
         * @property {number} reconnect=1 reconnect value
         * @property {number} surrender=2 surrender value
         */
        PvpShootResp.OppStatus = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "online"] = 0;
            values[valuesById[1] = "reconnect"] = 1;
            values[valuesById[2] = "surrender"] = 2;
            return values;
        })();

        return PvpShootResp;
    })();

    Msg.PvpSurrenderReq = (function() {

        /**
         * Properties of a PvpSurrenderReq.
         * @memberof Msg
         * @interface IPvpSurrenderReq
         * @property {string|null} [RoomID] PvpSurrenderReq RoomID
         * @property {string|null} [playerID] PvpSurrenderReq playerID
         */

        /**
         * Constructs a new PvpSurrenderReq.
         * @memberof Msg
         * @classdesc Represents a PvpSurrenderReq.
         * @implements IPvpSurrenderReq
         * @constructor
         * @param {Msg.IPvpSurrenderReq=} [properties] Properties to set
         */
        function PvpSurrenderReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PvpSurrenderReq RoomID.
         * @member {string} RoomID
         * @memberof Msg.PvpSurrenderReq
         * @instance
         */
        PvpSurrenderReq.prototype.RoomID = "";

        /**
         * PvpSurrenderReq playerID.
         * @member {string} playerID
         * @memberof Msg.PvpSurrenderReq
         * @instance
         */
        PvpSurrenderReq.prototype.playerID = "";

        /**
         * Creates a new PvpSurrenderReq instance using the specified properties.
         * @function create
         * @memberof Msg.PvpSurrenderReq
         * @static
         * @param {Msg.IPvpSurrenderReq=} [properties] Properties to set
         * @returns {Msg.PvpSurrenderReq} PvpSurrenderReq instance
         */
        PvpSurrenderReq.create = function create(properties) {
            return new PvpSurrenderReq(properties);
        };

        /**
         * Encodes the specified PvpSurrenderReq message. Does not implicitly {@link Msg.PvpSurrenderReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.PvpSurrenderReq
         * @static
         * @param {Msg.IPvpSurrenderReq} message PvpSurrenderReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpSurrenderReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RoomID != null && message.hasOwnProperty("RoomID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.RoomID);
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified PvpSurrenderReq message, length delimited. Does not implicitly {@link Msg.PvpSurrenderReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PvpSurrenderReq
         * @static
         * @param {Msg.IPvpSurrenderReq} message PvpSurrenderReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpSurrenderReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PvpSurrenderReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PvpSurrenderReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PvpSurrenderReq} PvpSurrenderReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpSurrenderReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PvpSurrenderReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RoomID = reader.string();
                    break;
                case 2:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PvpSurrenderReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PvpSurrenderReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PvpSurrenderReq} PvpSurrenderReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpSurrenderReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PvpSurrenderReq message.
         * @function verify
         * @memberof Msg.PvpSurrenderReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PvpSurrenderReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RoomID != null && message.hasOwnProperty("RoomID"))
                if (!$util.isString(message.RoomID))
                    return "RoomID: string expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a PvpSurrenderReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PvpSurrenderReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PvpSurrenderReq} PvpSurrenderReq
         */
        PvpSurrenderReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PvpSurrenderReq)
                return object;
            var message = new $root.Msg.PvpSurrenderReq();
            if (object.RoomID != null)
                message.RoomID = String(object.RoomID);
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a PvpSurrenderReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PvpSurrenderReq
         * @static
         * @param {Msg.PvpSurrenderReq} message PvpSurrenderReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PvpSurrenderReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.RoomID = "";
                object.playerID = "";
            }
            if (message.RoomID != null && message.hasOwnProperty("RoomID"))
                object.RoomID = message.RoomID;
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this PvpSurrenderReq to JSON.
         * @function toJSON
         * @memberof Msg.PvpSurrenderReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PvpSurrenderReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PvpSurrenderReq;
    })();

    Msg.PvpSurrenderResp = (function() {

        /**
         * Properties of a PvpSurrenderResp.
         * @memberof Msg
         * @interface IPvpSurrenderResp
         * @property {Msg.PvpSurrenderResp.Result|null} [result] PvpSurrenderResp result
         */

        /**
         * Constructs a new PvpSurrenderResp.
         * @memberof Msg
         * @classdesc Represents a PvpSurrenderResp.
         * @implements IPvpSurrenderResp
         * @constructor
         * @param {Msg.IPvpSurrenderResp=} [properties] Properties to set
         */
        function PvpSurrenderResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PvpSurrenderResp result.
         * @member {Msg.PvpSurrenderResp.Result} result
         * @memberof Msg.PvpSurrenderResp
         * @instance
         */
        PvpSurrenderResp.prototype.result = 0;

        /**
         * Creates a new PvpSurrenderResp instance using the specified properties.
         * @function create
         * @memberof Msg.PvpSurrenderResp
         * @static
         * @param {Msg.IPvpSurrenderResp=} [properties] Properties to set
         * @returns {Msg.PvpSurrenderResp} PvpSurrenderResp instance
         */
        PvpSurrenderResp.create = function create(properties) {
            return new PvpSurrenderResp(properties);
        };

        /**
         * Encodes the specified PvpSurrenderResp message. Does not implicitly {@link Msg.PvpSurrenderResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.PvpSurrenderResp
         * @static
         * @param {Msg.IPvpSurrenderResp} message PvpSurrenderResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpSurrenderResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified PvpSurrenderResp message, length delimited. Does not implicitly {@link Msg.PvpSurrenderResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PvpSurrenderResp
         * @static
         * @param {Msg.IPvpSurrenderResp} message PvpSurrenderResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpSurrenderResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PvpSurrenderResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PvpSurrenderResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PvpSurrenderResp} PvpSurrenderResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpSurrenderResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PvpSurrenderResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PvpSurrenderResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PvpSurrenderResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PvpSurrenderResp} PvpSurrenderResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpSurrenderResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PvpSurrenderResp message.
         * @function verify
         * @memberof Msg.PvpSurrenderResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PvpSurrenderResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a PvpSurrenderResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PvpSurrenderResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PvpSurrenderResp} PvpSurrenderResp
         */
        PvpSurrenderResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PvpSurrenderResp)
                return object;
            var message = new $root.Msg.PvpSurrenderResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "InvaildRoomID":
            case 2:
                message.result = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PvpSurrenderResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PvpSurrenderResp
         * @static
         * @param {Msg.PvpSurrenderResp} message PvpSurrenderResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PvpSurrenderResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "Internal" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.PvpSurrenderResp.Result[message.result] : message.result;
            return object;
        };

        /**
         * Converts this PvpSurrenderResp to JSON.
         * @function toJSON
         * @memberof Msg.PvpSurrenderResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PvpSurrenderResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.PvpSurrenderResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         * @property {number} InvaildRoomID=2 InvaildRoomID value
         */
        PvpSurrenderResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "InvaildRoomID"] = 2;
            return values;
        })();

        return PvpSurrenderResp;
    })();

    Msg.PvpOnMatched = (function() {

        /**
         * Properties of a PvpOnMatched.
         * @memberof Msg
         * @interface IPvpOnMatched
         * @property {Msg.PvpOnMatched.Result|null} [result] PvpOnMatched result
         * @property {string|null} [roomID] PvpOnMatched roomID
         * @property {Msg.IPlayerAttribute|null} [player1] PvpOnMatched player1
         * @property {Msg.IPlayerAttribute|null} [player2] PvpOnMatched player2
         * @property {Msg.IPvpBattle|null} [pvp] PvpOnMatched pvp
         */

        /**
         * Constructs a new PvpOnMatched.
         * @memberof Msg
         * @classdesc Represents a PvpOnMatched.
         * @implements IPvpOnMatched
         * @constructor
         * @param {Msg.IPvpOnMatched=} [properties] Properties to set
         */
        function PvpOnMatched(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PvpOnMatched result.
         * @member {Msg.PvpOnMatched.Result} result
         * @memberof Msg.PvpOnMatched
         * @instance
         */
        PvpOnMatched.prototype.result = 0;

        /**
         * PvpOnMatched roomID.
         * @member {string} roomID
         * @memberof Msg.PvpOnMatched
         * @instance
         */
        PvpOnMatched.prototype.roomID = "";

        /**
         * PvpOnMatched player1.
         * @member {Msg.IPlayerAttribute|null|undefined} player1
         * @memberof Msg.PvpOnMatched
         * @instance
         */
        PvpOnMatched.prototype.player1 = null;

        /**
         * PvpOnMatched player2.
         * @member {Msg.IPlayerAttribute|null|undefined} player2
         * @memberof Msg.PvpOnMatched
         * @instance
         */
        PvpOnMatched.prototype.player2 = null;

        /**
         * PvpOnMatched pvp.
         * @member {Msg.IPvpBattle|null|undefined} pvp
         * @memberof Msg.PvpOnMatched
         * @instance
         */
        PvpOnMatched.prototype.pvp = null;

        /**
         * Creates a new PvpOnMatched instance using the specified properties.
         * @function create
         * @memberof Msg.PvpOnMatched
         * @static
         * @param {Msg.IPvpOnMatched=} [properties] Properties to set
         * @returns {Msg.PvpOnMatched} PvpOnMatched instance
         */
        PvpOnMatched.create = function create(properties) {
            return new PvpOnMatched(properties);
        };

        /**
         * Encodes the specified PvpOnMatched message. Does not implicitly {@link Msg.PvpOnMatched.verify|verify} messages.
         * @function encode
         * @memberof Msg.PvpOnMatched
         * @static
         * @param {Msg.IPvpOnMatched} message PvpOnMatched message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpOnMatched.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.roomID);
            if (message.player1 != null && message.hasOwnProperty("player1"))
                $root.Msg.PlayerAttribute.encode(message.player1, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.player2 != null && message.hasOwnProperty("player2"))
                $root.Msg.PlayerAttribute.encode(message.player2, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.pvp != null && message.hasOwnProperty("pvp"))
                $root.Msg.PvpBattle.encode(message.pvp, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PvpOnMatched message, length delimited. Does not implicitly {@link Msg.PvpOnMatched.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PvpOnMatched
         * @static
         * @param {Msg.IPvpOnMatched} message PvpOnMatched message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpOnMatched.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PvpOnMatched message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PvpOnMatched
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PvpOnMatched} PvpOnMatched
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpOnMatched.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PvpOnMatched();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.roomID = reader.string();
                    break;
                case 3:
                    message.player1 = $root.Msg.PlayerAttribute.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.player2 = $root.Msg.PlayerAttribute.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.pvp = $root.Msg.PvpBattle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PvpOnMatched message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PvpOnMatched
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PvpOnMatched} PvpOnMatched
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpOnMatched.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PvpOnMatched message.
         * @function verify
         * @memberof Msg.PvpOnMatched
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PvpOnMatched.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                if (!$util.isString(message.roomID))
                    return "roomID: string expected";
            if (message.player1 != null && message.hasOwnProperty("player1")) {
                var error = $root.Msg.PlayerAttribute.verify(message.player1);
                if (error)
                    return "player1." + error;
            }
            if (message.player2 != null && message.hasOwnProperty("player2")) {
                var error = $root.Msg.PlayerAttribute.verify(message.player2);
                if (error)
                    return "player2." + error;
            }
            if (message.pvp != null && message.hasOwnProperty("pvp")) {
                var error = $root.Msg.PvpBattle.verify(message.pvp);
                if (error)
                    return "pvp." + error;
            }
            return null;
        };

        /**
         * Creates a PvpOnMatched message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PvpOnMatched
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PvpOnMatched} PvpOnMatched
         */
        PvpOnMatched.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PvpOnMatched)
                return object;
            var message = new $root.Msg.PvpOnMatched();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "CreateRoomFail":
            case 2:
                message.result = 2;
                break;
            }
            if (object.roomID != null)
                message.roomID = String(object.roomID);
            if (object.player1 != null) {
                if (typeof object.player1 !== "object")
                    throw TypeError(".Msg.PvpOnMatched.player1: object expected");
                message.player1 = $root.Msg.PlayerAttribute.fromObject(object.player1);
            }
            if (object.player2 != null) {
                if (typeof object.player2 !== "object")
                    throw TypeError(".Msg.PvpOnMatched.player2: object expected");
                message.player2 = $root.Msg.PlayerAttribute.fromObject(object.player2);
            }
            if (object.pvp != null) {
                if (typeof object.pvp !== "object")
                    throw TypeError(".Msg.PvpOnMatched.pvp: object expected");
                message.pvp = $root.Msg.PvpBattle.fromObject(object.pvp);
            }
            return message;
        };

        /**
         * Creates a plain object from a PvpOnMatched message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PvpOnMatched
         * @static
         * @param {Msg.PvpOnMatched} message PvpOnMatched
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PvpOnMatched.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "Internal" : 0;
                object.roomID = "";
                object.player1 = null;
                object.player2 = null;
                object.pvp = null;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.PvpOnMatched.Result[message.result] : message.result;
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                object.roomID = message.roomID;
            if (message.player1 != null && message.hasOwnProperty("player1"))
                object.player1 = $root.Msg.PlayerAttribute.toObject(message.player1, options);
            if (message.player2 != null && message.hasOwnProperty("player2"))
                object.player2 = $root.Msg.PlayerAttribute.toObject(message.player2, options);
            if (message.pvp != null && message.hasOwnProperty("pvp"))
                object.pvp = $root.Msg.PvpBattle.toObject(message.pvp, options);
            return object;
        };

        /**
         * Converts this PvpOnMatched to JSON.
         * @function toJSON
         * @memberof Msg.PvpOnMatched
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PvpOnMatched.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.PvpOnMatched.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         * @property {number} CreateRoomFail=2 CreateRoomFail value
         */
        PvpOnMatched.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "CreateRoomFail"] = 2;
            return values;
        })();

        return PvpOnMatched;
    })();

    Msg.PvpBattleReport = (function() {

        /**
         * Properties of a PvpBattleReport.
         * @memberof Msg
         * @interface IPvpBattleReport
         * @property {Msg.PvpBattleReport.Winner|null} [winner] PvpBattleReport winner
         * @property {Array.<number|Long>|null} [player1Cups] PvpBattleReport player1Cups
         * @property {Array.<number|Long>|null} [player2Cups] PvpBattleReport player2Cups
         * @property {Array.<number>|null} [player1RoundScore] PvpBattleReport player1RoundScore
         * @property {Array.<number>|null} [player2RoundScore] PvpBattleReport player2RoundScore
         * @property {number|null} [player1OTScore] PvpBattleReport player1OTScore
         * @property {number|null} [player2OTScore] PvpBattleReport player2OTScore
         */

        /**
         * Constructs a new PvpBattleReport.
         * @memberof Msg
         * @classdesc Represents a PvpBattleReport.
         * @implements IPvpBattleReport
         * @constructor
         * @param {Msg.IPvpBattleReport=} [properties] Properties to set
         */
        function PvpBattleReport(properties) {
            this.player1Cups = [];
            this.player2Cups = [];
            this.player1RoundScore = [];
            this.player2RoundScore = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PvpBattleReport winner.
         * @member {Msg.PvpBattleReport.Winner} winner
         * @memberof Msg.PvpBattleReport
         * @instance
         */
        PvpBattleReport.prototype.winner = 0;

        /**
         * PvpBattleReport player1Cups.
         * @member {Array.<number|Long>} player1Cups
         * @memberof Msg.PvpBattleReport
         * @instance
         */
        PvpBattleReport.prototype.player1Cups = $util.emptyArray;

        /**
         * PvpBattleReport player2Cups.
         * @member {Array.<number|Long>} player2Cups
         * @memberof Msg.PvpBattleReport
         * @instance
         */
        PvpBattleReport.prototype.player2Cups = $util.emptyArray;

        /**
         * PvpBattleReport player1RoundScore.
         * @member {Array.<number>} player1RoundScore
         * @memberof Msg.PvpBattleReport
         * @instance
         */
        PvpBattleReport.prototype.player1RoundScore = $util.emptyArray;

        /**
         * PvpBattleReport player2RoundScore.
         * @member {Array.<number>} player2RoundScore
         * @memberof Msg.PvpBattleReport
         * @instance
         */
        PvpBattleReport.prototype.player2RoundScore = $util.emptyArray;

        /**
         * PvpBattleReport player1OTScore.
         * @member {number} player1OTScore
         * @memberof Msg.PvpBattleReport
         * @instance
         */
        PvpBattleReport.prototype.player1OTScore = 0;

        /**
         * PvpBattleReport player2OTScore.
         * @member {number} player2OTScore
         * @memberof Msg.PvpBattleReport
         * @instance
         */
        PvpBattleReport.prototype.player2OTScore = 0;

        /**
         * Creates a new PvpBattleReport instance using the specified properties.
         * @function create
         * @memberof Msg.PvpBattleReport
         * @static
         * @param {Msg.IPvpBattleReport=} [properties] Properties to set
         * @returns {Msg.PvpBattleReport} PvpBattleReport instance
         */
        PvpBattleReport.create = function create(properties) {
            return new PvpBattleReport(properties);
        };

        /**
         * Encodes the specified PvpBattleReport message. Does not implicitly {@link Msg.PvpBattleReport.verify|verify} messages.
         * @function encode
         * @memberof Msg.PvpBattleReport
         * @static
         * @param {Msg.IPvpBattleReport} message PvpBattleReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpBattleReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.winner != null && message.hasOwnProperty("winner"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.winner);
            if (message.player1Cups != null && message.player1Cups.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.player1Cups.length; ++i)
                    writer.int64(message.player1Cups[i]);
                writer.ldelim();
            }
            if (message.player2Cups != null && message.player2Cups.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.player2Cups.length; ++i)
                    writer.int64(message.player2Cups[i]);
                writer.ldelim();
            }
            if (message.player1RoundScore != null && message.player1RoundScore.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.player1RoundScore.length; ++i)
                    writer.float(message.player1RoundScore[i]);
                writer.ldelim();
            }
            if (message.player2RoundScore != null && message.player2RoundScore.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (var i = 0; i < message.player2RoundScore.length; ++i)
                    writer.float(message.player2RoundScore[i]);
                writer.ldelim();
            }
            if (message.player1OTScore != null && message.hasOwnProperty("player1OTScore"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.player1OTScore);
            if (message.player2OTScore != null && message.hasOwnProperty("player2OTScore"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.player2OTScore);
            return writer;
        };

        /**
         * Encodes the specified PvpBattleReport message, length delimited. Does not implicitly {@link Msg.PvpBattleReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PvpBattleReport
         * @static
         * @param {Msg.IPvpBattleReport} message PvpBattleReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpBattleReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PvpBattleReport message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PvpBattleReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PvpBattleReport} PvpBattleReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpBattleReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PvpBattleReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.winner = reader.int32();
                    break;
                case 2:
                    if (!(message.player1Cups && message.player1Cups.length))
                        message.player1Cups = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.player1Cups.push(reader.int64());
                    } else
                        message.player1Cups.push(reader.int64());
                    break;
                case 3:
                    if (!(message.player2Cups && message.player2Cups.length))
                        message.player2Cups = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.player2Cups.push(reader.int64());
                    } else
                        message.player2Cups.push(reader.int64());
                    break;
                case 4:
                    if (!(message.player1RoundScore && message.player1RoundScore.length))
                        message.player1RoundScore = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.player1RoundScore.push(reader.float());
                    } else
                        message.player1RoundScore.push(reader.float());
                    break;
                case 5:
                    if (!(message.player2RoundScore && message.player2RoundScore.length))
                        message.player2RoundScore = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.player2RoundScore.push(reader.float());
                    } else
                        message.player2RoundScore.push(reader.float());
                    break;
                case 6:
                    message.player1OTScore = reader.float();
                    break;
                case 7:
                    message.player2OTScore = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PvpBattleReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PvpBattleReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PvpBattleReport} PvpBattleReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpBattleReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PvpBattleReport message.
         * @function verify
         * @memberof Msg.PvpBattleReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PvpBattleReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.winner != null && message.hasOwnProperty("winner"))
                switch (message.winner) {
                default:
                    return "winner: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.player1Cups != null && message.hasOwnProperty("player1Cups")) {
                if (!Array.isArray(message.player1Cups))
                    return "player1Cups: array expected";
                for (var i = 0; i < message.player1Cups.length; ++i)
                    if (!$util.isInteger(message.player1Cups[i]) && !(message.player1Cups[i] && $util.isInteger(message.player1Cups[i].low) && $util.isInteger(message.player1Cups[i].high)))
                        return "player1Cups: integer|Long[] expected";
            }
            if (message.player2Cups != null && message.hasOwnProperty("player2Cups")) {
                if (!Array.isArray(message.player2Cups))
                    return "player2Cups: array expected";
                for (var i = 0; i < message.player2Cups.length; ++i)
                    if (!$util.isInteger(message.player2Cups[i]) && !(message.player2Cups[i] && $util.isInteger(message.player2Cups[i].low) && $util.isInteger(message.player2Cups[i].high)))
                        return "player2Cups: integer|Long[] expected";
            }
            if (message.player1RoundScore != null && message.hasOwnProperty("player1RoundScore")) {
                if (!Array.isArray(message.player1RoundScore))
                    return "player1RoundScore: array expected";
                for (var i = 0; i < message.player1RoundScore.length; ++i)
                    if (typeof message.player1RoundScore[i] !== "number")
                        return "player1RoundScore: number[] expected";
            }
            if (message.player2RoundScore != null && message.hasOwnProperty("player2RoundScore")) {
                if (!Array.isArray(message.player2RoundScore))
                    return "player2RoundScore: array expected";
                for (var i = 0; i < message.player2RoundScore.length; ++i)
                    if (typeof message.player2RoundScore[i] !== "number")
                        return "player2RoundScore: number[] expected";
            }
            if (message.player1OTScore != null && message.hasOwnProperty("player1OTScore"))
                if (typeof message.player1OTScore !== "number")
                    return "player1OTScore: number expected";
            if (message.player2OTScore != null && message.hasOwnProperty("player2OTScore"))
                if (typeof message.player2OTScore !== "number")
                    return "player2OTScore: number expected";
            return null;
        };

        /**
         * Creates a PvpBattleReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PvpBattleReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PvpBattleReport} PvpBattleReport
         */
        PvpBattleReport.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PvpBattleReport)
                return object;
            var message = new $root.Msg.PvpBattleReport();
            switch (object.winner) {
            case "onMatch":
            case 0:
                message.winner = 0;
                break;
            case "player1":
            case 1:
                message.winner = 1;
                break;
            case "player2":
            case 2:
                message.winner = 2;
                break;
            case "ot":
            case 3:
                message.winner = 3;
                break;
            }
            if (object.player1Cups) {
                if (!Array.isArray(object.player1Cups))
                    throw TypeError(".Msg.PvpBattleReport.player1Cups: array expected");
                message.player1Cups = [];
                for (var i = 0; i < object.player1Cups.length; ++i)
                    if ($util.Long)
                        (message.player1Cups[i] = $util.Long.fromValue(object.player1Cups[i])).unsigned = false;
                    else if (typeof object.player1Cups[i] === "string")
                        message.player1Cups[i] = parseInt(object.player1Cups[i], 10);
                    else if (typeof object.player1Cups[i] === "number")
                        message.player1Cups[i] = object.player1Cups[i];
                    else if (typeof object.player1Cups[i] === "object")
                        message.player1Cups[i] = new $util.LongBits(object.player1Cups[i].low >>> 0, object.player1Cups[i].high >>> 0).toNumber();
            }
            if (object.player2Cups) {
                if (!Array.isArray(object.player2Cups))
                    throw TypeError(".Msg.PvpBattleReport.player2Cups: array expected");
                message.player2Cups = [];
                for (var i = 0; i < object.player2Cups.length; ++i)
                    if ($util.Long)
                        (message.player2Cups[i] = $util.Long.fromValue(object.player2Cups[i])).unsigned = false;
                    else if (typeof object.player2Cups[i] === "string")
                        message.player2Cups[i] = parseInt(object.player2Cups[i], 10);
                    else if (typeof object.player2Cups[i] === "number")
                        message.player2Cups[i] = object.player2Cups[i];
                    else if (typeof object.player2Cups[i] === "object")
                        message.player2Cups[i] = new $util.LongBits(object.player2Cups[i].low >>> 0, object.player2Cups[i].high >>> 0).toNumber();
            }
            if (object.player1RoundScore) {
                if (!Array.isArray(object.player1RoundScore))
                    throw TypeError(".Msg.PvpBattleReport.player1RoundScore: array expected");
                message.player1RoundScore = [];
                for (var i = 0; i < object.player1RoundScore.length; ++i)
                    message.player1RoundScore[i] = Number(object.player1RoundScore[i]);
            }
            if (object.player2RoundScore) {
                if (!Array.isArray(object.player2RoundScore))
                    throw TypeError(".Msg.PvpBattleReport.player2RoundScore: array expected");
                message.player2RoundScore = [];
                for (var i = 0; i < object.player2RoundScore.length; ++i)
                    message.player2RoundScore[i] = Number(object.player2RoundScore[i]);
            }
            if (object.player1OTScore != null)
                message.player1OTScore = Number(object.player1OTScore);
            if (object.player2OTScore != null)
                message.player2OTScore = Number(object.player2OTScore);
            return message;
        };

        /**
         * Creates a plain object from a PvpBattleReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PvpBattleReport
         * @static
         * @param {Msg.PvpBattleReport} message PvpBattleReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PvpBattleReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.player1Cups = [];
                object.player2Cups = [];
                object.player1RoundScore = [];
                object.player2RoundScore = [];
            }
            if (options.defaults) {
                object.winner = options.enums === String ? "onMatch" : 0;
                object.player1OTScore = 0;
                object.player2OTScore = 0;
            }
            if (message.winner != null && message.hasOwnProperty("winner"))
                object.winner = options.enums === String ? $root.Msg.PvpBattleReport.Winner[message.winner] : message.winner;
            if (message.player1Cups && message.player1Cups.length) {
                object.player1Cups = [];
                for (var j = 0; j < message.player1Cups.length; ++j)
                    if (typeof message.player1Cups[j] === "number")
                        object.player1Cups[j] = options.longs === String ? String(message.player1Cups[j]) : message.player1Cups[j];
                    else
                        object.player1Cups[j] = options.longs === String ? $util.Long.prototype.toString.call(message.player1Cups[j]) : options.longs === Number ? new $util.LongBits(message.player1Cups[j].low >>> 0, message.player1Cups[j].high >>> 0).toNumber() : message.player1Cups[j];
            }
            if (message.player2Cups && message.player2Cups.length) {
                object.player2Cups = [];
                for (var j = 0; j < message.player2Cups.length; ++j)
                    if (typeof message.player2Cups[j] === "number")
                        object.player2Cups[j] = options.longs === String ? String(message.player2Cups[j]) : message.player2Cups[j];
                    else
                        object.player2Cups[j] = options.longs === String ? $util.Long.prototype.toString.call(message.player2Cups[j]) : options.longs === Number ? new $util.LongBits(message.player2Cups[j].low >>> 0, message.player2Cups[j].high >>> 0).toNumber() : message.player2Cups[j];
            }
            if (message.player1RoundScore && message.player1RoundScore.length) {
                object.player1RoundScore = [];
                for (var j = 0; j < message.player1RoundScore.length; ++j)
                    object.player1RoundScore[j] = options.json && !isFinite(message.player1RoundScore[j]) ? String(message.player1RoundScore[j]) : message.player1RoundScore[j];
            }
            if (message.player2RoundScore && message.player2RoundScore.length) {
                object.player2RoundScore = [];
                for (var j = 0; j < message.player2RoundScore.length; ++j)
                    object.player2RoundScore[j] = options.json && !isFinite(message.player2RoundScore[j]) ? String(message.player2RoundScore[j]) : message.player2RoundScore[j];
            }
            if (message.player1OTScore != null && message.hasOwnProperty("player1OTScore"))
                object.player1OTScore = options.json && !isFinite(message.player1OTScore) ? String(message.player1OTScore) : message.player1OTScore;
            if (message.player2OTScore != null && message.hasOwnProperty("player2OTScore"))
                object.player2OTScore = options.json && !isFinite(message.player2OTScore) ? String(message.player2OTScore) : message.player2OTScore;
            return object;
        };

        /**
         * Converts this PvpBattleReport to JSON.
         * @function toJSON
         * @memberof Msg.PvpBattleReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PvpBattleReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Winner enum.
         * @name Msg.PvpBattleReport.Winner
         * @enum {string}
         * @property {number} onMatch=0 onMatch value
         * @property {number} player1=1 player1 value
         * @property {number} player2=2 player2 value
         * @property {number} ot=3 ot value
         */
        PvpBattleReport.Winner = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "onMatch"] = 0;
            values[valuesById[1] = "player1"] = 1;
            values[valuesById[2] = "player2"] = 2;
            values[valuesById[3] = "ot"] = 3;
            return values;
        })();

        return PvpBattleReport;
    })();

    Msg.PvpBattleStatus = (function() {

        /**
         * Properties of a PvpBattleStatus.
         * @memberof Msg
         * @interface IPvpBattleStatus
         * @property {number|Long|null} [index] PvpBattleStatus index
         * @property {Msg.PvpBattleStatus.Result|null} [result] PvpBattleStatus result
         * @property {Msg.PvpBattleStatus.Type|null} [battleStatusType] PvpBattleStatus battleStatusType
         * @property {Msg.ShootTurn|null} [turn] PvpBattleStatus turn
         * @property {Array.<Msg.IShoot>|null} [shoots] PvpBattleStatus shoots
         * @property {Msg.IPvpBattleReport|null} [report] PvpBattleStatus report
         */

        /**
         * Constructs a new PvpBattleStatus.
         * @memberof Msg
         * @classdesc Represents a PvpBattleStatus.
         * @implements IPvpBattleStatus
         * @constructor
         * @param {Msg.IPvpBattleStatus=} [properties] Properties to set
         */
        function PvpBattleStatus(properties) {
            this.shoots = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PvpBattleStatus index.
         * @member {number|Long} index
         * @memberof Msg.PvpBattleStatus
         * @instance
         */
        PvpBattleStatus.prototype.index = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PvpBattleStatus result.
         * @member {Msg.PvpBattleStatus.Result} result
         * @memberof Msg.PvpBattleStatus
         * @instance
         */
        PvpBattleStatus.prototype.result = 0;

        /**
         * PvpBattleStatus battleStatusType.
         * @member {Msg.PvpBattleStatus.Type} battleStatusType
         * @memberof Msg.PvpBattleStatus
         * @instance
         */
        PvpBattleStatus.prototype.battleStatusType = 0;

        /**
         * PvpBattleStatus turn.
         * @member {Msg.ShootTurn} turn
         * @memberof Msg.PvpBattleStatus
         * @instance
         */
        PvpBattleStatus.prototype.turn = 0;

        /**
         * PvpBattleStatus shoots.
         * @member {Array.<Msg.IShoot>} shoots
         * @memberof Msg.PvpBattleStatus
         * @instance
         */
        PvpBattleStatus.prototype.shoots = $util.emptyArray;

        /**
         * PvpBattleStatus report.
         * @member {Msg.IPvpBattleReport|null|undefined} report
         * @memberof Msg.PvpBattleStatus
         * @instance
         */
        PvpBattleStatus.prototype.report = null;

        /**
         * Creates a new PvpBattleStatus instance using the specified properties.
         * @function create
         * @memberof Msg.PvpBattleStatus
         * @static
         * @param {Msg.IPvpBattleStatus=} [properties] Properties to set
         * @returns {Msg.PvpBattleStatus} PvpBattleStatus instance
         */
        PvpBattleStatus.create = function create(properties) {
            return new PvpBattleStatus(properties);
        };

        /**
         * Encodes the specified PvpBattleStatus message. Does not implicitly {@link Msg.PvpBattleStatus.verify|verify} messages.
         * @function encode
         * @memberof Msg.PvpBattleStatus
         * @static
         * @param {Msg.IPvpBattleStatus} message PvpBattleStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpBattleStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.index);
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.result);
            if (message.battleStatusType != null && message.hasOwnProperty("battleStatusType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.battleStatusType);
            if (message.turn != null && message.hasOwnProperty("turn"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.turn);
            if (message.shoots != null && message.shoots.length)
                for (var i = 0; i < message.shoots.length; ++i)
                    $root.Msg.Shoot.encode(message.shoots[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.report != null && message.hasOwnProperty("report"))
                $root.Msg.PvpBattleReport.encode(message.report, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PvpBattleStatus message, length delimited. Does not implicitly {@link Msg.PvpBattleStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PvpBattleStatus
         * @static
         * @param {Msg.IPvpBattleStatus} message PvpBattleStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PvpBattleStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PvpBattleStatus message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PvpBattleStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PvpBattleStatus} PvpBattleStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpBattleStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PvpBattleStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int64();
                    break;
                case 2:
                    message.result = reader.int32();
                    break;
                case 3:
                    message.battleStatusType = reader.int32();
                    break;
                case 4:
                    message.turn = reader.int32();
                    break;
                case 5:
                    if (!(message.shoots && message.shoots.length))
                        message.shoots = [];
                    message.shoots.push($root.Msg.Shoot.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.report = $root.Msg.PvpBattleReport.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PvpBattleStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PvpBattleStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PvpBattleStatus} PvpBattleStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PvpBattleStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PvpBattleStatus message.
         * @function verify
         * @memberof Msg.PvpBattleStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PvpBattleStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                    return "index: integer|Long expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.battleStatusType != null && message.hasOwnProperty("battleStatusType"))
                switch (message.battleStatusType) {
                default:
                    return "battleStatusType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.turn != null && message.hasOwnProperty("turn"))
                switch (message.turn) {
                default:
                    return "turn: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.shoots != null && message.hasOwnProperty("shoots")) {
                if (!Array.isArray(message.shoots))
                    return "shoots: array expected";
                for (var i = 0; i < message.shoots.length; ++i) {
                    var error = $root.Msg.Shoot.verify(message.shoots[i]);
                    if (error)
                        return "shoots." + error;
                }
            }
            if (message.report != null && message.hasOwnProperty("report")) {
                var error = $root.Msg.PvpBattleReport.verify(message.report);
                if (error)
                    return "report." + error;
            }
            return null;
        };

        /**
         * Creates a PvpBattleStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PvpBattleStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PvpBattleStatus} PvpBattleStatus
         */
        PvpBattleStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PvpBattleStatus)
                return object;
            var message = new $root.Msg.PvpBattleStatus();
            if (object.index != null)
                if ($util.Long)
                    (message.index = $util.Long.fromValue(object.index)).unsigned = false;
                else if (typeof object.index === "string")
                    message.index = parseInt(object.index, 10);
                else if (typeof object.index === "number")
                    message.index = object.index;
                else if (typeof object.index === "object")
                    message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber();
            switch (object.result) {
            case "ok":
            case 0:
                message.result = 0;
                break;
            case "internal":
            case 1:
                message.result = 1;
                break;
            }
            switch (object.battleStatusType) {
            case "shoot":
            case 0:
                message.battleStatusType = 0;
                break;
            case "turnChange":
            case 1:
                message.battleStatusType = 1;
                break;
            case "roundOver":
            case 2:
                message.battleStatusType = 2;
                break;
            case "ot":
            case 3:
                message.battleStatusType = 3;
                break;
            case "oppOffLine":
            case 4:
                message.battleStatusType = 4;
                break;
            case "gameOver":
            case 5:
                message.battleStatusType = 5;
                break;
            case "surrender":
            case 6:
                message.battleStatusType = 6;
                break;
            case "stopGame":
            case 7:
                message.battleStatusType = 7;
                break;
            case "startGame":
            case 8:
                message.battleStatusType = 8;
                break;
            }
            switch (object.turn) {
            case "both":
            case 0:
                message.turn = 0;
                break;
            case "player1":
            case 1:
                message.turn = 1;
                break;
            case "player2":
            case 2:
                message.turn = 2;
                break;
            case "neither":
            case 3:
                message.turn = 3;
                break;
            }
            if (object.shoots) {
                if (!Array.isArray(object.shoots))
                    throw TypeError(".Msg.PvpBattleStatus.shoots: array expected");
                message.shoots = [];
                for (var i = 0; i < object.shoots.length; ++i) {
                    if (typeof object.shoots[i] !== "object")
                        throw TypeError(".Msg.PvpBattleStatus.shoots: object expected");
                    message.shoots[i] = $root.Msg.Shoot.fromObject(object.shoots[i]);
                }
            }
            if (object.report != null) {
                if (typeof object.report !== "object")
                    throw TypeError(".Msg.PvpBattleStatus.report: object expected");
                message.report = $root.Msg.PvpBattleReport.fromObject(object.report);
            }
            return message;
        };

        /**
         * Creates a plain object from a PvpBattleStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PvpBattleStatus
         * @static
         * @param {Msg.PvpBattleStatus} message PvpBattleStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PvpBattleStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.shoots = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.index = options.longs === String ? "0" : 0;
                object.result = options.enums === String ? "ok" : 0;
                object.battleStatusType = options.enums === String ? "shoot" : 0;
                object.turn = options.enums === String ? "both" : 0;
                object.report = null;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                if (typeof message.index === "number")
                    object.index = options.longs === String ? String(message.index) : message.index;
                else
                    object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber() : message.index;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.PvpBattleStatus.Result[message.result] : message.result;
            if (message.battleStatusType != null && message.hasOwnProperty("battleStatusType"))
                object.battleStatusType = options.enums === String ? $root.Msg.PvpBattleStatus.Type[message.battleStatusType] : message.battleStatusType;
            if (message.turn != null && message.hasOwnProperty("turn"))
                object.turn = options.enums === String ? $root.Msg.ShootTurn[message.turn] : message.turn;
            if (message.shoots && message.shoots.length) {
                object.shoots = [];
                for (var j = 0; j < message.shoots.length; ++j)
                    object.shoots[j] = $root.Msg.Shoot.toObject(message.shoots[j], options);
            }
            if (message.report != null && message.hasOwnProperty("report"))
                object.report = $root.Msg.PvpBattleReport.toObject(message.report, options);
            return object;
        };

        /**
         * Converts this PvpBattleStatus to JSON.
         * @function toJSON
         * @memberof Msg.PvpBattleStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PvpBattleStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.PvpBattleStatus.Result
         * @enum {string}
         * @property {number} ok=0 ok value
         * @property {number} internal=1 internal value
         */
        PvpBattleStatus.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ok"] = 0;
            values[valuesById[1] = "internal"] = 1;
            return values;
        })();

        /**
         * Type enum.
         * @name Msg.PvpBattleStatus.Type
         * @enum {string}
         * @property {number} shoot=0 shoot value
         * @property {number} turnChange=1 turnChange value
         * @property {number} roundOver=2 roundOver value
         * @property {number} ot=3 ot value
         * @property {number} oppOffLine=4 oppOffLine value
         * @property {number} gameOver=5 gameOver value
         * @property {number} surrender=6 surrender value
         * @property {number} stopGame=7 stopGame value
         * @property {number} startGame=8 startGame value
         */
        PvpBattleStatus.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "shoot"] = 0;
            values[valuesById[1] = "turnChange"] = 1;
            values[valuesById[2] = "roundOver"] = 2;
            values[valuesById[3] = "ot"] = 3;
            values[valuesById[4] = "oppOffLine"] = 4;
            values[valuesById[5] = "gameOver"] = 5;
            values[valuesById[6] = "surrender"] = 6;
            values[valuesById[7] = "stopGame"] = 7;
            values[valuesById[8] = "startGame"] = 8;
            return values;
        })();

        return PvpBattleStatus;
    })();

    Msg.BattleStatusACK = (function() {

        /**
         * Properties of a BattleStatusACK.
         * @memberof Msg
         * @interface IBattleStatusACK
         * @property {string|null} [playerID] BattleStatusACK playerID
         * @property {string|null} [roomID] BattleStatusACK roomID
         * @property {number|Long|null} [recIndex] BattleStatusACK recIndex
         */

        /**
         * Constructs a new BattleStatusACK.
         * @memberof Msg
         * @classdesc Represents a BattleStatusACK.
         * @implements IBattleStatusACK
         * @constructor
         * @param {Msg.IBattleStatusACK=} [properties] Properties to set
         */
        function BattleStatusACK(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleStatusACK playerID.
         * @member {string} playerID
         * @memberof Msg.BattleStatusACK
         * @instance
         */
        BattleStatusACK.prototype.playerID = "";

        /**
         * BattleStatusACK roomID.
         * @member {string} roomID
         * @memberof Msg.BattleStatusACK
         * @instance
         */
        BattleStatusACK.prototype.roomID = "";

        /**
         * BattleStatusACK recIndex.
         * @member {number|Long} recIndex
         * @memberof Msg.BattleStatusACK
         * @instance
         */
        BattleStatusACK.prototype.recIndex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BattleStatusACK instance using the specified properties.
         * @function create
         * @memberof Msg.BattleStatusACK
         * @static
         * @param {Msg.IBattleStatusACK=} [properties] Properties to set
         * @returns {Msg.BattleStatusACK} BattleStatusACK instance
         */
        BattleStatusACK.create = function create(properties) {
            return new BattleStatusACK(properties);
        };

        /**
         * Encodes the specified BattleStatusACK message. Does not implicitly {@link Msg.BattleStatusACK.verify|verify} messages.
         * @function encode
         * @memberof Msg.BattleStatusACK
         * @static
         * @param {Msg.IBattleStatusACK} message BattleStatusACK message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleStatusACK.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.roomID);
            if (message.recIndex != null && message.hasOwnProperty("recIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.recIndex);
            return writer;
        };

        /**
         * Encodes the specified BattleStatusACK message, length delimited. Does not implicitly {@link Msg.BattleStatusACK.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.BattleStatusACK
         * @static
         * @param {Msg.IBattleStatusACK} message BattleStatusACK message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleStatusACK.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleStatusACK message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.BattleStatusACK
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.BattleStatusACK} BattleStatusACK
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleStatusACK.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.BattleStatusACK();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                case 2:
                    message.roomID = reader.string();
                    break;
                case 3:
                    message.recIndex = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleStatusACK message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.BattleStatusACK
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.BattleStatusACK} BattleStatusACK
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleStatusACK.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleStatusACK message.
         * @function verify
         * @memberof Msg.BattleStatusACK
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleStatusACK.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                if (!$util.isString(message.roomID))
                    return "roomID: string expected";
            if (message.recIndex != null && message.hasOwnProperty("recIndex"))
                if (!$util.isInteger(message.recIndex) && !(message.recIndex && $util.isInteger(message.recIndex.low) && $util.isInteger(message.recIndex.high)))
                    return "recIndex: integer|Long expected";
            return null;
        };

        /**
         * Creates a BattleStatusACK message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.BattleStatusACK
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.BattleStatusACK} BattleStatusACK
         */
        BattleStatusACK.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.BattleStatusACK)
                return object;
            var message = new $root.Msg.BattleStatusACK();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            if (object.roomID != null)
                message.roomID = String(object.roomID);
            if (object.recIndex != null)
                if ($util.Long)
                    (message.recIndex = $util.Long.fromValue(object.recIndex)).unsigned = false;
                else if (typeof object.recIndex === "string")
                    message.recIndex = parseInt(object.recIndex, 10);
                else if (typeof object.recIndex === "number")
                    message.recIndex = object.recIndex;
                else if (typeof object.recIndex === "object")
                    message.recIndex = new $util.LongBits(object.recIndex.low >>> 0, object.recIndex.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BattleStatusACK message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.BattleStatusACK
         * @static
         * @param {Msg.BattleStatusACK} message BattleStatusACK
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BattleStatusACK.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerID = "";
                object.roomID = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.recIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.recIndex = options.longs === String ? "0" : 0;
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                object.roomID = message.roomID;
            if (message.recIndex != null && message.hasOwnProperty("recIndex"))
                if (typeof message.recIndex === "number")
                    object.recIndex = options.longs === String ? String(message.recIndex) : message.recIndex;
                else
                    object.recIndex = options.longs === String ? $util.Long.prototype.toString.call(message.recIndex) : options.longs === Number ? new $util.LongBits(message.recIndex.low >>> 0, message.recIndex.high >>> 0).toNumber() : message.recIndex;
            return object;
        };

        /**
         * Converts this BattleStatusACK to JSON.
         * @function toJSON
         * @memberof Msg.BattleStatusACK
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BattleStatusACK.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BattleStatusACK;
    })();

    Msg.BattleStatusACKResp = (function() {

        /**
         * Properties of a BattleStatusACKResp.
         * @memberof Msg
         * @interface IBattleStatusACKResp
         */

        /**
         * Constructs a new BattleStatusACKResp.
         * @memberof Msg
         * @classdesc Represents a BattleStatusACKResp.
         * @implements IBattleStatusACKResp
         * @constructor
         * @param {Msg.IBattleStatusACKResp=} [properties] Properties to set
         */
        function BattleStatusACKResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new BattleStatusACKResp instance using the specified properties.
         * @function create
         * @memberof Msg.BattleStatusACKResp
         * @static
         * @param {Msg.IBattleStatusACKResp=} [properties] Properties to set
         * @returns {Msg.BattleStatusACKResp} BattleStatusACKResp instance
         */
        BattleStatusACKResp.create = function create(properties) {
            return new BattleStatusACKResp(properties);
        };

        /**
         * Encodes the specified BattleStatusACKResp message. Does not implicitly {@link Msg.BattleStatusACKResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.BattleStatusACKResp
         * @static
         * @param {Msg.IBattleStatusACKResp} message BattleStatusACKResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleStatusACKResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified BattleStatusACKResp message, length delimited. Does not implicitly {@link Msg.BattleStatusACKResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.BattleStatusACKResp
         * @static
         * @param {Msg.IBattleStatusACKResp} message BattleStatusACKResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleStatusACKResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleStatusACKResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.BattleStatusACKResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.BattleStatusACKResp} BattleStatusACKResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleStatusACKResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.BattleStatusACKResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleStatusACKResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.BattleStatusACKResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.BattleStatusACKResp} BattleStatusACKResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleStatusACKResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleStatusACKResp message.
         * @function verify
         * @memberof Msg.BattleStatusACKResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleStatusACKResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a BattleStatusACKResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.BattleStatusACKResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.BattleStatusACKResp} BattleStatusACKResp
         */
        BattleStatusACKResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.BattleStatusACKResp)
                return object;
            return new $root.Msg.BattleStatusACKResp();
        };

        /**
         * Creates a plain object from a BattleStatusACKResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.BattleStatusACKResp
         * @static
         * @param {Msg.BattleStatusACKResp} message BattleStatusACKResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BattleStatusACKResp.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this BattleStatusACKResp to JSON.
         * @function toJSON
         * @memberof Msg.BattleStatusACKResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BattleStatusACKResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BattleStatusACKResp;
    })();

    Msg.QuitRoomReq = (function() {

        /**
         * Properties of a QuitRoomReq.
         * @memberof Msg
         * @interface IQuitRoomReq
         * @property {string|null} [playerID] QuitRoomReq playerID
         * @property {string|null} [roomID] QuitRoomReq roomID
         */

        /**
         * Constructs a new QuitRoomReq.
         * @memberof Msg
         * @classdesc Represents a QuitRoomReq.
         * @implements IQuitRoomReq
         * @constructor
         * @param {Msg.IQuitRoomReq=} [properties] Properties to set
         */
        function QuitRoomReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QuitRoomReq playerID.
         * @member {string} playerID
         * @memberof Msg.QuitRoomReq
         * @instance
         */
        QuitRoomReq.prototype.playerID = "";

        /**
         * QuitRoomReq roomID.
         * @member {string} roomID
         * @memberof Msg.QuitRoomReq
         * @instance
         */
        QuitRoomReq.prototype.roomID = "";

        /**
         * Creates a new QuitRoomReq instance using the specified properties.
         * @function create
         * @memberof Msg.QuitRoomReq
         * @static
         * @param {Msg.IQuitRoomReq=} [properties] Properties to set
         * @returns {Msg.QuitRoomReq} QuitRoomReq instance
         */
        QuitRoomReq.create = function create(properties) {
            return new QuitRoomReq(properties);
        };

        /**
         * Encodes the specified QuitRoomReq message. Does not implicitly {@link Msg.QuitRoomReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.QuitRoomReq
         * @static
         * @param {Msg.IQuitRoomReq} message QuitRoomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QuitRoomReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.roomID);
            return writer;
        };

        /**
         * Encodes the specified QuitRoomReq message, length delimited. Does not implicitly {@link Msg.QuitRoomReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.QuitRoomReq
         * @static
         * @param {Msg.IQuitRoomReq} message QuitRoomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QuitRoomReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QuitRoomReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.QuitRoomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.QuitRoomReq} QuitRoomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QuitRoomReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.QuitRoomReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                case 2:
                    message.roomID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QuitRoomReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.QuitRoomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.QuitRoomReq} QuitRoomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QuitRoomReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QuitRoomReq message.
         * @function verify
         * @memberof Msg.QuitRoomReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QuitRoomReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                if (!$util.isString(message.roomID))
                    return "roomID: string expected";
            return null;
        };

        /**
         * Creates a QuitRoomReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.QuitRoomReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.QuitRoomReq} QuitRoomReq
         */
        QuitRoomReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.QuitRoomReq)
                return object;
            var message = new $root.Msg.QuitRoomReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            if (object.roomID != null)
                message.roomID = String(object.roomID);
            return message;
        };

        /**
         * Creates a plain object from a QuitRoomReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.QuitRoomReq
         * @static
         * @param {Msg.QuitRoomReq} message QuitRoomReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QuitRoomReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerID = "";
                object.roomID = "";
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                object.roomID = message.roomID;
            return object;
        };

        /**
         * Converts this QuitRoomReq to JSON.
         * @function toJSON
         * @memberof Msg.QuitRoomReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QuitRoomReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QuitRoomReq;
    })();

    Msg.QuitRoomResp = (function() {

        /**
         * Properties of a QuitRoomResp.
         * @memberof Msg
         * @interface IQuitRoomResp
         * @property {Msg.QuitRoomResp.Result|null} [result] QuitRoomResp result
         */

        /**
         * Constructs a new QuitRoomResp.
         * @memberof Msg
         * @classdesc Represents a QuitRoomResp.
         * @implements IQuitRoomResp
         * @constructor
         * @param {Msg.IQuitRoomResp=} [properties] Properties to set
         */
        function QuitRoomResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QuitRoomResp result.
         * @member {Msg.QuitRoomResp.Result} result
         * @memberof Msg.QuitRoomResp
         * @instance
         */
        QuitRoomResp.prototype.result = 0;

        /**
         * Creates a new QuitRoomResp instance using the specified properties.
         * @function create
         * @memberof Msg.QuitRoomResp
         * @static
         * @param {Msg.IQuitRoomResp=} [properties] Properties to set
         * @returns {Msg.QuitRoomResp} QuitRoomResp instance
         */
        QuitRoomResp.create = function create(properties) {
            return new QuitRoomResp(properties);
        };

        /**
         * Encodes the specified QuitRoomResp message. Does not implicitly {@link Msg.QuitRoomResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.QuitRoomResp
         * @static
         * @param {Msg.IQuitRoomResp} message QuitRoomResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QuitRoomResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified QuitRoomResp message, length delimited. Does not implicitly {@link Msg.QuitRoomResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.QuitRoomResp
         * @static
         * @param {Msg.IQuitRoomResp} message QuitRoomResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QuitRoomResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QuitRoomResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.QuitRoomResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.QuitRoomResp} QuitRoomResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QuitRoomResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.QuitRoomResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QuitRoomResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.QuitRoomResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.QuitRoomResp} QuitRoomResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QuitRoomResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QuitRoomResp message.
         * @function verify
         * @memberof Msg.QuitRoomResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QuitRoomResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a QuitRoomResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.QuitRoomResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.QuitRoomResp} QuitRoomResp
         */
        QuitRoomResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.QuitRoomResp)
                return object;
            var message = new $root.Msg.QuitRoomResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "InvalidRoomID":
            case 2:
                message.result = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a QuitRoomResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.QuitRoomResp
         * @static
         * @param {Msg.QuitRoomResp} message QuitRoomResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QuitRoomResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "Internal" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.QuitRoomResp.Result[message.result] : message.result;
            return object;
        };

        /**
         * Converts this QuitRoomResp to JSON.
         * @function toJSON
         * @memberof Msg.QuitRoomResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QuitRoomResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.QuitRoomResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         * @property {number} InvalidRoomID=2 InvalidRoomID value
         */
        QuitRoomResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "InvalidRoomID"] = 2;
            return values;
        })();

        return QuitRoomResp;
    })();

    Msg.PlayerInfo = (function() {

        /**
         * Properties of a PlayerInfo.
         * @memberof Msg
         * @interface IPlayerInfo
         * @property {string|null} [id] PlayerInfo id
         * @property {string|null} [nickname] PlayerInfo nickname
         * @property {string|null} [url] PlayerInfo url
         * @property {number|Long|null} [level] PlayerInfo level
         * @property {number|Long|null} [cup] PlayerInfo cup
         * @property {number|Long|null} [score] PlayerInfo score
         * @property {Msg.PlayerInfo.Seat|null} [seat] PlayerInfo seat
         */

        /**
         * Constructs a new PlayerInfo.
         * @memberof Msg
         * @classdesc Represents a PlayerInfo.
         * @implements IPlayerInfo
         * @constructor
         * @param {Msg.IPlayerInfo=} [properties] Properties to set
         */
        function PlayerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayerInfo id.
         * @member {string} id
         * @memberof Msg.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.id = "";

        /**
         * PlayerInfo nickname.
         * @member {string} nickname
         * @memberof Msg.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.nickname = "";

        /**
         * PlayerInfo url.
         * @member {string} url
         * @memberof Msg.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.url = "";

        /**
         * PlayerInfo level.
         * @member {number|Long} level
         * @memberof Msg.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.level = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PlayerInfo cup.
         * @member {number|Long} cup
         * @memberof Msg.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.cup = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PlayerInfo score.
         * @member {number|Long} score
         * @memberof Msg.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.score = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PlayerInfo seat.
         * @member {Msg.PlayerInfo.Seat} seat
         * @memberof Msg.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.seat = 0;

        /**
         * Creates a new PlayerInfo instance using the specified properties.
         * @function create
         * @memberof Msg.PlayerInfo
         * @static
         * @param {Msg.IPlayerInfo=} [properties] Properties to set
         * @returns {Msg.PlayerInfo} PlayerInfo instance
         */
        PlayerInfo.create = function create(properties) {
            return new PlayerInfo(properties);
        };

        /**
         * Encodes the specified PlayerInfo message. Does not implicitly {@link Msg.PlayerInfo.verify|verify} messages.
         * @function encode
         * @memberof Msg.PlayerInfo
         * @static
         * @param {Msg.IPlayerInfo} message PlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);
            if (message.url != null && message.hasOwnProperty("url"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.url);
            if (message.level != null && message.hasOwnProperty("level"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.level);
            if (message.cup != null && message.hasOwnProperty("cup"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.cup);
            if (message.score != null && message.hasOwnProperty("score"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.score);
            if (message.seat != null && message.hasOwnProperty("seat"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.seat);
            return writer;
        };

        /**
         * Encodes the specified PlayerInfo message, length delimited. Does not implicitly {@link Msg.PlayerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PlayerInfo
         * @static
         * @param {Msg.IPlayerInfo} message PlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PlayerInfo} PlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PlayerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.nickname = reader.string();
                    break;
                case 3:
                    message.url = reader.string();
                    break;
                case 4:
                    message.level = reader.int64();
                    break;
                case 5:
                    message.cup = reader.int64();
                    break;
                case 6:
                    message.score = reader.int64();
                    break;
                case 7:
                    message.seat = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PlayerInfo} PlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayerInfo message.
         * @function verify
         * @memberof Msg.PlayerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                if (!$util.isString(message.nickname))
                    return "nickname: string expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level) && !(message.level && $util.isInteger(message.level.low) && $util.isInteger(message.level.high)))
                    return "level: integer|Long expected";
            if (message.cup != null && message.hasOwnProperty("cup"))
                if (!$util.isInteger(message.cup) && !(message.cup && $util.isInteger(message.cup.low) && $util.isInteger(message.cup.high)))
                    return "cup: integer|Long expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score) && !(message.score && $util.isInteger(message.score.low) && $util.isInteger(message.score.high)))
                    return "score: integer|Long expected";
            if (message.seat != null && message.hasOwnProperty("seat"))
                switch (message.seat) {
                default:
                    return "seat: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a PlayerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PlayerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PlayerInfo} PlayerInfo
         */
        PlayerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PlayerInfo)
                return object;
            var message = new $root.Msg.PlayerInfo();
            if (object.id != null)
                message.id = String(object.id);
            if (object.nickname != null)
                message.nickname = String(object.nickname);
            if (object.url != null)
                message.url = String(object.url);
            if (object.level != null)
                if ($util.Long)
                    (message.level = $util.Long.fromValue(object.level)).unsigned = false;
                else if (typeof object.level === "string")
                    message.level = parseInt(object.level, 10);
                else if (typeof object.level === "number")
                    message.level = object.level;
                else if (typeof object.level === "object")
                    message.level = new $util.LongBits(object.level.low >>> 0, object.level.high >>> 0).toNumber();
            if (object.cup != null)
                if ($util.Long)
                    (message.cup = $util.Long.fromValue(object.cup)).unsigned = false;
                else if (typeof object.cup === "string")
                    message.cup = parseInt(object.cup, 10);
                else if (typeof object.cup === "number")
                    message.cup = object.cup;
                else if (typeof object.cup === "object")
                    message.cup = new $util.LongBits(object.cup.low >>> 0, object.cup.high >>> 0).toNumber();
            if (object.score != null)
                if ($util.Long)
                    (message.score = $util.Long.fromValue(object.score)).unsigned = false;
                else if (typeof object.score === "string")
                    message.score = parseInt(object.score, 10);
                else if (typeof object.score === "number")
                    message.score = object.score;
                else if (typeof object.score === "object")
                    message.score = new $util.LongBits(object.score.low >>> 0, object.score.high >>> 0).toNumber();
            switch (object.seat) {
            case "seat1":
            case 0:
                message.seat = 0;
                break;
            case "seat2":
            case 1:
                message.seat = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PlayerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PlayerInfo
         * @static
         * @param {Msg.PlayerInfo} message PlayerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.nickname = "";
                object.url = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.level = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.level = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.cup = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.cup = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.score = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.score = options.longs === String ? "0" : 0;
                object.seat = options.enums === String ? "seat1" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.nickname != null && message.hasOwnProperty("nickname"))
                object.nickname = message.nickname;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.level != null && message.hasOwnProperty("level"))
                if (typeof message.level === "number")
                    object.level = options.longs === String ? String(message.level) : message.level;
                else
                    object.level = options.longs === String ? $util.Long.prototype.toString.call(message.level) : options.longs === Number ? new $util.LongBits(message.level.low >>> 0, message.level.high >>> 0).toNumber() : message.level;
            if (message.cup != null && message.hasOwnProperty("cup"))
                if (typeof message.cup === "number")
                    object.cup = options.longs === String ? String(message.cup) : message.cup;
                else
                    object.cup = options.longs === String ? $util.Long.prototype.toString.call(message.cup) : options.longs === Number ? new $util.LongBits(message.cup.low >>> 0, message.cup.high >>> 0).toNumber() : message.cup;
            if (message.score != null && message.hasOwnProperty("score"))
                if (typeof message.score === "number")
                    object.score = options.longs === String ? String(message.score) : message.score;
                else
                    object.score = options.longs === String ? $util.Long.prototype.toString.call(message.score) : options.longs === Number ? new $util.LongBits(message.score.low >>> 0, message.score.high >>> 0).toNumber() : message.score;
            if (message.seat != null && message.hasOwnProperty("seat"))
                object.seat = options.enums === String ? $root.Msg.PlayerInfo.Seat[message.seat] : message.seat;
            return object;
        };

        /**
         * Converts this PlayerInfo to JSON.
         * @function toJSON
         * @memberof Msg.PlayerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Seat enum.
         * @name Msg.PlayerInfo.Seat
         * @enum {string}
         * @property {number} seat1=0 seat1 value
         * @property {number} seat2=1 seat2 value
         */
        PlayerInfo.Seat = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "seat1"] = 0;
            values[valuesById[1] = "seat2"] = 1;
            return values;
        })();

        return PlayerInfo;
    })();

    Msg.Pvp = (function() {

        /**
         * Constructs a new Pvp service.
         * @memberof Msg
         * @classdesc Represents a Pvp
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Pvp(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Pvp.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Pvp;

        /**
         * Creates new Pvp service using the specified rpc implementation.
         * @function create
         * @memberof Msg.Pvp
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {Pvp} RPC service. Useful where requests and/or responses are streamed.
         */
        Pvp.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link Msg.Pvp#ping}.
         * @memberof Msg.Pvp
         * @typedef PingCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {Msg.PingResp} [response] PingResp
         */

        /**
         * Calls Ping.
         * @function ping
         * @memberof Msg.Pvp
         * @instance
         * @param {Msg.IPingReq} request PingReq message or plain object
         * @param {Msg.Pvp.PingCallback} callback Node-style callback called with the error, if any, and PingResp
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Pvp.prototype.ping = function ping(request, callback) {
            return this.rpcCall(ping, $root.Msg.PingReq, $root.Msg.PingResp, request, callback);
        }, "name", { value: "Ping" });

        /**
         * Calls Ping.
         * @function ping
         * @memberof Msg.Pvp
         * @instance
         * @param {Msg.IPingReq} request PingReq message or plain object
         * @returns {Promise<Msg.PingResp>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link Msg.Pvp#createRoom}.
         * @memberof Msg.Pvp
         * @typedef CreateRoomCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {Msg.CreateRoomResp} [response] CreateRoomResp
         */

        /**
         * Calls CreateRoom.
         * @function createRoom
         * @memberof Msg.Pvp
         * @instance
         * @param {Msg.ICreateRoomReq} request CreateRoomReq message or plain object
         * @param {Msg.Pvp.CreateRoomCallback} callback Node-style callback called with the error, if any, and CreateRoomResp
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Pvp.prototype.createRoom = function createRoom(request, callback) {
            return this.rpcCall(createRoom, $root.Msg.CreateRoomReq, $root.Msg.CreateRoomResp, request, callback);
        }, "name", { value: "CreateRoom" });

        /**
         * Calls CreateRoom.
         * @function createRoom
         * @memberof Msg.Pvp
         * @instance
         * @param {Msg.ICreateRoomReq} request CreateRoomReq message or plain object
         * @returns {Promise<Msg.CreateRoomResp>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link Msg.Pvp#shoot}.
         * @memberof Msg.Pvp
         * @typedef ShootCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {Msg.PvpShootResp} [response] PvpShootResp
         */

        /**
         * Calls Shoot.
         * @function shoot
         * @memberof Msg.Pvp
         * @instance
         * @param {Msg.IPvpShootReq} request PvpShootReq message or plain object
         * @param {Msg.Pvp.ShootCallback} callback Node-style callback called with the error, if any, and PvpShootResp
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Pvp.prototype.shoot = function shoot(request, callback) {
            return this.rpcCall(shoot, $root.Msg.PvpShootReq, $root.Msg.PvpShootResp, request, callback);
        }, "name", { value: "Shoot" });

        /**
         * Calls Shoot.
         * @function shoot
         * @memberof Msg.Pvp
         * @instance
         * @param {Msg.IPvpShootReq} request PvpShootReq message or plain object
         * @returns {Promise<Msg.PvpShootResp>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link Msg.Pvp#surrender}.
         * @memberof Msg.Pvp
         * @typedef SurrenderCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {Msg.PvpSurrenderResp} [response] PvpSurrenderResp
         */

        /**
         * Calls Surrender.
         * @function surrender
         * @memberof Msg.Pvp
         * @instance
         * @param {Msg.IPvpSurrenderReq} request PvpSurrenderReq message or plain object
         * @param {Msg.Pvp.SurrenderCallback} callback Node-style callback called with the error, if any, and PvpSurrenderResp
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Pvp.prototype.surrender = function surrender(request, callback) {
            return this.rpcCall(surrender, $root.Msg.PvpSurrenderReq, $root.Msg.PvpSurrenderResp, request, callback);
        }, "name", { value: "Surrender" });

        /**
         * Calls Surrender.
         * @function surrender
         * @memberof Msg.Pvp
         * @instance
         * @param {Msg.IPvpSurrenderReq} request PvpSurrenderReq message or plain object
         * @returns {Promise<Msg.PvpSurrenderResp>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link Msg.Pvp#battleStatusAck}.
         * @memberof Msg.Pvp
         * @typedef BattleStatusAckCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {Msg.BattleStatusACKResp} [response] BattleStatusACKResp
         */

        /**
         * Calls BattleStatusAck.
         * @function battleStatusAck
         * @memberof Msg.Pvp
         * @instance
         * @param {Msg.IBattleStatusACK} request BattleStatusACK message or plain object
         * @param {Msg.Pvp.BattleStatusAckCallback} callback Node-style callback called with the error, if any, and BattleStatusACKResp
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Pvp.prototype.battleStatusAck = function battleStatusAck(request, callback) {
            return this.rpcCall(battleStatusAck, $root.Msg.BattleStatusACK, $root.Msg.BattleStatusACKResp, request, callback);
        }, "name", { value: "BattleStatusAck" });

        /**
         * Calls BattleStatusAck.
         * @function battleStatusAck
         * @memberof Msg.Pvp
         * @instance
         * @param {Msg.IBattleStatusACK} request BattleStatusACK message or plain object
         * @returns {Promise<Msg.BattleStatusACKResp>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link Msg.Pvp#enterRoom}.
         * @memberof Msg.Pvp
         * @typedef EnterRoomCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {Msg.PvpBattleStatus} [response] PvpBattleStatus
         */

        /**
         * Calls EnterRoom.
         * @function enterRoom
         * @memberof Msg.Pvp
         * @instance
         * @param {Msg.IBattleStatusReq} request BattleStatusReq message or plain object
         * @param {Msg.Pvp.EnterRoomCallback} callback Node-style callback called with the error, if any, and PvpBattleStatus
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Pvp.prototype.enterRoom = function enterRoom(request, callback) {
            return this.rpcCall(enterRoom, $root.Msg.BattleStatusReq, $root.Msg.PvpBattleStatus, request, callback);
        }, "name", { value: "EnterRoom" });

        /**
         * Calls EnterRoom.
         * @function enterRoom
         * @memberof Msg.Pvp
         * @instance
         * @param {Msg.IBattleStatusReq} request BattleStatusReq message or plain object
         * @returns {Promise<Msg.PvpBattleStatus>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link Msg.Pvp#quitRoom}.
         * @memberof Msg.Pvp
         * @typedef QuitRoomCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {Msg.QuitRoomResp} [response] QuitRoomResp
         */

        /**
         * Calls QuitRoom.
         * @function quitRoom
         * @memberof Msg.Pvp
         * @instance
         * @param {Msg.IQuitRoomReq} request QuitRoomReq message or plain object
         * @param {Msg.Pvp.QuitRoomCallback} callback Node-style callback called with the error, if any, and QuitRoomResp
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Pvp.prototype.quitRoom = function quitRoom(request, callback) {
            return this.rpcCall(quitRoom, $root.Msg.QuitRoomReq, $root.Msg.QuitRoomResp, request, callback);
        }, "name", { value: "QuitRoom" });

        /**
         * Calls QuitRoom.
         * @function quitRoom
         * @memberof Msg.Pvp
         * @instance
         * @param {Msg.IQuitRoomReq} request QuitRoomReq message or plain object
         * @returns {Promise<Msg.QuitRoomResp>} Promise
         * @variation 2
         */

        return Pvp;
    })();

    Msg.PingReq = (function() {

        /**
         * Properties of a PingReq.
         * @memberof Msg
         * @interface IPingReq
         */

        /**
         * Constructs a new PingReq.
         * @memberof Msg
         * @classdesc Represents a PingReq.
         * @implements IPingReq
         * @constructor
         * @param {Msg.IPingReq=} [properties] Properties to set
         */
        function PingReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PingReq instance using the specified properties.
         * @function create
         * @memberof Msg.PingReq
         * @static
         * @param {Msg.IPingReq=} [properties] Properties to set
         * @returns {Msg.PingReq} PingReq instance
         */
        PingReq.create = function create(properties) {
            return new PingReq(properties);
        };

        /**
         * Encodes the specified PingReq message. Does not implicitly {@link Msg.PingReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.PingReq
         * @static
         * @param {Msg.IPingReq} message PingReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PingReq message, length delimited. Does not implicitly {@link Msg.PingReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PingReq
         * @static
         * @param {Msg.IPingReq} message PingReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PingReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PingReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PingReq} PingReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PingReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PingReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PingReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PingReq} PingReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PingReq message.
         * @function verify
         * @memberof Msg.PingReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PingReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a PingReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PingReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PingReq} PingReq
         */
        PingReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PingReq)
                return object;
            return new $root.Msg.PingReq();
        };

        /**
         * Creates a plain object from a PingReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PingReq
         * @static
         * @param {Msg.PingReq} message PingReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PingReq.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PingReq to JSON.
         * @function toJSON
         * @memberof Msg.PingReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PingReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PingReq;
    })();

    Msg.PingResp = (function() {

        /**
         * Properties of a PingResp.
         * @memberof Msg
         * @interface IPingResp
         * @property {Msg.PingResp.Result|null} [result] PingResp result
         * @property {number|Long|null} [roomNum] PingResp roomNum
         */

        /**
         * Constructs a new PingResp.
         * @memberof Msg
         * @classdesc Represents a PingResp.
         * @implements IPingResp
         * @constructor
         * @param {Msg.IPingResp=} [properties] Properties to set
         */
        function PingResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PingResp result.
         * @member {Msg.PingResp.Result} result
         * @memberof Msg.PingResp
         * @instance
         */
        PingResp.prototype.result = 0;

        /**
         * PingResp roomNum.
         * @member {number|Long} roomNum
         * @memberof Msg.PingResp
         * @instance
         */
        PingResp.prototype.roomNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PingResp instance using the specified properties.
         * @function create
         * @memberof Msg.PingResp
         * @static
         * @param {Msg.IPingResp=} [properties] Properties to set
         * @returns {Msg.PingResp} PingResp instance
         */
        PingResp.create = function create(properties) {
            return new PingResp(properties);
        };

        /**
         * Encodes the specified PingResp message. Does not implicitly {@link Msg.PingResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.PingResp
         * @static
         * @param {Msg.IPingResp} message PingResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.roomNum != null && message.hasOwnProperty("roomNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.roomNum);
            return writer;
        };

        /**
         * Encodes the specified PingResp message, length delimited. Does not implicitly {@link Msg.PingResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.PingResp
         * @static
         * @param {Msg.IPingResp} message PingResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PingResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.PingResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.PingResp} PingResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.PingResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.roomNum = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PingResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.PingResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.PingResp} PingResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PingResp message.
         * @function verify
         * @memberof Msg.PingResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PingResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.roomNum != null && message.hasOwnProperty("roomNum"))
                if (!$util.isInteger(message.roomNum) && !(message.roomNum && $util.isInteger(message.roomNum.low) && $util.isInteger(message.roomNum.high)))
                    return "roomNum: integer|Long expected";
            return null;
        };

        /**
         * Creates a PingResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.PingResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.PingResp} PingResp
         */
        PingResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.PingResp)
                return object;
            var message = new $root.Msg.PingResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            if (object.roomNum != null)
                if ($util.Long)
                    (message.roomNum = $util.Long.fromValue(object.roomNum)).unsigned = false;
                else if (typeof object.roomNum === "string")
                    message.roomNum = parseInt(object.roomNum, 10);
                else if (typeof object.roomNum === "number")
                    message.roomNum = object.roomNum;
                else if (typeof object.roomNum === "object")
                    message.roomNum = new $util.LongBits(object.roomNum.low >>> 0, object.roomNum.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PingResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.PingResp
         * @static
         * @param {Msg.PingResp} message PingResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PingResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "Internal" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.roomNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.roomNum = options.longs === String ? "0" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.PingResp.Result[message.result] : message.result;
            if (message.roomNum != null && message.hasOwnProperty("roomNum"))
                if (typeof message.roomNum === "number")
                    object.roomNum = options.longs === String ? String(message.roomNum) : message.roomNum;
                else
                    object.roomNum = options.longs === String ? $util.Long.prototype.toString.call(message.roomNum) : options.longs === Number ? new $util.LongBits(message.roomNum.low >>> 0, message.roomNum.high >>> 0).toNumber() : message.roomNum;
            return object;
        };

        /**
         * Converts this PingResp to JSON.
         * @function toJSON
         * @memberof Msg.PingResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PingResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.PingResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        PingResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return PingResp;
    })();

    Msg.CreateRoomReq = (function() {

        /**
         * Properties of a CreateRoomReq.
         * @memberof Msg
         * @interface ICreateRoomReq
         * @property {Msg.IPlayerInfo|null} [player1] CreateRoomReq player1
         * @property {Msg.IPlayerInfo|null} [player2] CreateRoomReq player2
         * @property {string|null} [address] CreateRoomReq address
         */

        /**
         * Constructs a new CreateRoomReq.
         * @memberof Msg
         * @classdesc Represents a CreateRoomReq.
         * @implements ICreateRoomReq
         * @constructor
         * @param {Msg.ICreateRoomReq=} [properties] Properties to set
         */
        function CreateRoomReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateRoomReq player1.
         * @member {Msg.IPlayerInfo|null|undefined} player1
         * @memberof Msg.CreateRoomReq
         * @instance
         */
        CreateRoomReq.prototype.player1 = null;

        /**
         * CreateRoomReq player2.
         * @member {Msg.IPlayerInfo|null|undefined} player2
         * @memberof Msg.CreateRoomReq
         * @instance
         */
        CreateRoomReq.prototype.player2 = null;

        /**
         * CreateRoomReq address.
         * @member {string} address
         * @memberof Msg.CreateRoomReq
         * @instance
         */
        CreateRoomReq.prototype.address = "";

        /**
         * Creates a new CreateRoomReq instance using the specified properties.
         * @function create
         * @memberof Msg.CreateRoomReq
         * @static
         * @param {Msg.ICreateRoomReq=} [properties] Properties to set
         * @returns {Msg.CreateRoomReq} CreateRoomReq instance
         */
        CreateRoomReq.create = function create(properties) {
            return new CreateRoomReq(properties);
        };

        /**
         * Encodes the specified CreateRoomReq message. Does not implicitly {@link Msg.CreateRoomReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.CreateRoomReq
         * @static
         * @param {Msg.ICreateRoomReq} message CreateRoomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRoomReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.player1 != null && message.hasOwnProperty("player1"))
                $root.Msg.PlayerInfo.encode(message.player1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.player2 != null && message.hasOwnProperty("player2"))
                $root.Msg.PlayerInfo.encode(message.player2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.address);
            return writer;
        };

        /**
         * Encodes the specified CreateRoomReq message, length delimited. Does not implicitly {@link Msg.CreateRoomReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.CreateRoomReq
         * @static
         * @param {Msg.ICreateRoomReq} message CreateRoomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRoomReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateRoomReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.CreateRoomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.CreateRoomReq} CreateRoomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRoomReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.CreateRoomReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.player1 = $root.Msg.PlayerInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.player2 = $root.Msg.PlayerInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateRoomReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.CreateRoomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.CreateRoomReq} CreateRoomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRoomReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateRoomReq message.
         * @function verify
         * @memberof Msg.CreateRoomReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateRoomReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.player1 != null && message.hasOwnProperty("player1")) {
                var error = $root.Msg.PlayerInfo.verify(message.player1);
                if (error)
                    return "player1." + error;
            }
            if (message.player2 != null && message.hasOwnProperty("player2")) {
                var error = $root.Msg.PlayerInfo.verify(message.player2);
                if (error)
                    return "player2." + error;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            return null;
        };

        /**
         * Creates a CreateRoomReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.CreateRoomReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.CreateRoomReq} CreateRoomReq
         */
        CreateRoomReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.CreateRoomReq)
                return object;
            var message = new $root.Msg.CreateRoomReq();
            if (object.player1 != null) {
                if (typeof object.player1 !== "object")
                    throw TypeError(".Msg.CreateRoomReq.player1: object expected");
                message.player1 = $root.Msg.PlayerInfo.fromObject(object.player1);
            }
            if (object.player2 != null) {
                if (typeof object.player2 !== "object")
                    throw TypeError(".Msg.CreateRoomReq.player2: object expected");
                message.player2 = $root.Msg.PlayerInfo.fromObject(object.player2);
            }
            if (object.address != null)
                message.address = String(object.address);
            return message;
        };

        /**
         * Creates a plain object from a CreateRoomReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.CreateRoomReq
         * @static
         * @param {Msg.CreateRoomReq} message CreateRoomReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateRoomReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.player1 = null;
                object.player2 = null;
                object.address = "";
            }
            if (message.player1 != null && message.hasOwnProperty("player1"))
                object.player1 = $root.Msg.PlayerInfo.toObject(message.player1, options);
            if (message.player2 != null && message.hasOwnProperty("player2"))
                object.player2 = $root.Msg.PlayerInfo.toObject(message.player2, options);
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            return object;
        };

        /**
         * Converts this CreateRoomReq to JSON.
         * @function toJSON
         * @memberof Msg.CreateRoomReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateRoomReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateRoomReq;
    })();

    Msg.CreateRoomResp = (function() {

        /**
         * Properties of a CreateRoomResp.
         * @memberof Msg
         * @interface ICreateRoomResp
         * @property {Msg.CreateRoomResp.Result|null} [result] CreateRoomResp result
         * @property {string|null} [roomID] CreateRoomResp roomID
         * @property {Msg.IPvpBattle|null} [pvp] CreateRoomResp pvp
         */

        /**
         * Constructs a new CreateRoomResp.
         * @memberof Msg
         * @classdesc Represents a CreateRoomResp.
         * @implements ICreateRoomResp
         * @constructor
         * @param {Msg.ICreateRoomResp=} [properties] Properties to set
         */
        function CreateRoomResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateRoomResp result.
         * @member {Msg.CreateRoomResp.Result} result
         * @memberof Msg.CreateRoomResp
         * @instance
         */
        CreateRoomResp.prototype.result = 0;

        /**
         * CreateRoomResp roomID.
         * @member {string} roomID
         * @memberof Msg.CreateRoomResp
         * @instance
         */
        CreateRoomResp.prototype.roomID = "";

        /**
         * CreateRoomResp pvp.
         * @member {Msg.IPvpBattle|null|undefined} pvp
         * @memberof Msg.CreateRoomResp
         * @instance
         */
        CreateRoomResp.prototype.pvp = null;

        /**
         * Creates a new CreateRoomResp instance using the specified properties.
         * @function create
         * @memberof Msg.CreateRoomResp
         * @static
         * @param {Msg.ICreateRoomResp=} [properties] Properties to set
         * @returns {Msg.CreateRoomResp} CreateRoomResp instance
         */
        CreateRoomResp.create = function create(properties) {
            return new CreateRoomResp(properties);
        };

        /**
         * Encodes the specified CreateRoomResp message. Does not implicitly {@link Msg.CreateRoomResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.CreateRoomResp
         * @static
         * @param {Msg.ICreateRoomResp} message CreateRoomResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRoomResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.roomID);
            if (message.pvp != null && message.hasOwnProperty("pvp"))
                $root.Msg.PvpBattle.encode(message.pvp, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateRoomResp message, length delimited. Does not implicitly {@link Msg.CreateRoomResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.CreateRoomResp
         * @static
         * @param {Msg.ICreateRoomResp} message CreateRoomResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateRoomResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateRoomResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.CreateRoomResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.CreateRoomResp} CreateRoomResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRoomResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.CreateRoomResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.roomID = reader.string();
                    break;
                case 3:
                    message.pvp = $root.Msg.PvpBattle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateRoomResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.CreateRoomResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.CreateRoomResp} CreateRoomResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateRoomResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateRoomResp message.
         * @function verify
         * @memberof Msg.CreateRoomResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateRoomResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                if (!$util.isString(message.roomID))
                    return "roomID: string expected";
            if (message.pvp != null && message.hasOwnProperty("pvp")) {
                var error = $root.Msg.PvpBattle.verify(message.pvp);
                if (error)
                    return "pvp." + error;
            }
            return null;
        };

        /**
         * Creates a CreateRoomResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.CreateRoomResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.CreateRoomResp} CreateRoomResp
         */
        CreateRoomResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.CreateRoomResp)
                return object;
            var message = new $root.Msg.CreateRoomResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            if (object.roomID != null)
                message.roomID = String(object.roomID);
            if (object.pvp != null) {
                if (typeof object.pvp !== "object")
                    throw TypeError(".Msg.CreateRoomResp.pvp: object expected");
                message.pvp = $root.Msg.PvpBattle.fromObject(object.pvp);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateRoomResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.CreateRoomResp
         * @static
         * @param {Msg.CreateRoomResp} message CreateRoomResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateRoomResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "Internal" : 0;
                object.roomID = "";
                object.pvp = null;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.CreateRoomResp.Result[message.result] : message.result;
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                object.roomID = message.roomID;
            if (message.pvp != null && message.hasOwnProperty("pvp"))
                object.pvp = $root.Msg.PvpBattle.toObject(message.pvp, options);
            return object;
        };

        /**
         * Converts this CreateRoomResp to JSON.
         * @function toJSON
         * @memberof Msg.CreateRoomResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateRoomResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.CreateRoomResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        CreateRoomResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return CreateRoomResp;
    })();

    Msg.BattleStatusReq = (function() {

        /**
         * Properties of a BattleStatusReq.
         * @memberof Msg
         * @interface IBattleStatusReq
         * @property {string|null} [roomID] BattleStatusReq roomID
         * @property {string|null} [playerID] BattleStatusReq playerID
         */

        /**
         * Constructs a new BattleStatusReq.
         * @memberof Msg
         * @classdesc Represents a BattleStatusReq.
         * @implements IBattleStatusReq
         * @constructor
         * @param {Msg.IBattleStatusReq=} [properties] Properties to set
         */
        function BattleStatusReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleStatusReq roomID.
         * @member {string} roomID
         * @memberof Msg.BattleStatusReq
         * @instance
         */
        BattleStatusReq.prototype.roomID = "";

        /**
         * BattleStatusReq playerID.
         * @member {string} playerID
         * @memberof Msg.BattleStatusReq
         * @instance
         */
        BattleStatusReq.prototype.playerID = "";

        /**
         * Creates a new BattleStatusReq instance using the specified properties.
         * @function create
         * @memberof Msg.BattleStatusReq
         * @static
         * @param {Msg.IBattleStatusReq=} [properties] Properties to set
         * @returns {Msg.BattleStatusReq} BattleStatusReq instance
         */
        BattleStatusReq.create = function create(properties) {
            return new BattleStatusReq(properties);
        };

        /**
         * Encodes the specified BattleStatusReq message. Does not implicitly {@link Msg.BattleStatusReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.BattleStatusReq
         * @static
         * @param {Msg.IBattleStatusReq} message BattleStatusReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleStatusReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.roomID);
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified BattleStatusReq message, length delimited. Does not implicitly {@link Msg.BattleStatusReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.BattleStatusReq
         * @static
         * @param {Msg.IBattleStatusReq} message BattleStatusReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleStatusReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleStatusReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.BattleStatusReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.BattleStatusReq} BattleStatusReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleStatusReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.BattleStatusReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomID = reader.string();
                    break;
                case 2:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleStatusReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.BattleStatusReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.BattleStatusReq} BattleStatusReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleStatusReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleStatusReq message.
         * @function verify
         * @memberof Msg.BattleStatusReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleStatusReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                if (!$util.isString(message.roomID))
                    return "roomID: string expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a BattleStatusReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.BattleStatusReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.BattleStatusReq} BattleStatusReq
         */
        BattleStatusReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.BattleStatusReq)
                return object;
            var message = new $root.Msg.BattleStatusReq();
            if (object.roomID != null)
                message.roomID = String(object.roomID);
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a BattleStatusReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.BattleStatusReq
         * @static
         * @param {Msg.BattleStatusReq} message BattleStatusReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BattleStatusReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.roomID = "";
                object.playerID = "";
            }
            if (message.roomID != null && message.hasOwnProperty("roomID"))
                object.roomID = message.roomID;
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this BattleStatusReq to JSON.
         * @function toJSON
         * @memberof Msg.BattleStatusReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BattleStatusReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BattleStatusReq;
    })();

    Msg.GetRankListReq = (function() {

        /**
         * Properties of a GetRankListReq.
         * @memberof Msg
         * @interface IGetRankListReq
         * @property {Msg.GetRankListReq.RankType|null} [rankType] GetRankListReq rankType
         * @property {Msg.GetRankListReq.RankZone|null} [rankZone] GetRankListReq rankZone
         */

        /**
         * Constructs a new GetRankListReq.
         * @memberof Msg
         * @classdesc Represents a GetRankListReq.
         * @implements IGetRankListReq
         * @constructor
         * @param {Msg.IGetRankListReq=} [properties] Properties to set
         */
        function GetRankListReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRankListReq rankType.
         * @member {Msg.GetRankListReq.RankType} rankType
         * @memberof Msg.GetRankListReq
         * @instance
         */
        GetRankListReq.prototype.rankType = 0;

        /**
         * GetRankListReq rankZone.
         * @member {Msg.GetRankListReq.RankZone} rankZone
         * @memberof Msg.GetRankListReq
         * @instance
         */
        GetRankListReq.prototype.rankZone = 0;

        /**
         * Creates a new GetRankListReq instance using the specified properties.
         * @function create
         * @memberof Msg.GetRankListReq
         * @static
         * @param {Msg.IGetRankListReq=} [properties] Properties to set
         * @returns {Msg.GetRankListReq} GetRankListReq instance
         */
        GetRankListReq.create = function create(properties) {
            return new GetRankListReq(properties);
        };

        /**
         * Encodes the specified GetRankListReq message. Does not implicitly {@link Msg.GetRankListReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetRankListReq
         * @static
         * @param {Msg.IGetRankListReq} message GetRankListReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRankListReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rankType);
            if (message.rankZone != null && message.hasOwnProperty("rankZone"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.rankZone);
            return writer;
        };

        /**
         * Encodes the specified GetRankListReq message, length delimited. Does not implicitly {@link Msg.GetRankListReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetRankListReq
         * @static
         * @param {Msg.IGetRankListReq} message GetRankListReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRankListReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRankListReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetRankListReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetRankListReq} GetRankListReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRankListReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetRankListReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rankType = reader.int32();
                    break;
                case 2:
                    message.rankZone = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRankListReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetRankListReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetRankListReq} GetRankListReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRankListReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRankListReq message.
         * @function verify
         * @memberof Msg.GetRankListReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRankListReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                switch (message.rankType) {
                default:
                    return "rankType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.rankZone != null && message.hasOwnProperty("rankZone"))
                switch (message.rankZone) {
                default:
                    return "rankZone: enum value expected";
                case 0:
                    break;
                }
            return null;
        };

        /**
         * Creates a GetRankListReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetRankListReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetRankListReq} GetRankListReq
         */
        GetRankListReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetRankListReq)
                return object;
            var message = new $root.Msg.GetRankListReq();
            switch (object.rankType) {
            case "PveStar":
            case 0:
                message.rankType = 0;
                break;
            case "PvpCup":
            case 1:
                message.rankType = 1;
                break;
            }
            switch (object.rankZone) {
            case "Global":
            case 0:
                message.rankZone = 0;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetRankListReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetRankListReq
         * @static
         * @param {Msg.GetRankListReq} message GetRankListReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRankListReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rankType = options.enums === String ? "PveStar" : 0;
                object.rankZone = options.enums === String ? "Global" : 0;
            }
            if (message.rankType != null && message.hasOwnProperty("rankType"))
                object.rankType = options.enums === String ? $root.Msg.GetRankListReq.RankType[message.rankType] : message.rankType;
            if (message.rankZone != null && message.hasOwnProperty("rankZone"))
                object.rankZone = options.enums === String ? $root.Msg.GetRankListReq.RankZone[message.rankZone] : message.rankZone;
            return object;
        };

        /**
         * Converts this GetRankListReq to JSON.
         * @function toJSON
         * @memberof Msg.GetRankListReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRankListReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * RankType enum.
         * @name Msg.GetRankListReq.RankType
         * @enum {string}
         * @property {number} PveStar=0 PveStar value
         * @property {number} PvpCup=1 PvpCup value
         */
        GetRankListReq.RankType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PveStar"] = 0;
            values[valuesById[1] = "PvpCup"] = 1;
            return values;
        })();

        /**
         * RankZone enum.
         * @name Msg.GetRankListReq.RankZone
         * @enum {string}
         * @property {number} Global=0 Global value
         */
        GetRankListReq.RankZone = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Global"] = 0;
            return values;
        })();

        return GetRankListReq;
    })();

    Msg.GetRankListResp = (function() {

        /**
         * Properties of a GetRankListResp.
         * @memberof Msg
         * @interface IGetRankListResp
         * @property {Msg.IStatus|null} [status] GetRankListResp status
         * @property {Array.<Msg.GetRankListResp.IRankItem>|null} [items] GetRankListResp items
         */

        /**
         * Constructs a new GetRankListResp.
         * @memberof Msg
         * @classdesc Represents a GetRankListResp.
         * @implements IGetRankListResp
         * @constructor
         * @param {Msg.IGetRankListResp=} [properties] Properties to set
         */
        function GetRankListResp(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRankListResp status.
         * @member {Msg.IStatus|null|undefined} status
         * @memberof Msg.GetRankListResp
         * @instance
         */
        GetRankListResp.prototype.status = null;

        /**
         * GetRankListResp items.
         * @member {Array.<Msg.GetRankListResp.IRankItem>} items
         * @memberof Msg.GetRankListResp
         * @instance
         */
        GetRankListResp.prototype.items = $util.emptyArray;

        /**
         * Creates a new GetRankListResp instance using the specified properties.
         * @function create
         * @memberof Msg.GetRankListResp
         * @static
         * @param {Msg.IGetRankListResp=} [properties] Properties to set
         * @returns {Msg.GetRankListResp} GetRankListResp instance
         */
        GetRankListResp.create = function create(properties) {
            return new GetRankListResp(properties);
        };

        /**
         * Encodes the specified GetRankListResp message. Does not implicitly {@link Msg.GetRankListResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetRankListResp
         * @static
         * @param {Msg.IGetRankListResp} message GetRankListResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRankListResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && message.hasOwnProperty("status"))
                $root.Msg.Status.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.Msg.GetRankListResp.RankItem.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetRankListResp message, length delimited. Does not implicitly {@link Msg.GetRankListResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetRankListResp
         * @static
         * @param {Msg.IGetRankListResp} message GetRankListResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRankListResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRankListResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetRankListResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetRankListResp} GetRankListResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRankListResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetRankListResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = $root.Msg.Status.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.Msg.GetRankListResp.RankItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRankListResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetRankListResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetRankListResp} GetRankListResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRankListResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRankListResp message.
         * @function verify
         * @memberof Msg.GetRankListResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRankListResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.Msg.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.Msg.GetRankListResp.RankItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetRankListResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetRankListResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetRankListResp} GetRankListResp
         */
        GetRankListResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetRankListResp)
                return object;
            var message = new $root.Msg.GetRankListResp();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".Msg.GetRankListResp.status: object expected");
                message.status = $root.Msg.Status.fromObject(object.status);
            }
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".Msg.GetRankListResp.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".Msg.GetRankListResp.items: object expected");
                    message.items[i] = $root.Msg.GetRankListResp.RankItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetRankListResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetRankListResp
         * @static
         * @param {Msg.GetRankListResp} message GetRankListResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetRankListResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.Msg.Status.toObject(message.status, options);
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.Msg.GetRankListResp.RankItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this GetRankListResp to JSON.
         * @function toJSON
         * @memberof Msg.GetRankListResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetRankListResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        GetRankListResp.RankItem = (function() {

            /**
             * Properties of a RankItem.
             * @memberof Msg.GetRankListResp
             * @interface IRankItem
             * @property {string|null} [playerID] RankItem playerID
             * @property {string|null} [avatar] RankItem avatar
             * @property {string|null} [name] RankItem name
             * @property {number|null} [sex] RankItem sex
             * @property {number|Long|null} [exp] RankItem exp
             * @property {number|Long|null} [val1] RankItem val1
             * @property {number|Long|null} [val2] RankItem val2
             */

            /**
             * Constructs a new RankItem.
             * @memberof Msg.GetRankListResp
             * @classdesc Represents a RankItem.
             * @implements IRankItem
             * @constructor
             * @param {Msg.GetRankListResp.IRankItem=} [properties] Properties to set
             */
            function RankItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RankItem playerID.
             * @member {string} playerID
             * @memberof Msg.GetRankListResp.RankItem
             * @instance
             */
            RankItem.prototype.playerID = "";

            /**
             * RankItem avatar.
             * @member {string} avatar
             * @memberof Msg.GetRankListResp.RankItem
             * @instance
             */
            RankItem.prototype.avatar = "";

            /**
             * RankItem name.
             * @member {string} name
             * @memberof Msg.GetRankListResp.RankItem
             * @instance
             */
            RankItem.prototype.name = "";

            /**
             * RankItem sex.
             * @member {number} sex
             * @memberof Msg.GetRankListResp.RankItem
             * @instance
             */
            RankItem.prototype.sex = 0;

            /**
             * RankItem exp.
             * @member {number|Long} exp
             * @memberof Msg.GetRankListResp.RankItem
             * @instance
             */
            RankItem.prototype.exp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RankItem val1.
             * @member {number|Long} val1
             * @memberof Msg.GetRankListResp.RankItem
             * @instance
             */
            RankItem.prototype.val1 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RankItem val2.
             * @member {number|Long} val2
             * @memberof Msg.GetRankListResp.RankItem
             * @instance
             */
            RankItem.prototype.val2 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new RankItem instance using the specified properties.
             * @function create
             * @memberof Msg.GetRankListResp.RankItem
             * @static
             * @param {Msg.GetRankListResp.IRankItem=} [properties] Properties to set
             * @returns {Msg.GetRankListResp.RankItem} RankItem instance
             */
            RankItem.create = function create(properties) {
                return new RankItem(properties);
            };

            /**
             * Encodes the specified RankItem message. Does not implicitly {@link Msg.GetRankListResp.RankItem.verify|verify} messages.
             * @function encode
             * @memberof Msg.GetRankListResp.RankItem
             * @static
             * @param {Msg.GetRankListResp.IRankItem} message RankItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RankItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.playerID != null && message.hasOwnProperty("playerID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.avatar);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                if (message.sex != null && message.hasOwnProperty("sex"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.sex);
                if (message.exp != null && message.hasOwnProperty("exp"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.exp);
                if (message.val1 != null && message.hasOwnProperty("val1"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.val1);
                if (message.val2 != null && message.hasOwnProperty("val2"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.val2);
                return writer;
            };

            /**
             * Encodes the specified RankItem message, length delimited. Does not implicitly {@link Msg.GetRankListResp.RankItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Msg.GetRankListResp.RankItem
             * @static
             * @param {Msg.GetRankListResp.IRankItem} message RankItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RankItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RankItem message from the specified reader or buffer.
             * @function decode
             * @memberof Msg.GetRankListResp.RankItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Msg.GetRankListResp.RankItem} RankItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RankItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetRankListResp.RankItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.playerID = reader.string();
                        break;
                    case 2:
                        message.avatar = reader.string();
                        break;
                    case 3:
                        message.name = reader.string();
                        break;
                    case 4:
                        message.sex = reader.int32();
                        break;
                    case 5:
                        message.exp = reader.int64();
                        break;
                    case 6:
                        message.val1 = reader.int64();
                        break;
                    case 7:
                        message.val2 = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RankItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Msg.GetRankListResp.RankItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Msg.GetRankListResp.RankItem} RankItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RankItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RankItem message.
             * @function verify
             * @memberof Msg.GetRankListResp.RankItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RankItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.playerID != null && message.hasOwnProperty("playerID"))
                    if (!$util.isString(message.playerID))
                        return "playerID: string expected";
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    if (!$util.isString(message.avatar))
                        return "avatar: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.sex != null && message.hasOwnProperty("sex"))
                    if (!$util.isInteger(message.sex))
                        return "sex: integer expected";
                if (message.exp != null && message.hasOwnProperty("exp"))
                    if (!$util.isInteger(message.exp) && !(message.exp && $util.isInteger(message.exp.low) && $util.isInteger(message.exp.high)))
                        return "exp: integer|Long expected";
                if (message.val1 != null && message.hasOwnProperty("val1"))
                    if (!$util.isInteger(message.val1) && !(message.val1 && $util.isInteger(message.val1.low) && $util.isInteger(message.val1.high)))
                        return "val1: integer|Long expected";
                if (message.val2 != null && message.hasOwnProperty("val2"))
                    if (!$util.isInteger(message.val2) && !(message.val2 && $util.isInteger(message.val2.low) && $util.isInteger(message.val2.high)))
                        return "val2: integer|Long expected";
                return null;
            };

            /**
             * Creates a RankItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Msg.GetRankListResp.RankItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Msg.GetRankListResp.RankItem} RankItem
             */
            RankItem.fromObject = function fromObject(object) {
                if (object instanceof $root.Msg.GetRankListResp.RankItem)
                    return object;
                var message = new $root.Msg.GetRankListResp.RankItem();
                if (object.playerID != null)
                    message.playerID = String(object.playerID);
                if (object.avatar != null)
                    message.avatar = String(object.avatar);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.sex != null)
                    message.sex = object.sex | 0;
                if (object.exp != null)
                    if ($util.Long)
                        (message.exp = $util.Long.fromValue(object.exp)).unsigned = false;
                    else if (typeof object.exp === "string")
                        message.exp = parseInt(object.exp, 10);
                    else if (typeof object.exp === "number")
                        message.exp = object.exp;
                    else if (typeof object.exp === "object")
                        message.exp = new $util.LongBits(object.exp.low >>> 0, object.exp.high >>> 0).toNumber();
                if (object.val1 != null)
                    if ($util.Long)
                        (message.val1 = $util.Long.fromValue(object.val1)).unsigned = false;
                    else if (typeof object.val1 === "string")
                        message.val1 = parseInt(object.val1, 10);
                    else if (typeof object.val1 === "number")
                        message.val1 = object.val1;
                    else if (typeof object.val1 === "object")
                        message.val1 = new $util.LongBits(object.val1.low >>> 0, object.val1.high >>> 0).toNumber();
                if (object.val2 != null)
                    if ($util.Long)
                        (message.val2 = $util.Long.fromValue(object.val2)).unsigned = false;
                    else if (typeof object.val2 === "string")
                        message.val2 = parseInt(object.val2, 10);
                    else if (typeof object.val2 === "number")
                        message.val2 = object.val2;
                    else if (typeof object.val2 === "object")
                        message.val2 = new $util.LongBits(object.val2.low >>> 0, object.val2.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a RankItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Msg.GetRankListResp.RankItem
             * @static
             * @param {Msg.GetRankListResp.RankItem} message RankItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RankItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.playerID = "";
                    object.avatar = "";
                    object.name = "";
                    object.sex = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.exp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.exp = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.val1 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.val1 = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.val2 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.val2 = options.longs === String ? "0" : 0;
                }
                if (message.playerID != null && message.hasOwnProperty("playerID"))
                    object.playerID = message.playerID;
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    object.avatar = message.avatar;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.sex != null && message.hasOwnProperty("sex"))
                    object.sex = message.sex;
                if (message.exp != null && message.hasOwnProperty("exp"))
                    if (typeof message.exp === "number")
                        object.exp = options.longs === String ? String(message.exp) : message.exp;
                    else
                        object.exp = options.longs === String ? $util.Long.prototype.toString.call(message.exp) : options.longs === Number ? new $util.LongBits(message.exp.low >>> 0, message.exp.high >>> 0).toNumber() : message.exp;
                if (message.val1 != null && message.hasOwnProperty("val1"))
                    if (typeof message.val1 === "number")
                        object.val1 = options.longs === String ? String(message.val1) : message.val1;
                    else
                        object.val1 = options.longs === String ? $util.Long.prototype.toString.call(message.val1) : options.longs === Number ? new $util.LongBits(message.val1.low >>> 0, message.val1.high >>> 0).toNumber() : message.val1;
                if (message.val2 != null && message.hasOwnProperty("val2"))
                    if (typeof message.val2 === "number")
                        object.val2 = options.longs === String ? String(message.val2) : message.val2;
                    else
                        object.val2 = options.longs === String ? $util.Long.prototype.toString.call(message.val2) : options.longs === Number ? new $util.LongBits(message.val2.low >>> 0, message.val2.high >>> 0).toNumber() : message.val2;
                return object;
            };

            /**
             * Converts this RankItem to JSON.
             * @function toJSON
             * @memberof Msg.GetRankListResp.RankItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RankItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RankItem;
        })();

        return GetRankListResp;
    })();

    Msg.GetPlayerAchievementReq = (function() {

        /**
         * Properties of a GetPlayerAchievementReq.
         * @memberof Msg
         * @interface IGetPlayerAchievementReq
         * @property {string|null} [playerID] GetPlayerAchievementReq playerID
         */

        /**
         * Constructs a new GetPlayerAchievementReq.
         * @memberof Msg
         * @classdesc Represents a GetPlayerAchievementReq.
         * @implements IGetPlayerAchievementReq
         * @constructor
         * @param {Msg.IGetPlayerAchievementReq=} [properties] Properties to set
         */
        function GetPlayerAchievementReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlayerAchievementReq playerID.
         * @member {string} playerID
         * @memberof Msg.GetPlayerAchievementReq
         * @instance
         */
        GetPlayerAchievementReq.prototype.playerID = "";

        /**
         * Creates a new GetPlayerAchievementReq instance using the specified properties.
         * @function create
         * @memberof Msg.GetPlayerAchievementReq
         * @static
         * @param {Msg.IGetPlayerAchievementReq=} [properties] Properties to set
         * @returns {Msg.GetPlayerAchievementReq} GetPlayerAchievementReq instance
         */
        GetPlayerAchievementReq.create = function create(properties) {
            return new GetPlayerAchievementReq(properties);
        };

        /**
         * Encodes the specified GetPlayerAchievementReq message. Does not implicitly {@link Msg.GetPlayerAchievementReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetPlayerAchievementReq
         * @static
         * @param {Msg.IGetPlayerAchievementReq} message GetPlayerAchievementReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerAchievementReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified GetPlayerAchievementReq message, length delimited. Does not implicitly {@link Msg.GetPlayerAchievementReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetPlayerAchievementReq
         * @static
         * @param {Msg.IGetPlayerAchievementReq} message GetPlayerAchievementReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerAchievementReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlayerAchievementReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetPlayerAchievementReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetPlayerAchievementReq} GetPlayerAchievementReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerAchievementReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetPlayerAchievementReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlayerAchievementReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetPlayerAchievementReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetPlayerAchievementReq} GetPlayerAchievementReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerAchievementReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlayerAchievementReq message.
         * @function verify
         * @memberof Msg.GetPlayerAchievementReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlayerAchievementReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a GetPlayerAchievementReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetPlayerAchievementReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetPlayerAchievementReq} GetPlayerAchievementReq
         */
        GetPlayerAchievementReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetPlayerAchievementReq)
                return object;
            var message = new $root.Msg.GetPlayerAchievementReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a GetPlayerAchievementReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetPlayerAchievementReq
         * @static
         * @param {Msg.GetPlayerAchievementReq} message GetPlayerAchievementReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlayerAchievementReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playerID = "";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this GetPlayerAchievementReq to JSON.
         * @function toJSON
         * @memberof Msg.GetPlayerAchievementReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlayerAchievementReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetPlayerAchievementReq;
    })();

    Msg.GetPlayerAchievementResp = (function() {

        /**
         * Properties of a GetPlayerAchievementResp.
         * @memberof Msg
         * @interface IGetPlayerAchievementResp
         * @property {Msg.GetPlayerAchievementResp.Result|null} [result] GetPlayerAchievementResp result
         * @property {Array.<Msg.ITask>|null} [task] GetPlayerAchievementResp task
         */

        /**
         * Constructs a new GetPlayerAchievementResp.
         * @memberof Msg
         * @classdesc Represents a GetPlayerAchievementResp.
         * @implements IGetPlayerAchievementResp
         * @constructor
         * @param {Msg.IGetPlayerAchievementResp=} [properties] Properties to set
         */
        function GetPlayerAchievementResp(properties) {
            this.task = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlayerAchievementResp result.
         * @member {Msg.GetPlayerAchievementResp.Result} result
         * @memberof Msg.GetPlayerAchievementResp
         * @instance
         */
        GetPlayerAchievementResp.prototype.result = 0;

        /**
         * GetPlayerAchievementResp task.
         * @member {Array.<Msg.ITask>} task
         * @memberof Msg.GetPlayerAchievementResp
         * @instance
         */
        GetPlayerAchievementResp.prototype.task = $util.emptyArray;

        /**
         * Creates a new GetPlayerAchievementResp instance using the specified properties.
         * @function create
         * @memberof Msg.GetPlayerAchievementResp
         * @static
         * @param {Msg.IGetPlayerAchievementResp=} [properties] Properties to set
         * @returns {Msg.GetPlayerAchievementResp} GetPlayerAchievementResp instance
         */
        GetPlayerAchievementResp.create = function create(properties) {
            return new GetPlayerAchievementResp(properties);
        };

        /**
         * Encodes the specified GetPlayerAchievementResp message. Does not implicitly {@link Msg.GetPlayerAchievementResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetPlayerAchievementResp
         * @static
         * @param {Msg.IGetPlayerAchievementResp} message GetPlayerAchievementResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerAchievementResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.task != null && message.task.length)
                for (var i = 0; i < message.task.length; ++i)
                    $root.Msg.Task.encode(message.task[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetPlayerAchievementResp message, length delimited. Does not implicitly {@link Msg.GetPlayerAchievementResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetPlayerAchievementResp
         * @static
         * @param {Msg.IGetPlayerAchievementResp} message GetPlayerAchievementResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerAchievementResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlayerAchievementResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetPlayerAchievementResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetPlayerAchievementResp} GetPlayerAchievementResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerAchievementResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetPlayerAchievementResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.task && message.task.length))
                        message.task = [];
                    message.task.push($root.Msg.Task.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlayerAchievementResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetPlayerAchievementResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetPlayerAchievementResp} GetPlayerAchievementResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerAchievementResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlayerAchievementResp message.
         * @function verify
         * @memberof Msg.GetPlayerAchievementResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlayerAchievementResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.task != null && message.hasOwnProperty("task")) {
                if (!Array.isArray(message.task))
                    return "task: array expected";
                for (var i = 0; i < message.task.length; ++i) {
                    var error = $root.Msg.Task.verify(message.task[i]);
                    if (error)
                        return "task." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetPlayerAchievementResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetPlayerAchievementResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetPlayerAchievementResp} GetPlayerAchievementResp
         */
        GetPlayerAchievementResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetPlayerAchievementResp)
                return object;
            var message = new $root.Msg.GetPlayerAchievementResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            if (object.task) {
                if (!Array.isArray(object.task))
                    throw TypeError(".Msg.GetPlayerAchievementResp.task: array expected");
                message.task = [];
                for (var i = 0; i < object.task.length; ++i) {
                    if (typeof object.task[i] !== "object")
                        throw TypeError(".Msg.GetPlayerAchievementResp.task: object expected");
                    message.task[i] = $root.Msg.Task.fromObject(object.task[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetPlayerAchievementResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetPlayerAchievementResp
         * @static
         * @param {Msg.GetPlayerAchievementResp} message GetPlayerAchievementResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlayerAchievementResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.task = [];
            if (options.defaults)
                object.result = options.enums === String ? "Internal" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.GetPlayerAchievementResp.Result[message.result] : message.result;
            if (message.task && message.task.length) {
                object.task = [];
                for (var j = 0; j < message.task.length; ++j)
                    object.task[j] = $root.Msg.Task.toObject(message.task[j], options);
            }
            return object;
        };

        /**
         * Converts this GetPlayerAchievementResp to JSON.
         * @function toJSON
         * @memberof Msg.GetPlayerAchievementResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlayerAchievementResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.GetPlayerAchievementResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        GetPlayerAchievementResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return GetPlayerAchievementResp;
    })();

    Msg.GetPlayerDailyReq = (function() {

        /**
         * Properties of a GetPlayerDailyReq.
         * @memberof Msg
         * @interface IGetPlayerDailyReq
         * @property {string|null} [playerID] GetPlayerDailyReq playerID
         */

        /**
         * Constructs a new GetPlayerDailyReq.
         * @memberof Msg
         * @classdesc Represents a GetPlayerDailyReq.
         * @implements IGetPlayerDailyReq
         * @constructor
         * @param {Msg.IGetPlayerDailyReq=} [properties] Properties to set
         */
        function GetPlayerDailyReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlayerDailyReq playerID.
         * @member {string} playerID
         * @memberof Msg.GetPlayerDailyReq
         * @instance
         */
        GetPlayerDailyReq.prototype.playerID = "";

        /**
         * Creates a new GetPlayerDailyReq instance using the specified properties.
         * @function create
         * @memberof Msg.GetPlayerDailyReq
         * @static
         * @param {Msg.IGetPlayerDailyReq=} [properties] Properties to set
         * @returns {Msg.GetPlayerDailyReq} GetPlayerDailyReq instance
         */
        GetPlayerDailyReq.create = function create(properties) {
            return new GetPlayerDailyReq(properties);
        };

        /**
         * Encodes the specified GetPlayerDailyReq message. Does not implicitly {@link Msg.GetPlayerDailyReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetPlayerDailyReq
         * @static
         * @param {Msg.IGetPlayerDailyReq} message GetPlayerDailyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerDailyReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified GetPlayerDailyReq message, length delimited. Does not implicitly {@link Msg.GetPlayerDailyReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetPlayerDailyReq
         * @static
         * @param {Msg.IGetPlayerDailyReq} message GetPlayerDailyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerDailyReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlayerDailyReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetPlayerDailyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetPlayerDailyReq} GetPlayerDailyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerDailyReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetPlayerDailyReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlayerDailyReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetPlayerDailyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetPlayerDailyReq} GetPlayerDailyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerDailyReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlayerDailyReq message.
         * @function verify
         * @memberof Msg.GetPlayerDailyReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlayerDailyReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a GetPlayerDailyReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetPlayerDailyReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetPlayerDailyReq} GetPlayerDailyReq
         */
        GetPlayerDailyReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetPlayerDailyReq)
                return object;
            var message = new $root.Msg.GetPlayerDailyReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a GetPlayerDailyReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetPlayerDailyReq
         * @static
         * @param {Msg.GetPlayerDailyReq} message GetPlayerDailyReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlayerDailyReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playerID = "";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this GetPlayerDailyReq to JSON.
         * @function toJSON
         * @memberof Msg.GetPlayerDailyReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlayerDailyReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetPlayerDailyReq;
    })();

    Msg.GetPlayerDailyResp = (function() {

        /**
         * Properties of a GetPlayerDailyResp.
         * @memberof Msg
         * @interface IGetPlayerDailyResp
         * @property {Msg.GetPlayerDailyResp.Result|null} [result] GetPlayerDailyResp result
         * @property {Array.<Msg.ITask>|null} [task] GetPlayerDailyResp task
         * @property {Msg.IActive|null} [active] GetPlayerDailyResp active
         */

        /**
         * Constructs a new GetPlayerDailyResp.
         * @memberof Msg
         * @classdesc Represents a GetPlayerDailyResp.
         * @implements IGetPlayerDailyResp
         * @constructor
         * @param {Msg.IGetPlayerDailyResp=} [properties] Properties to set
         */
        function GetPlayerDailyResp(properties) {
            this.task = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlayerDailyResp result.
         * @member {Msg.GetPlayerDailyResp.Result} result
         * @memberof Msg.GetPlayerDailyResp
         * @instance
         */
        GetPlayerDailyResp.prototype.result = 0;

        /**
         * GetPlayerDailyResp task.
         * @member {Array.<Msg.ITask>} task
         * @memberof Msg.GetPlayerDailyResp
         * @instance
         */
        GetPlayerDailyResp.prototype.task = $util.emptyArray;

        /**
         * GetPlayerDailyResp active.
         * @member {Msg.IActive|null|undefined} active
         * @memberof Msg.GetPlayerDailyResp
         * @instance
         */
        GetPlayerDailyResp.prototype.active = null;

        /**
         * Creates a new GetPlayerDailyResp instance using the specified properties.
         * @function create
         * @memberof Msg.GetPlayerDailyResp
         * @static
         * @param {Msg.IGetPlayerDailyResp=} [properties] Properties to set
         * @returns {Msg.GetPlayerDailyResp} GetPlayerDailyResp instance
         */
        GetPlayerDailyResp.create = function create(properties) {
            return new GetPlayerDailyResp(properties);
        };

        /**
         * Encodes the specified GetPlayerDailyResp message. Does not implicitly {@link Msg.GetPlayerDailyResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetPlayerDailyResp
         * @static
         * @param {Msg.IGetPlayerDailyResp} message GetPlayerDailyResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerDailyResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.task != null && message.task.length)
                for (var i = 0; i < message.task.length; ++i)
                    $root.Msg.Task.encode(message.task[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.active != null && message.hasOwnProperty("active"))
                $root.Msg.Active.encode(message.active, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetPlayerDailyResp message, length delimited. Does not implicitly {@link Msg.GetPlayerDailyResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetPlayerDailyResp
         * @static
         * @param {Msg.IGetPlayerDailyResp} message GetPlayerDailyResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerDailyResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlayerDailyResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetPlayerDailyResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetPlayerDailyResp} GetPlayerDailyResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerDailyResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetPlayerDailyResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    if (!(message.task && message.task.length))
                        message.task = [];
                    message.task.push($root.Msg.Task.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.active = $root.Msg.Active.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlayerDailyResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetPlayerDailyResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetPlayerDailyResp} GetPlayerDailyResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerDailyResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlayerDailyResp message.
         * @function verify
         * @memberof Msg.GetPlayerDailyResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlayerDailyResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.task != null && message.hasOwnProperty("task")) {
                if (!Array.isArray(message.task))
                    return "task: array expected";
                for (var i = 0; i < message.task.length; ++i) {
                    var error = $root.Msg.Task.verify(message.task[i]);
                    if (error)
                        return "task." + error;
                }
            }
            if (message.active != null && message.hasOwnProperty("active")) {
                var error = $root.Msg.Active.verify(message.active);
                if (error)
                    return "active." + error;
            }
            return null;
        };

        /**
         * Creates a GetPlayerDailyResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetPlayerDailyResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetPlayerDailyResp} GetPlayerDailyResp
         */
        GetPlayerDailyResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetPlayerDailyResp)
                return object;
            var message = new $root.Msg.GetPlayerDailyResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            if (object.task) {
                if (!Array.isArray(object.task))
                    throw TypeError(".Msg.GetPlayerDailyResp.task: array expected");
                message.task = [];
                for (var i = 0; i < object.task.length; ++i) {
                    if (typeof object.task[i] !== "object")
                        throw TypeError(".Msg.GetPlayerDailyResp.task: object expected");
                    message.task[i] = $root.Msg.Task.fromObject(object.task[i]);
                }
            }
            if (object.active != null) {
                if (typeof object.active !== "object")
                    throw TypeError(".Msg.GetPlayerDailyResp.active: object expected");
                message.active = $root.Msg.Active.fromObject(object.active);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetPlayerDailyResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetPlayerDailyResp
         * @static
         * @param {Msg.GetPlayerDailyResp} message GetPlayerDailyResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlayerDailyResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.task = [];
            if (options.defaults) {
                object.result = options.enums === String ? "Internal" : 0;
                object.active = null;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.GetPlayerDailyResp.Result[message.result] : message.result;
            if (message.task && message.task.length) {
                object.task = [];
                for (var j = 0; j < message.task.length; ++j)
                    object.task[j] = $root.Msg.Task.toObject(message.task[j], options);
            }
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = $root.Msg.Active.toObject(message.active, options);
            return object;
        };

        /**
         * Converts this GetPlayerDailyResp to JSON.
         * @function toJSON
         * @memberof Msg.GetPlayerDailyResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlayerDailyResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.GetPlayerDailyResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        GetPlayerDailyResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return GetPlayerDailyResp;
    })();

    Msg.BoxItem = (function() {

        /**
         * Properties of a BoxItem.
         * @memberof Msg
         * @interface IBoxItem
         * @property {string|null} [Type] BoxItem Type
         * @property {number|Long|null} [Number] BoxItem Number
         */

        /**
         * Constructs a new BoxItem.
         * @memberof Msg
         * @classdesc Represents a BoxItem.
         * @implements IBoxItem
         * @constructor
         * @param {Msg.IBoxItem=} [properties] Properties to set
         */
        function BoxItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BoxItem Type.
         * @member {string} Type
         * @memberof Msg.BoxItem
         * @instance
         */
        BoxItem.prototype.Type = "";

        /**
         * BoxItem Number.
         * @member {number|Long} Number
         * @memberof Msg.BoxItem
         * @instance
         */
        BoxItem.prototype.Number = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BoxItem instance using the specified properties.
         * @function create
         * @memberof Msg.BoxItem
         * @static
         * @param {Msg.IBoxItem=} [properties] Properties to set
         * @returns {Msg.BoxItem} BoxItem instance
         */
        BoxItem.create = function create(properties) {
            return new BoxItem(properties);
        };

        /**
         * Encodes the specified BoxItem message. Does not implicitly {@link Msg.BoxItem.verify|verify} messages.
         * @function encode
         * @memberof Msg.BoxItem
         * @static
         * @param {Msg.IBoxItem} message BoxItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BoxItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Type);
            if (message.Number != null && message.hasOwnProperty("Number"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.Number);
            return writer;
        };

        /**
         * Encodes the specified BoxItem message, length delimited. Does not implicitly {@link Msg.BoxItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.BoxItem
         * @static
         * @param {Msg.IBoxItem} message BoxItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BoxItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BoxItem message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.BoxItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.BoxItem} BoxItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BoxItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.BoxItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.string();
                    break;
                case 2:
                    message.Number = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BoxItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.BoxItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.BoxItem} BoxItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BoxItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BoxItem message.
         * @function verify
         * @memberof Msg.BoxItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BoxItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                if (!$util.isString(message.Type))
                    return "Type: string expected";
            if (message.Number != null && message.hasOwnProperty("Number"))
                if (!$util.isInteger(message.Number) && !(message.Number && $util.isInteger(message.Number.low) && $util.isInteger(message.Number.high)))
                    return "Number: integer|Long expected";
            return null;
        };

        /**
         * Creates a BoxItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.BoxItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.BoxItem} BoxItem
         */
        BoxItem.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.BoxItem)
                return object;
            var message = new $root.Msg.BoxItem();
            if (object.Type != null)
                message.Type = String(object.Type);
            if (object.Number != null)
                if ($util.Long)
                    (message.Number = $util.Long.fromValue(object.Number)).unsigned = false;
                else if (typeof object.Number === "string")
                    message.Number = parseInt(object.Number, 10);
                else if (typeof object.Number === "number")
                    message.Number = object.Number;
                else if (typeof object.Number === "object")
                    message.Number = new $util.LongBits(object.Number.low >>> 0, object.Number.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BoxItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.BoxItem
         * @static
         * @param {Msg.BoxItem} message BoxItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BoxItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Type = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.Number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Number = options.longs === String ? "0" : 0;
            }
            if (message.Type != null && message.hasOwnProperty("Type"))
                object.Type = message.Type;
            if (message.Number != null && message.hasOwnProperty("Number"))
                if (typeof message.Number === "number")
                    object.Number = options.longs === String ? String(message.Number) : message.Number;
                else
                    object.Number = options.longs === String ? $util.Long.prototype.toString.call(message.Number) : options.longs === Number ? new $util.LongBits(message.Number.low >>> 0, message.Number.high >>> 0).toNumber() : message.Number;
            return object;
        };

        /**
         * Converts this BoxItem to JSON.
         * @function toJSON
         * @memberof Msg.BoxItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BoxItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BoxItem;
    })();

    Msg.Task = (function() {

        /**
         * Properties of a Task.
         * @memberof Msg
         * @interface ITask
         * @property {string|null} [name] Task name
         * @property {string|null} [show] Task show
         * @property {number|Long|null} [level] Task level
         * @property {number|Long|null} [levelReach] Task levelReach
         * @property {number|Long|null} [grade] Task grade
         * @property {Array.<number|Long>|null} [allLevel] Task allLevel
         * @property {Array.<Msg.IBoxItem>|null} [box] Task box
         * @property {number|Long|null} [order] Task order
         */

        /**
         * Constructs a new Task.
         * @memberof Msg
         * @classdesc Represents a Task.
         * @implements ITask
         * @constructor
         * @param {Msg.ITask=} [properties] Properties to set
         */
        function Task(properties) {
            this.allLevel = [];
            this.box = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Task name.
         * @member {string} name
         * @memberof Msg.Task
         * @instance
         */
        Task.prototype.name = "";

        /**
         * Task show.
         * @member {string} show
         * @memberof Msg.Task
         * @instance
         */
        Task.prototype.show = "";

        /**
         * Task level.
         * @member {number|Long} level
         * @memberof Msg.Task
         * @instance
         */
        Task.prototype.level = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Task levelReach.
         * @member {number|Long} levelReach
         * @memberof Msg.Task
         * @instance
         */
        Task.prototype.levelReach = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Task grade.
         * @member {number|Long} grade
         * @memberof Msg.Task
         * @instance
         */
        Task.prototype.grade = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Task allLevel.
         * @member {Array.<number|Long>} allLevel
         * @memberof Msg.Task
         * @instance
         */
        Task.prototype.allLevel = $util.emptyArray;

        /**
         * Task box.
         * @member {Array.<Msg.IBoxItem>} box
         * @memberof Msg.Task
         * @instance
         */
        Task.prototype.box = $util.emptyArray;

        /**
         * Task order.
         * @member {number|Long} order
         * @memberof Msg.Task
         * @instance
         */
        Task.prototype.order = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Task instance using the specified properties.
         * @function create
         * @memberof Msg.Task
         * @static
         * @param {Msg.ITask=} [properties] Properties to set
         * @returns {Msg.Task} Task instance
         */
        Task.create = function create(properties) {
            return new Task(properties);
        };

        /**
         * Encodes the specified Task message. Does not implicitly {@link Msg.Task.verify|verify} messages.
         * @function encode
         * @memberof Msg.Task
         * @static
         * @param {Msg.ITask} message Task message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Task.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.show != null && message.hasOwnProperty("show"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.show);
            if (message.level != null && message.hasOwnProperty("level"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.level);
            if (message.levelReach != null && message.hasOwnProperty("levelReach"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.levelReach);
            if (message.grade != null && message.hasOwnProperty("grade"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.grade);
            if (message.allLevel != null && message.allLevel.length) {
                writer.uint32(/* id 6, wireType 2 =*/50).fork();
                for (var i = 0; i < message.allLevel.length; ++i)
                    writer.int64(message.allLevel[i]);
                writer.ldelim();
            }
            if (message.box != null && message.box.length)
                for (var i = 0; i < message.box.length; ++i)
                    $root.Msg.BoxItem.encode(message.box[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.order != null && message.hasOwnProperty("order"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.order);
            return writer;
        };

        /**
         * Encodes the specified Task message, length delimited. Does not implicitly {@link Msg.Task.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.Task
         * @static
         * @param {Msg.ITask} message Task message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Task.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Task message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.Task
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.Task} Task
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Task.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.Task();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.show = reader.string();
                    break;
                case 3:
                    message.level = reader.int64();
                    break;
                case 4:
                    message.levelReach = reader.int64();
                    break;
                case 5:
                    message.grade = reader.int64();
                    break;
                case 6:
                    if (!(message.allLevel && message.allLevel.length))
                        message.allLevel = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.allLevel.push(reader.int64());
                    } else
                        message.allLevel.push(reader.int64());
                    break;
                case 7:
                    if (!(message.box && message.box.length))
                        message.box = [];
                    message.box.push($root.Msg.BoxItem.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.order = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Task message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.Task
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.Task} Task
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Task.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Task message.
         * @function verify
         * @memberof Msg.Task
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Task.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.show != null && message.hasOwnProperty("show"))
                if (!$util.isString(message.show))
                    return "show: string expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level) && !(message.level && $util.isInteger(message.level.low) && $util.isInteger(message.level.high)))
                    return "level: integer|Long expected";
            if (message.levelReach != null && message.hasOwnProperty("levelReach"))
                if (!$util.isInteger(message.levelReach) && !(message.levelReach && $util.isInteger(message.levelReach.low) && $util.isInteger(message.levelReach.high)))
                    return "levelReach: integer|Long expected";
            if (message.grade != null && message.hasOwnProperty("grade"))
                if (!$util.isInteger(message.grade) && !(message.grade && $util.isInteger(message.grade.low) && $util.isInteger(message.grade.high)))
                    return "grade: integer|Long expected";
            if (message.allLevel != null && message.hasOwnProperty("allLevel")) {
                if (!Array.isArray(message.allLevel))
                    return "allLevel: array expected";
                for (var i = 0; i < message.allLevel.length; ++i)
                    if (!$util.isInteger(message.allLevel[i]) && !(message.allLevel[i] && $util.isInteger(message.allLevel[i].low) && $util.isInteger(message.allLevel[i].high)))
                        return "allLevel: integer|Long[] expected";
            }
            if (message.box != null && message.hasOwnProperty("box")) {
                if (!Array.isArray(message.box))
                    return "box: array expected";
                for (var i = 0; i < message.box.length; ++i) {
                    var error = $root.Msg.BoxItem.verify(message.box[i]);
                    if (error)
                        return "box." + error;
                }
            }
            if (message.order != null && message.hasOwnProperty("order"))
                if (!$util.isInteger(message.order) && !(message.order && $util.isInteger(message.order.low) && $util.isInteger(message.order.high)))
                    return "order: integer|Long expected";
            return null;
        };

        /**
         * Creates a Task message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.Task
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.Task} Task
         */
        Task.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.Task)
                return object;
            var message = new $root.Msg.Task();
            if (object.name != null)
                message.name = String(object.name);
            if (object.show != null)
                message.show = String(object.show);
            if (object.level != null)
                if ($util.Long)
                    (message.level = $util.Long.fromValue(object.level)).unsigned = false;
                else if (typeof object.level === "string")
                    message.level = parseInt(object.level, 10);
                else if (typeof object.level === "number")
                    message.level = object.level;
                else if (typeof object.level === "object")
                    message.level = new $util.LongBits(object.level.low >>> 0, object.level.high >>> 0).toNumber();
            if (object.levelReach != null)
                if ($util.Long)
                    (message.levelReach = $util.Long.fromValue(object.levelReach)).unsigned = false;
                else if (typeof object.levelReach === "string")
                    message.levelReach = parseInt(object.levelReach, 10);
                else if (typeof object.levelReach === "number")
                    message.levelReach = object.levelReach;
                else if (typeof object.levelReach === "object")
                    message.levelReach = new $util.LongBits(object.levelReach.low >>> 0, object.levelReach.high >>> 0).toNumber();
            if (object.grade != null)
                if ($util.Long)
                    (message.grade = $util.Long.fromValue(object.grade)).unsigned = false;
                else if (typeof object.grade === "string")
                    message.grade = parseInt(object.grade, 10);
                else if (typeof object.grade === "number")
                    message.grade = object.grade;
                else if (typeof object.grade === "object")
                    message.grade = new $util.LongBits(object.grade.low >>> 0, object.grade.high >>> 0).toNumber();
            if (object.allLevel) {
                if (!Array.isArray(object.allLevel))
                    throw TypeError(".Msg.Task.allLevel: array expected");
                message.allLevel = [];
                for (var i = 0; i < object.allLevel.length; ++i)
                    if ($util.Long)
                        (message.allLevel[i] = $util.Long.fromValue(object.allLevel[i])).unsigned = false;
                    else if (typeof object.allLevel[i] === "string")
                        message.allLevel[i] = parseInt(object.allLevel[i], 10);
                    else if (typeof object.allLevel[i] === "number")
                        message.allLevel[i] = object.allLevel[i];
                    else if (typeof object.allLevel[i] === "object")
                        message.allLevel[i] = new $util.LongBits(object.allLevel[i].low >>> 0, object.allLevel[i].high >>> 0).toNumber();
            }
            if (object.box) {
                if (!Array.isArray(object.box))
                    throw TypeError(".Msg.Task.box: array expected");
                message.box = [];
                for (var i = 0; i < object.box.length; ++i) {
                    if (typeof object.box[i] !== "object")
                        throw TypeError(".Msg.Task.box: object expected");
                    message.box[i] = $root.Msg.BoxItem.fromObject(object.box[i]);
                }
            }
            if (object.order != null)
                if ($util.Long)
                    (message.order = $util.Long.fromValue(object.order)).unsigned = false;
                else if (typeof object.order === "string")
                    message.order = parseInt(object.order, 10);
                else if (typeof object.order === "number")
                    message.order = object.order;
                else if (typeof object.order === "object")
                    message.order = new $util.LongBits(object.order.low >>> 0, object.order.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Task message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.Task
         * @static
         * @param {Msg.Task} message Task
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Task.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.allLevel = [];
                object.box = [];
            }
            if (options.defaults) {
                object.name = "";
                object.show = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.level = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.level = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.levelReach = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.levelReach = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.grade = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.grade = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.order = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.order = options.longs === String ? "0" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.show != null && message.hasOwnProperty("show"))
                object.show = message.show;
            if (message.level != null && message.hasOwnProperty("level"))
                if (typeof message.level === "number")
                    object.level = options.longs === String ? String(message.level) : message.level;
                else
                    object.level = options.longs === String ? $util.Long.prototype.toString.call(message.level) : options.longs === Number ? new $util.LongBits(message.level.low >>> 0, message.level.high >>> 0).toNumber() : message.level;
            if (message.levelReach != null && message.hasOwnProperty("levelReach"))
                if (typeof message.levelReach === "number")
                    object.levelReach = options.longs === String ? String(message.levelReach) : message.levelReach;
                else
                    object.levelReach = options.longs === String ? $util.Long.prototype.toString.call(message.levelReach) : options.longs === Number ? new $util.LongBits(message.levelReach.low >>> 0, message.levelReach.high >>> 0).toNumber() : message.levelReach;
            if (message.grade != null && message.hasOwnProperty("grade"))
                if (typeof message.grade === "number")
                    object.grade = options.longs === String ? String(message.grade) : message.grade;
                else
                    object.grade = options.longs === String ? $util.Long.prototype.toString.call(message.grade) : options.longs === Number ? new $util.LongBits(message.grade.low >>> 0, message.grade.high >>> 0).toNumber() : message.grade;
            if (message.allLevel && message.allLevel.length) {
                object.allLevel = [];
                for (var j = 0; j < message.allLevel.length; ++j)
                    if (typeof message.allLevel[j] === "number")
                        object.allLevel[j] = options.longs === String ? String(message.allLevel[j]) : message.allLevel[j];
                    else
                        object.allLevel[j] = options.longs === String ? $util.Long.prototype.toString.call(message.allLevel[j]) : options.longs === Number ? new $util.LongBits(message.allLevel[j].low >>> 0, message.allLevel[j].high >>> 0).toNumber() : message.allLevel[j];
            }
            if (message.box && message.box.length) {
                object.box = [];
                for (var j = 0; j < message.box.length; ++j)
                    object.box[j] = $root.Msg.BoxItem.toObject(message.box[j], options);
            }
            if (message.order != null && message.hasOwnProperty("order"))
                if (typeof message.order === "number")
                    object.order = options.longs === String ? String(message.order) : message.order;
                else
                    object.order = options.longs === String ? $util.Long.prototype.toString.call(message.order) : options.longs === Number ? new $util.LongBits(message.order.low >>> 0, message.order.high >>> 0).toNumber() : message.order;
            return object;
        };

        /**
         * Converts this Task to JSON.
         * @function toJSON
         * @memberof Msg.Task
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Task.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Task;
    })();

    Msg.Active = (function() {

        /**
         * Properties of an Active.
         * @memberof Msg
         * @interface IActive
         * @property {number|Long|null} [current] Active current
         * @property {Object.<string,boolean>|null} [award] Active award
         * @property {Array.<number|Long>|null} [allLevel] Active allLevel
         * @property {Array.<Msg.IBoxItem>|null} [box] Active box
         */

        /**
         * Constructs a new Active.
         * @memberof Msg
         * @classdesc Represents an Active.
         * @implements IActive
         * @constructor
         * @param {Msg.IActive=} [properties] Properties to set
         */
        function Active(properties) {
            this.award = {};
            this.allLevel = [];
            this.box = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Active current.
         * @member {number|Long} current
         * @memberof Msg.Active
         * @instance
         */
        Active.prototype.current = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Active award.
         * @member {Object.<string,boolean>} award
         * @memberof Msg.Active
         * @instance
         */
        Active.prototype.award = $util.emptyObject;

        /**
         * Active allLevel.
         * @member {Array.<number|Long>} allLevel
         * @memberof Msg.Active
         * @instance
         */
        Active.prototype.allLevel = $util.emptyArray;

        /**
         * Active box.
         * @member {Array.<Msg.IBoxItem>} box
         * @memberof Msg.Active
         * @instance
         */
        Active.prototype.box = $util.emptyArray;

        /**
         * Creates a new Active instance using the specified properties.
         * @function create
         * @memberof Msg.Active
         * @static
         * @param {Msg.IActive=} [properties] Properties to set
         * @returns {Msg.Active} Active instance
         */
        Active.create = function create(properties) {
            return new Active(properties);
        };

        /**
         * Encodes the specified Active message. Does not implicitly {@link Msg.Active.verify|verify} messages.
         * @function encode
         * @memberof Msg.Active
         * @static
         * @param {Msg.IActive} message Active message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Active.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.current != null && message.hasOwnProperty("current"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.current);
            if (message.award != null && message.hasOwnProperty("award"))
                for (var keys = Object.keys(message.award), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 0 =*/8).int64(keys[i]).uint32(/* id 2, wireType 0 =*/16).bool(message.award[keys[i]]).ldelim();
            if (message.allLevel != null && message.allLevel.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.allLevel.length; ++i)
                    writer.int64(message.allLevel[i]);
                writer.ldelim();
            }
            if (message.box != null && message.box.length)
                for (var i = 0; i < message.box.length; ++i)
                    $root.Msg.BoxItem.encode(message.box[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Active message, length delimited. Does not implicitly {@link Msg.Active.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.Active
         * @static
         * @param {Msg.IActive} message Active message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Active.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Active message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.Active
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.Active} Active
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Active.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.Active(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.current = reader.int64();
                    break;
                case 2:
                    reader.skip().pos++;
                    if (message.award === $util.emptyObject)
                        message.award = {};
                    key = reader.int64();
                    reader.pos++;
                    message.award[typeof key === "object" ? $util.longToHash(key) : key] = reader.bool();
                    break;
                case 3:
                    if (!(message.allLevel && message.allLevel.length))
                        message.allLevel = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.allLevel.push(reader.int64());
                    } else
                        message.allLevel.push(reader.int64());
                    break;
                case 4:
                    if (!(message.box && message.box.length))
                        message.box = [];
                    message.box.push($root.Msg.BoxItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Active message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.Active
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.Active} Active
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Active.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Active message.
         * @function verify
         * @memberof Msg.Active
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Active.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.current != null && message.hasOwnProperty("current"))
                if (!$util.isInteger(message.current) && !(message.current && $util.isInteger(message.current.low) && $util.isInteger(message.current.high)))
                    return "current: integer|Long expected";
            if (message.award != null && message.hasOwnProperty("award")) {
                if (!$util.isObject(message.award))
                    return "award: object expected";
                var key = Object.keys(message.award);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key64Re.test(key[i]))
                        return "award: integer|Long key{k:int64} expected";
                    if (typeof message.award[key[i]] !== "boolean")
                        return "award: boolean{k:int64} expected";
                }
            }
            if (message.allLevel != null && message.hasOwnProperty("allLevel")) {
                if (!Array.isArray(message.allLevel))
                    return "allLevel: array expected";
                for (var i = 0; i < message.allLevel.length; ++i)
                    if (!$util.isInteger(message.allLevel[i]) && !(message.allLevel[i] && $util.isInteger(message.allLevel[i].low) && $util.isInteger(message.allLevel[i].high)))
                        return "allLevel: integer|Long[] expected";
            }
            if (message.box != null && message.hasOwnProperty("box")) {
                if (!Array.isArray(message.box))
                    return "box: array expected";
                for (var i = 0; i < message.box.length; ++i) {
                    var error = $root.Msg.BoxItem.verify(message.box[i]);
                    if (error)
                        return "box." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Active message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.Active
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.Active} Active
         */
        Active.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.Active)
                return object;
            var message = new $root.Msg.Active();
            if (object.current != null)
                if ($util.Long)
                    (message.current = $util.Long.fromValue(object.current)).unsigned = false;
                else if (typeof object.current === "string")
                    message.current = parseInt(object.current, 10);
                else if (typeof object.current === "number")
                    message.current = object.current;
                else if (typeof object.current === "object")
                    message.current = new $util.LongBits(object.current.low >>> 0, object.current.high >>> 0).toNumber();
            if (object.award) {
                if (typeof object.award !== "object")
                    throw TypeError(".Msg.Active.award: object expected");
                message.award = {};
                for (var keys = Object.keys(object.award), i = 0; i < keys.length; ++i)
                    message.award[keys[i]] = Boolean(object.award[keys[i]]);
            }
            if (object.allLevel) {
                if (!Array.isArray(object.allLevel))
                    throw TypeError(".Msg.Active.allLevel: array expected");
                message.allLevel = [];
                for (var i = 0; i < object.allLevel.length; ++i)
                    if ($util.Long)
                        (message.allLevel[i] = $util.Long.fromValue(object.allLevel[i])).unsigned = false;
                    else if (typeof object.allLevel[i] === "string")
                        message.allLevel[i] = parseInt(object.allLevel[i], 10);
                    else if (typeof object.allLevel[i] === "number")
                        message.allLevel[i] = object.allLevel[i];
                    else if (typeof object.allLevel[i] === "object")
                        message.allLevel[i] = new $util.LongBits(object.allLevel[i].low >>> 0, object.allLevel[i].high >>> 0).toNumber();
            }
            if (object.box) {
                if (!Array.isArray(object.box))
                    throw TypeError(".Msg.Active.box: array expected");
                message.box = [];
                for (var i = 0; i < object.box.length; ++i) {
                    if (typeof object.box[i] !== "object")
                        throw TypeError(".Msg.Active.box: object expected");
                    message.box[i] = $root.Msg.BoxItem.fromObject(object.box[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an Active message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.Active
         * @static
         * @param {Msg.Active} message Active
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Active.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.allLevel = [];
                object.box = [];
            }
            if (options.objects || options.defaults)
                object.award = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.current = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.current = options.longs === String ? "0" : 0;
            if (message.current != null && message.hasOwnProperty("current"))
                if (typeof message.current === "number")
                    object.current = options.longs === String ? String(message.current) : message.current;
                else
                    object.current = options.longs === String ? $util.Long.prototype.toString.call(message.current) : options.longs === Number ? new $util.LongBits(message.current.low >>> 0, message.current.high >>> 0).toNumber() : message.current;
            var keys2;
            if (message.award && (keys2 = Object.keys(message.award)).length) {
                object.award = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.award[keys2[j]] = message.award[keys2[j]];
            }
            if (message.allLevel && message.allLevel.length) {
                object.allLevel = [];
                for (var j = 0; j < message.allLevel.length; ++j)
                    if (typeof message.allLevel[j] === "number")
                        object.allLevel[j] = options.longs === String ? String(message.allLevel[j]) : message.allLevel[j];
                    else
                        object.allLevel[j] = options.longs === String ? $util.Long.prototype.toString.call(message.allLevel[j]) : options.longs === Number ? new $util.LongBits(message.allLevel[j].low >>> 0, message.allLevel[j].high >>> 0).toNumber() : message.allLevel[j];
            }
            if (message.box && message.box.length) {
                object.box = [];
                for (var j = 0; j < message.box.length; ++j)
                    object.box[j] = $root.Msg.BoxItem.toObject(message.box[j], options);
            }
            return object;
        };

        /**
         * Converts this Active to JSON.
         * @function toJSON
         * @memberof Msg.Active
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Active.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Active;
    })();

    Msg.DailyAwardReq = (function() {

        /**
         * Properties of a DailyAwardReq.
         * @memberof Msg
         * @interface IDailyAwardReq
         * @property {string|null} [playerID] DailyAwardReq playerID
         * @property {string|null} [name] DailyAwardReq name
         * @property {number|Long|null} [level] DailyAwardReq level
         */

        /**
         * Constructs a new DailyAwardReq.
         * @memberof Msg
         * @classdesc Represents a DailyAwardReq.
         * @implements IDailyAwardReq
         * @constructor
         * @param {Msg.IDailyAwardReq=} [properties] Properties to set
         */
        function DailyAwardReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DailyAwardReq playerID.
         * @member {string} playerID
         * @memberof Msg.DailyAwardReq
         * @instance
         */
        DailyAwardReq.prototype.playerID = "";

        /**
         * DailyAwardReq name.
         * @member {string} name
         * @memberof Msg.DailyAwardReq
         * @instance
         */
        DailyAwardReq.prototype.name = "";

        /**
         * DailyAwardReq level.
         * @member {number|Long} level
         * @memberof Msg.DailyAwardReq
         * @instance
         */
        DailyAwardReq.prototype.level = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DailyAwardReq instance using the specified properties.
         * @function create
         * @memberof Msg.DailyAwardReq
         * @static
         * @param {Msg.IDailyAwardReq=} [properties] Properties to set
         * @returns {Msg.DailyAwardReq} DailyAwardReq instance
         */
        DailyAwardReq.create = function create(properties) {
            return new DailyAwardReq(properties);
        };

        /**
         * Encodes the specified DailyAwardReq message. Does not implicitly {@link Msg.DailyAwardReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.DailyAwardReq
         * @static
         * @param {Msg.IDailyAwardReq} message DailyAwardReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DailyAwardReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.level != null && message.hasOwnProperty("level"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.level);
            return writer;
        };

        /**
         * Encodes the specified DailyAwardReq message, length delimited. Does not implicitly {@link Msg.DailyAwardReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.DailyAwardReq
         * @static
         * @param {Msg.IDailyAwardReq} message DailyAwardReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DailyAwardReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DailyAwardReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.DailyAwardReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.DailyAwardReq} DailyAwardReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DailyAwardReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.DailyAwardReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.level = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DailyAwardReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.DailyAwardReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.DailyAwardReq} DailyAwardReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DailyAwardReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DailyAwardReq message.
         * @function verify
         * @memberof Msg.DailyAwardReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DailyAwardReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level) && !(message.level && $util.isInteger(message.level.low) && $util.isInteger(message.level.high)))
                    return "level: integer|Long expected";
            return null;
        };

        /**
         * Creates a DailyAwardReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.DailyAwardReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.DailyAwardReq} DailyAwardReq
         */
        DailyAwardReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.DailyAwardReq)
                return object;
            var message = new $root.Msg.DailyAwardReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            if (object.name != null)
                message.name = String(object.name);
            if (object.level != null)
                if ($util.Long)
                    (message.level = $util.Long.fromValue(object.level)).unsigned = false;
                else if (typeof object.level === "string")
                    message.level = parseInt(object.level, 10);
                else if (typeof object.level === "number")
                    message.level = object.level;
                else if (typeof object.level === "object")
                    message.level = new $util.LongBits(object.level.low >>> 0, object.level.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a DailyAwardReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.DailyAwardReq
         * @static
         * @param {Msg.DailyAwardReq} message DailyAwardReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DailyAwardReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerID = "";
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.level = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.level = options.longs === String ? "0" : 0;
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.level != null && message.hasOwnProperty("level"))
                if (typeof message.level === "number")
                    object.level = options.longs === String ? String(message.level) : message.level;
                else
                    object.level = options.longs === String ? $util.Long.prototype.toString.call(message.level) : options.longs === Number ? new $util.LongBits(message.level.low >>> 0, message.level.high >>> 0).toNumber() : message.level;
            return object;
        };

        /**
         * Converts this DailyAwardReq to JSON.
         * @function toJSON
         * @memberof Msg.DailyAwardReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DailyAwardReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DailyAwardReq;
    })();

    Msg.DailyAwardResp = (function() {

        /**
         * Properties of a DailyAwardResp.
         * @memberof Msg
         * @interface IDailyAwardResp
         * @property {Msg.DailyAwardResp.Result|null} [result] DailyAwardResp result
         */

        /**
         * Constructs a new DailyAwardResp.
         * @memberof Msg
         * @classdesc Represents a DailyAwardResp.
         * @implements IDailyAwardResp
         * @constructor
         * @param {Msg.IDailyAwardResp=} [properties] Properties to set
         */
        function DailyAwardResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DailyAwardResp result.
         * @member {Msg.DailyAwardResp.Result} result
         * @memberof Msg.DailyAwardResp
         * @instance
         */
        DailyAwardResp.prototype.result = 0;

        /**
         * Creates a new DailyAwardResp instance using the specified properties.
         * @function create
         * @memberof Msg.DailyAwardResp
         * @static
         * @param {Msg.IDailyAwardResp=} [properties] Properties to set
         * @returns {Msg.DailyAwardResp} DailyAwardResp instance
         */
        DailyAwardResp.create = function create(properties) {
            return new DailyAwardResp(properties);
        };

        /**
         * Encodes the specified DailyAwardResp message. Does not implicitly {@link Msg.DailyAwardResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.DailyAwardResp
         * @static
         * @param {Msg.IDailyAwardResp} message DailyAwardResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DailyAwardResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified DailyAwardResp message, length delimited. Does not implicitly {@link Msg.DailyAwardResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.DailyAwardResp
         * @static
         * @param {Msg.IDailyAwardResp} message DailyAwardResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DailyAwardResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DailyAwardResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.DailyAwardResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.DailyAwardResp} DailyAwardResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DailyAwardResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.DailyAwardResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DailyAwardResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.DailyAwardResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.DailyAwardResp} DailyAwardResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DailyAwardResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DailyAwardResp message.
         * @function verify
         * @memberof Msg.DailyAwardResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DailyAwardResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a DailyAwardResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.DailyAwardResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.DailyAwardResp} DailyAwardResp
         */
        DailyAwardResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.DailyAwardResp)
                return object;
            var message = new $root.Msg.DailyAwardResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a DailyAwardResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.DailyAwardResp
         * @static
         * @param {Msg.DailyAwardResp} message DailyAwardResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DailyAwardResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "Internal" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.DailyAwardResp.Result[message.result] : message.result;
            return object;
        };

        /**
         * Converts this DailyAwardResp to JSON.
         * @function toJSON
         * @memberof Msg.DailyAwardResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DailyAwardResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.DailyAwardResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        DailyAwardResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return DailyAwardResp;
    })();

    Msg.AchievementAwardReq = (function() {

        /**
         * Properties of an AchievementAwardReq.
         * @memberof Msg
         * @interface IAchievementAwardReq
         * @property {string|null} [playerID] AchievementAwardReq playerID
         * @property {string|null} [name] AchievementAwardReq name
         * @property {number|Long|null} [level] AchievementAwardReq level
         */

        /**
         * Constructs a new AchievementAwardReq.
         * @memberof Msg
         * @classdesc Represents an AchievementAwardReq.
         * @implements IAchievementAwardReq
         * @constructor
         * @param {Msg.IAchievementAwardReq=} [properties] Properties to set
         */
        function AchievementAwardReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AchievementAwardReq playerID.
         * @member {string} playerID
         * @memberof Msg.AchievementAwardReq
         * @instance
         */
        AchievementAwardReq.prototype.playerID = "";

        /**
         * AchievementAwardReq name.
         * @member {string} name
         * @memberof Msg.AchievementAwardReq
         * @instance
         */
        AchievementAwardReq.prototype.name = "";

        /**
         * AchievementAwardReq level.
         * @member {number|Long} level
         * @memberof Msg.AchievementAwardReq
         * @instance
         */
        AchievementAwardReq.prototype.level = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AchievementAwardReq instance using the specified properties.
         * @function create
         * @memberof Msg.AchievementAwardReq
         * @static
         * @param {Msg.IAchievementAwardReq=} [properties] Properties to set
         * @returns {Msg.AchievementAwardReq} AchievementAwardReq instance
         */
        AchievementAwardReq.create = function create(properties) {
            return new AchievementAwardReq(properties);
        };

        /**
         * Encodes the specified AchievementAwardReq message. Does not implicitly {@link Msg.AchievementAwardReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.AchievementAwardReq
         * @static
         * @param {Msg.IAchievementAwardReq} message AchievementAwardReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AchievementAwardReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.level != null && message.hasOwnProperty("level"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.level);
            return writer;
        };

        /**
         * Encodes the specified AchievementAwardReq message, length delimited. Does not implicitly {@link Msg.AchievementAwardReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.AchievementAwardReq
         * @static
         * @param {Msg.IAchievementAwardReq} message AchievementAwardReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AchievementAwardReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AchievementAwardReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.AchievementAwardReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.AchievementAwardReq} AchievementAwardReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AchievementAwardReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.AchievementAwardReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.level = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AchievementAwardReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.AchievementAwardReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.AchievementAwardReq} AchievementAwardReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AchievementAwardReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AchievementAwardReq message.
         * @function verify
         * @memberof Msg.AchievementAwardReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AchievementAwardReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level) && !(message.level && $util.isInteger(message.level.low) && $util.isInteger(message.level.high)))
                    return "level: integer|Long expected";
            return null;
        };

        /**
         * Creates an AchievementAwardReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.AchievementAwardReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.AchievementAwardReq} AchievementAwardReq
         */
        AchievementAwardReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.AchievementAwardReq)
                return object;
            var message = new $root.Msg.AchievementAwardReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            if (object.name != null)
                message.name = String(object.name);
            if (object.level != null)
                if ($util.Long)
                    (message.level = $util.Long.fromValue(object.level)).unsigned = false;
                else if (typeof object.level === "string")
                    message.level = parseInt(object.level, 10);
                else if (typeof object.level === "number")
                    message.level = object.level;
                else if (typeof object.level === "object")
                    message.level = new $util.LongBits(object.level.low >>> 0, object.level.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an AchievementAwardReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.AchievementAwardReq
         * @static
         * @param {Msg.AchievementAwardReq} message AchievementAwardReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AchievementAwardReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerID = "";
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.level = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.level = options.longs === String ? "0" : 0;
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.level != null && message.hasOwnProperty("level"))
                if (typeof message.level === "number")
                    object.level = options.longs === String ? String(message.level) : message.level;
                else
                    object.level = options.longs === String ? $util.Long.prototype.toString.call(message.level) : options.longs === Number ? new $util.LongBits(message.level.low >>> 0, message.level.high >>> 0).toNumber() : message.level;
            return object;
        };

        /**
         * Converts this AchievementAwardReq to JSON.
         * @function toJSON
         * @memberof Msg.AchievementAwardReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AchievementAwardReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AchievementAwardReq;
    })();

    Msg.AchievementAwardResp = (function() {

        /**
         * Properties of an AchievementAwardResp.
         * @memberof Msg
         * @interface IAchievementAwardResp
         * @property {Msg.AchievementAwardResp.Result|null} [result] AchievementAwardResp result
         */

        /**
         * Constructs a new AchievementAwardResp.
         * @memberof Msg
         * @classdesc Represents an AchievementAwardResp.
         * @implements IAchievementAwardResp
         * @constructor
         * @param {Msg.IAchievementAwardResp=} [properties] Properties to set
         */
        function AchievementAwardResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AchievementAwardResp result.
         * @member {Msg.AchievementAwardResp.Result} result
         * @memberof Msg.AchievementAwardResp
         * @instance
         */
        AchievementAwardResp.prototype.result = 0;

        /**
         * Creates a new AchievementAwardResp instance using the specified properties.
         * @function create
         * @memberof Msg.AchievementAwardResp
         * @static
         * @param {Msg.IAchievementAwardResp=} [properties] Properties to set
         * @returns {Msg.AchievementAwardResp} AchievementAwardResp instance
         */
        AchievementAwardResp.create = function create(properties) {
            return new AchievementAwardResp(properties);
        };

        /**
         * Encodes the specified AchievementAwardResp message. Does not implicitly {@link Msg.AchievementAwardResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.AchievementAwardResp
         * @static
         * @param {Msg.IAchievementAwardResp} message AchievementAwardResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AchievementAwardResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified AchievementAwardResp message, length delimited. Does not implicitly {@link Msg.AchievementAwardResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.AchievementAwardResp
         * @static
         * @param {Msg.IAchievementAwardResp} message AchievementAwardResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AchievementAwardResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AchievementAwardResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.AchievementAwardResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.AchievementAwardResp} AchievementAwardResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AchievementAwardResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.AchievementAwardResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AchievementAwardResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.AchievementAwardResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.AchievementAwardResp} AchievementAwardResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AchievementAwardResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AchievementAwardResp message.
         * @function verify
         * @memberof Msg.AchievementAwardResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AchievementAwardResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates an AchievementAwardResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.AchievementAwardResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.AchievementAwardResp} AchievementAwardResp
         */
        AchievementAwardResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.AchievementAwardResp)
                return object;
            var message = new $root.Msg.AchievementAwardResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an AchievementAwardResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.AchievementAwardResp
         * @static
         * @param {Msg.AchievementAwardResp} message AchievementAwardResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AchievementAwardResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "Internal" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.AchievementAwardResp.Result[message.result] : message.result;
            return object;
        };

        /**
         * Converts this AchievementAwardResp to JSON.
         * @function toJSON
         * @memberof Msg.AchievementAwardResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AchievementAwardResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.AchievementAwardResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        AchievementAwardResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return AchievementAwardResp;
    })();

    Msg.GetPlayerTreasuresReq = (function() {

        /**
         * Properties of a GetPlayerTreasuresReq.
         * @memberof Msg
         * @interface IGetPlayerTreasuresReq
         * @property {string|null} [playerID] GetPlayerTreasuresReq playerID
         */

        /**
         * Constructs a new GetPlayerTreasuresReq.
         * @memberof Msg
         * @classdesc Represents a GetPlayerTreasuresReq.
         * @implements IGetPlayerTreasuresReq
         * @constructor
         * @param {Msg.IGetPlayerTreasuresReq=} [properties] Properties to set
         */
        function GetPlayerTreasuresReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlayerTreasuresReq playerID.
         * @member {string} playerID
         * @memberof Msg.GetPlayerTreasuresReq
         * @instance
         */
        GetPlayerTreasuresReq.prototype.playerID = "";

        /**
         * Creates a new GetPlayerTreasuresReq instance using the specified properties.
         * @function create
         * @memberof Msg.GetPlayerTreasuresReq
         * @static
         * @param {Msg.IGetPlayerTreasuresReq=} [properties] Properties to set
         * @returns {Msg.GetPlayerTreasuresReq} GetPlayerTreasuresReq instance
         */
        GetPlayerTreasuresReq.create = function create(properties) {
            return new GetPlayerTreasuresReq(properties);
        };

        /**
         * Encodes the specified GetPlayerTreasuresReq message. Does not implicitly {@link Msg.GetPlayerTreasuresReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetPlayerTreasuresReq
         * @static
         * @param {Msg.IGetPlayerTreasuresReq} message GetPlayerTreasuresReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerTreasuresReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            return writer;
        };

        /**
         * Encodes the specified GetPlayerTreasuresReq message, length delimited. Does not implicitly {@link Msg.GetPlayerTreasuresReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetPlayerTreasuresReq
         * @static
         * @param {Msg.IGetPlayerTreasuresReq} message GetPlayerTreasuresReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerTreasuresReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlayerTreasuresReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetPlayerTreasuresReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetPlayerTreasuresReq} GetPlayerTreasuresReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerTreasuresReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetPlayerTreasuresReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlayerTreasuresReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetPlayerTreasuresReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetPlayerTreasuresReq} GetPlayerTreasuresReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerTreasuresReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlayerTreasuresReq message.
         * @function verify
         * @memberof Msg.GetPlayerTreasuresReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlayerTreasuresReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            return null;
        };

        /**
         * Creates a GetPlayerTreasuresReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetPlayerTreasuresReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetPlayerTreasuresReq} GetPlayerTreasuresReq
         */
        GetPlayerTreasuresReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetPlayerTreasuresReq)
                return object;
            var message = new $root.Msg.GetPlayerTreasuresReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            return message;
        };

        /**
         * Creates a plain object from a GetPlayerTreasuresReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetPlayerTreasuresReq
         * @static
         * @param {Msg.GetPlayerTreasuresReq} message GetPlayerTreasuresReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlayerTreasuresReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.playerID = "";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            return object;
        };

        /**
         * Converts this GetPlayerTreasuresReq to JSON.
         * @function toJSON
         * @memberof Msg.GetPlayerTreasuresReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlayerTreasuresReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetPlayerTreasuresReq;
    })();

    Msg.GetPlayerTreasuresResp = (function() {

        /**
         * Properties of a GetPlayerTreasuresResp.
         * @memberof Msg
         * @interface IGetPlayerTreasuresResp
         * @property {Msg.GetPlayerTreasuresResp.Result|null} [result] GetPlayerTreasuresResp result
         * @property {Object.<string,number|Long>|null} [treasures] GetPlayerTreasuresResp treasures
         */

        /**
         * Constructs a new GetPlayerTreasuresResp.
         * @memberof Msg
         * @classdesc Represents a GetPlayerTreasuresResp.
         * @implements IGetPlayerTreasuresResp
         * @constructor
         * @param {Msg.IGetPlayerTreasuresResp=} [properties] Properties to set
         */
        function GetPlayerTreasuresResp(properties) {
            this.treasures = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPlayerTreasuresResp result.
         * @member {Msg.GetPlayerTreasuresResp.Result} result
         * @memberof Msg.GetPlayerTreasuresResp
         * @instance
         */
        GetPlayerTreasuresResp.prototype.result = 0;

        /**
         * GetPlayerTreasuresResp treasures.
         * @member {Object.<string,number|Long>} treasures
         * @memberof Msg.GetPlayerTreasuresResp
         * @instance
         */
        GetPlayerTreasuresResp.prototype.treasures = $util.emptyObject;

        /**
         * Creates a new GetPlayerTreasuresResp instance using the specified properties.
         * @function create
         * @memberof Msg.GetPlayerTreasuresResp
         * @static
         * @param {Msg.IGetPlayerTreasuresResp=} [properties] Properties to set
         * @returns {Msg.GetPlayerTreasuresResp} GetPlayerTreasuresResp instance
         */
        GetPlayerTreasuresResp.create = function create(properties) {
            return new GetPlayerTreasuresResp(properties);
        };

        /**
         * Encodes the specified GetPlayerTreasuresResp message. Does not implicitly {@link Msg.GetPlayerTreasuresResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.GetPlayerTreasuresResp
         * @static
         * @param {Msg.IGetPlayerTreasuresResp} message GetPlayerTreasuresResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerTreasuresResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.treasures != null && message.hasOwnProperty("treasures"))
                for (var keys = Object.keys(message.treasures), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.treasures[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetPlayerTreasuresResp message, length delimited. Does not implicitly {@link Msg.GetPlayerTreasuresResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.GetPlayerTreasuresResp
         * @static
         * @param {Msg.IGetPlayerTreasuresResp} message GetPlayerTreasuresResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPlayerTreasuresResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPlayerTreasuresResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.GetPlayerTreasuresResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.GetPlayerTreasuresResp} GetPlayerTreasuresResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerTreasuresResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.GetPlayerTreasuresResp(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    reader.skip().pos++;
                    if (message.treasures === $util.emptyObject)
                        message.treasures = {};
                    key = reader.string();
                    reader.pos++;
                    message.treasures[key] = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPlayerTreasuresResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.GetPlayerTreasuresResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.GetPlayerTreasuresResp} GetPlayerTreasuresResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPlayerTreasuresResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPlayerTreasuresResp message.
         * @function verify
         * @memberof Msg.GetPlayerTreasuresResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPlayerTreasuresResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.treasures != null && message.hasOwnProperty("treasures")) {
                if (!$util.isObject(message.treasures))
                    return "treasures: object expected";
                var key = Object.keys(message.treasures);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.treasures[key[i]]) && !(message.treasures[key[i]] && $util.isInteger(message.treasures[key[i]].low) && $util.isInteger(message.treasures[key[i]].high)))
                        return "treasures: integer|Long{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a GetPlayerTreasuresResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.GetPlayerTreasuresResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.GetPlayerTreasuresResp} GetPlayerTreasuresResp
         */
        GetPlayerTreasuresResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.GetPlayerTreasuresResp)
                return object;
            var message = new $root.Msg.GetPlayerTreasuresResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            }
            if (object.treasures) {
                if (typeof object.treasures !== "object")
                    throw TypeError(".Msg.GetPlayerTreasuresResp.treasures: object expected");
                message.treasures = {};
                for (var keys = Object.keys(object.treasures), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.treasures[keys[i]] = $util.Long.fromValue(object.treasures[keys[i]])).unsigned = false;
                    else if (typeof object.treasures[keys[i]] === "string")
                        message.treasures[keys[i]] = parseInt(object.treasures[keys[i]], 10);
                    else if (typeof object.treasures[keys[i]] === "number")
                        message.treasures[keys[i]] = object.treasures[keys[i]];
                    else if (typeof object.treasures[keys[i]] === "object")
                        message.treasures[keys[i]] = new $util.LongBits(object.treasures[keys[i]].low >>> 0, object.treasures[keys[i]].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a GetPlayerTreasuresResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.GetPlayerTreasuresResp
         * @static
         * @param {Msg.GetPlayerTreasuresResp} message GetPlayerTreasuresResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPlayerTreasuresResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.treasures = {};
            if (options.defaults)
                object.result = options.enums === String ? "Internal" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.GetPlayerTreasuresResp.Result[message.result] : message.result;
            var keys2;
            if (message.treasures && (keys2 = Object.keys(message.treasures)).length) {
                object.treasures = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.treasures[keys2[j]] === "number")
                        object.treasures[keys2[j]] = options.longs === String ? String(message.treasures[keys2[j]]) : message.treasures[keys2[j]];
                    else
                        object.treasures[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.treasures[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.treasures[keys2[j]].low >>> 0, message.treasures[keys2[j]].high >>> 0).toNumber() : message.treasures[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this GetPlayerTreasuresResp to JSON.
         * @function toJSON
         * @memberof Msg.GetPlayerTreasuresResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPlayerTreasuresResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.GetPlayerTreasuresResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         */
        GetPlayerTreasuresResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            return values;
        })();

        return GetPlayerTreasuresResp;
    })();

    Msg.ExchangeTreasureReq = (function() {

        /**
         * Properties of an ExchangeTreasureReq.
         * @memberof Msg
         * @interface IExchangeTreasureReq
         * @property {string|null} [playerID] ExchangeTreasureReq playerID
         * @property {number|Long|null} [treasureType] ExchangeTreasureReq treasureType
         */

        /**
         * Constructs a new ExchangeTreasureReq.
         * @memberof Msg
         * @classdesc Represents an ExchangeTreasureReq.
         * @implements IExchangeTreasureReq
         * @constructor
         * @param {Msg.IExchangeTreasureReq=} [properties] Properties to set
         */
        function ExchangeTreasureReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangeTreasureReq playerID.
         * @member {string} playerID
         * @memberof Msg.ExchangeTreasureReq
         * @instance
         */
        ExchangeTreasureReq.prototype.playerID = "";

        /**
         * ExchangeTreasureReq treasureType.
         * @member {number|Long} treasureType
         * @memberof Msg.ExchangeTreasureReq
         * @instance
         */
        ExchangeTreasureReq.prototype.treasureType = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExchangeTreasureReq instance using the specified properties.
         * @function create
         * @memberof Msg.ExchangeTreasureReq
         * @static
         * @param {Msg.IExchangeTreasureReq=} [properties] Properties to set
         * @returns {Msg.ExchangeTreasureReq} ExchangeTreasureReq instance
         */
        ExchangeTreasureReq.create = function create(properties) {
            return new ExchangeTreasureReq(properties);
        };

        /**
         * Encodes the specified ExchangeTreasureReq message. Does not implicitly {@link Msg.ExchangeTreasureReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.ExchangeTreasureReq
         * @static
         * @param {Msg.IExchangeTreasureReq} message ExchangeTreasureReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeTreasureReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            if (message.treasureType != null && message.hasOwnProperty("treasureType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.treasureType);
            return writer;
        };

        /**
         * Encodes the specified ExchangeTreasureReq message, length delimited. Does not implicitly {@link Msg.ExchangeTreasureReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.ExchangeTreasureReq
         * @static
         * @param {Msg.IExchangeTreasureReq} message ExchangeTreasureReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeTreasureReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExchangeTreasureReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.ExchangeTreasureReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.ExchangeTreasureReq} ExchangeTreasureReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeTreasureReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.ExchangeTreasureReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                case 2:
                    message.treasureType = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangeTreasureReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.ExchangeTreasureReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.ExchangeTreasureReq} ExchangeTreasureReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeTreasureReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExchangeTreasureReq message.
         * @function verify
         * @memberof Msg.ExchangeTreasureReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExchangeTreasureReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            if (message.treasureType != null && message.hasOwnProperty("treasureType"))
                if (!$util.isInteger(message.treasureType) && !(message.treasureType && $util.isInteger(message.treasureType.low) && $util.isInteger(message.treasureType.high)))
                    return "treasureType: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExchangeTreasureReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.ExchangeTreasureReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.ExchangeTreasureReq} ExchangeTreasureReq
         */
        ExchangeTreasureReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.ExchangeTreasureReq)
                return object;
            var message = new $root.Msg.ExchangeTreasureReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            if (object.treasureType != null)
                if ($util.Long)
                    (message.treasureType = $util.Long.fromValue(object.treasureType)).unsigned = false;
                else if (typeof object.treasureType === "string")
                    message.treasureType = parseInt(object.treasureType, 10);
                else if (typeof object.treasureType === "number")
                    message.treasureType = object.treasureType;
                else if (typeof object.treasureType === "object")
                    message.treasureType = new $util.LongBits(object.treasureType.low >>> 0, object.treasureType.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExchangeTreasureReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.ExchangeTreasureReq
         * @static
         * @param {Msg.ExchangeTreasureReq} message ExchangeTreasureReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExchangeTreasureReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerID = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.treasureType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.treasureType = options.longs === String ? "0" : 0;
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.treasureType != null && message.hasOwnProperty("treasureType"))
                if (typeof message.treasureType === "number")
                    object.treasureType = options.longs === String ? String(message.treasureType) : message.treasureType;
                else
                    object.treasureType = options.longs === String ? $util.Long.prototype.toString.call(message.treasureType) : options.longs === Number ? new $util.LongBits(message.treasureType.low >>> 0, message.treasureType.high >>> 0).toNumber() : message.treasureType;
            return object;
        };

        /**
         * Converts this ExchangeTreasureReq to JSON.
         * @function toJSON
         * @memberof Msg.ExchangeTreasureReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExchangeTreasureReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExchangeTreasureReq;
    })();

    Msg.ExchangeTreasureResp = (function() {

        /**
         * Properties of an ExchangeTreasureResp.
         * @memberof Msg
         * @interface IExchangeTreasureResp
         * @property {Msg.ExchangeTreasureResp.Result|null} [result] ExchangeTreasureResp result
         */

        /**
         * Constructs a new ExchangeTreasureResp.
         * @memberof Msg
         * @classdesc Represents an ExchangeTreasureResp.
         * @implements IExchangeTreasureResp
         * @constructor
         * @param {Msg.IExchangeTreasureResp=} [properties] Properties to set
         */
        function ExchangeTreasureResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangeTreasureResp result.
         * @member {Msg.ExchangeTreasureResp.Result} result
         * @memberof Msg.ExchangeTreasureResp
         * @instance
         */
        ExchangeTreasureResp.prototype.result = 0;

        /**
         * Creates a new ExchangeTreasureResp instance using the specified properties.
         * @function create
         * @memberof Msg.ExchangeTreasureResp
         * @static
         * @param {Msg.IExchangeTreasureResp=} [properties] Properties to set
         * @returns {Msg.ExchangeTreasureResp} ExchangeTreasureResp instance
         */
        ExchangeTreasureResp.create = function create(properties) {
            return new ExchangeTreasureResp(properties);
        };

        /**
         * Encodes the specified ExchangeTreasureResp message. Does not implicitly {@link Msg.ExchangeTreasureResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.ExchangeTreasureResp
         * @static
         * @param {Msg.IExchangeTreasureResp} message ExchangeTreasureResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeTreasureResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified ExchangeTreasureResp message, length delimited. Does not implicitly {@link Msg.ExchangeTreasureResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.ExchangeTreasureResp
         * @static
         * @param {Msg.IExchangeTreasureResp} message ExchangeTreasureResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeTreasureResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExchangeTreasureResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.ExchangeTreasureResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.ExchangeTreasureResp} ExchangeTreasureResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeTreasureResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.ExchangeTreasureResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangeTreasureResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.ExchangeTreasureResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.ExchangeTreasureResp} ExchangeTreasureResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeTreasureResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExchangeTreasureResp message.
         * @function verify
         * @memberof Msg.ExchangeTreasureResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExchangeTreasureResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates an ExchangeTreasureResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.ExchangeTreasureResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.ExchangeTreasureResp} ExchangeTreasureResp
         */
        ExchangeTreasureResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.ExchangeTreasureResp)
                return object;
            var message = new $root.Msg.ExchangeTreasureResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "OK":
            case 1:
                message.result = 1;
                break;
            case "NotEnoughNormalFragment":
            case 2:
                message.result = 2;
                break;
            case "NotEnoughLegendFragment":
            case 3:
                message.result = 3;
                break;
            case "InvalidType":
            case 4:
                message.result = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an ExchangeTreasureResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.ExchangeTreasureResp
         * @static
         * @param {Msg.ExchangeTreasureResp} message ExchangeTreasureResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExchangeTreasureResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "Internal" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.ExchangeTreasureResp.Result[message.result] : message.result;
            return object;
        };

        /**
         * Converts this ExchangeTreasureResp to JSON.
         * @function toJSON
         * @memberof Msg.ExchangeTreasureResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExchangeTreasureResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.ExchangeTreasureResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} OK=1 OK value
         * @property {number} NotEnoughNormalFragment=2 NotEnoughNormalFragment value
         * @property {number} NotEnoughLegendFragment=3 NotEnoughLegendFragment value
         * @property {number} InvalidType=4 InvalidType value
         */
        ExchangeTreasureResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "OK"] = 1;
            values[valuesById[2] = "NotEnoughNormalFragment"] = 2;
            values[valuesById[3] = "NotEnoughLegendFragment"] = 3;
            values[valuesById[4] = "InvalidType"] = 4;
            return values;
        })();

        return ExchangeTreasureResp;
    })();

    Msg.OpenTreasureReq = (function() {

        /**
         * Properties of an OpenTreasureReq.
         * @memberof Msg
         * @interface IOpenTreasureReq
         * @property {string|null} [playerID] OpenTreasureReq playerID
         * @property {number|Long|null} [treasureType] OpenTreasureReq treasureType
         */

        /**
         * Constructs a new OpenTreasureReq.
         * @memberof Msg
         * @classdesc Represents an OpenTreasureReq.
         * @implements IOpenTreasureReq
         * @constructor
         * @param {Msg.IOpenTreasureReq=} [properties] Properties to set
         */
        function OpenTreasureReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpenTreasureReq playerID.
         * @member {string} playerID
         * @memberof Msg.OpenTreasureReq
         * @instance
         */
        OpenTreasureReq.prototype.playerID = "";

        /**
         * OpenTreasureReq treasureType.
         * @member {number|Long} treasureType
         * @memberof Msg.OpenTreasureReq
         * @instance
         */
        OpenTreasureReq.prototype.treasureType = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new OpenTreasureReq instance using the specified properties.
         * @function create
         * @memberof Msg.OpenTreasureReq
         * @static
         * @param {Msg.IOpenTreasureReq=} [properties] Properties to set
         * @returns {Msg.OpenTreasureReq} OpenTreasureReq instance
         */
        OpenTreasureReq.create = function create(properties) {
            return new OpenTreasureReq(properties);
        };

        /**
         * Encodes the specified OpenTreasureReq message. Does not implicitly {@link Msg.OpenTreasureReq.verify|verify} messages.
         * @function encode
         * @memberof Msg.OpenTreasureReq
         * @static
         * @param {Msg.IOpenTreasureReq} message OpenTreasureReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenTreasureReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playerID);
            if (message.treasureType != null && message.hasOwnProperty("treasureType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.treasureType);
            return writer;
        };

        /**
         * Encodes the specified OpenTreasureReq message, length delimited. Does not implicitly {@link Msg.OpenTreasureReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.OpenTreasureReq
         * @static
         * @param {Msg.IOpenTreasureReq} message OpenTreasureReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenTreasureReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenTreasureReq message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.OpenTreasureReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.OpenTreasureReq} OpenTreasureReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenTreasureReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.OpenTreasureReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.playerID = reader.string();
                    break;
                case 2:
                    message.treasureType = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenTreasureReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.OpenTreasureReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.OpenTreasureReq} OpenTreasureReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenTreasureReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenTreasureReq message.
         * @function verify
         * @memberof Msg.OpenTreasureReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenTreasureReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                if (!$util.isString(message.playerID))
                    return "playerID: string expected";
            if (message.treasureType != null && message.hasOwnProperty("treasureType"))
                if (!$util.isInteger(message.treasureType) && !(message.treasureType && $util.isInteger(message.treasureType.low) && $util.isInteger(message.treasureType.high)))
                    return "treasureType: integer|Long expected";
            return null;
        };

        /**
         * Creates an OpenTreasureReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.OpenTreasureReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.OpenTreasureReq} OpenTreasureReq
         */
        OpenTreasureReq.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.OpenTreasureReq)
                return object;
            var message = new $root.Msg.OpenTreasureReq();
            if (object.playerID != null)
                message.playerID = String(object.playerID);
            if (object.treasureType != null)
                if ($util.Long)
                    (message.treasureType = $util.Long.fromValue(object.treasureType)).unsigned = false;
                else if (typeof object.treasureType === "string")
                    message.treasureType = parseInt(object.treasureType, 10);
                else if (typeof object.treasureType === "number")
                    message.treasureType = object.treasureType;
                else if (typeof object.treasureType === "object")
                    message.treasureType = new $util.LongBits(object.treasureType.low >>> 0, object.treasureType.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an OpenTreasureReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.OpenTreasureReq
         * @static
         * @param {Msg.OpenTreasureReq} message OpenTreasureReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OpenTreasureReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.playerID = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.treasureType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.treasureType = options.longs === String ? "0" : 0;
            }
            if (message.playerID != null && message.hasOwnProperty("playerID"))
                object.playerID = message.playerID;
            if (message.treasureType != null && message.hasOwnProperty("treasureType"))
                if (typeof message.treasureType === "number")
                    object.treasureType = options.longs === String ? String(message.treasureType) : message.treasureType;
                else
                    object.treasureType = options.longs === String ? $util.Long.prototype.toString.call(message.treasureType) : options.longs === Number ? new $util.LongBits(message.treasureType.low >>> 0, message.treasureType.high >>> 0).toNumber() : message.treasureType;
            return object;
        };

        /**
         * Converts this OpenTreasureReq to JSON.
         * @function toJSON
         * @memberof Msg.OpenTreasureReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OpenTreasureReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OpenTreasureReq;
    })();

    Msg.OpenTreasureResp = (function() {

        /**
         * Properties of an OpenTreasureResp.
         * @memberof Msg
         * @interface IOpenTreasureResp
         * @property {Msg.OpenTreasureResp.Result|null} [result] OpenTreasureResp result
         * @property {string|null} [info] OpenTreasureResp info
         * @property {number|Long|null} [fashionID] OpenTreasureResp fashionID
         * @property {Object.<string,number|Long>|null} [fragment] OpenTreasureResp fragment
         */

        /**
         * Constructs a new OpenTreasureResp.
         * @memberof Msg
         * @classdesc Represents an OpenTreasureResp.
         * @implements IOpenTreasureResp
         * @constructor
         * @param {Msg.IOpenTreasureResp=} [properties] Properties to set
         */
        function OpenTreasureResp(properties) {
            this.fragment = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpenTreasureResp result.
         * @member {Msg.OpenTreasureResp.Result} result
         * @memberof Msg.OpenTreasureResp
         * @instance
         */
        OpenTreasureResp.prototype.result = 0;

        /**
         * OpenTreasureResp info.
         * @member {string} info
         * @memberof Msg.OpenTreasureResp
         * @instance
         */
        OpenTreasureResp.prototype.info = "";

        /**
         * OpenTreasureResp fashionID.
         * @member {number|Long} fashionID
         * @memberof Msg.OpenTreasureResp
         * @instance
         */
        OpenTreasureResp.prototype.fashionID = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OpenTreasureResp fragment.
         * @member {Object.<string,number|Long>} fragment
         * @memberof Msg.OpenTreasureResp
         * @instance
         */
        OpenTreasureResp.prototype.fragment = $util.emptyObject;

        /**
         * Creates a new OpenTreasureResp instance using the specified properties.
         * @function create
         * @memberof Msg.OpenTreasureResp
         * @static
         * @param {Msg.IOpenTreasureResp=} [properties] Properties to set
         * @returns {Msg.OpenTreasureResp} OpenTreasureResp instance
         */
        OpenTreasureResp.create = function create(properties) {
            return new OpenTreasureResp(properties);
        };

        /**
         * Encodes the specified OpenTreasureResp message. Does not implicitly {@link Msg.OpenTreasureResp.verify|verify} messages.
         * @function encode
         * @memberof Msg.OpenTreasureResp
         * @static
         * @param {Msg.IOpenTreasureResp} message OpenTreasureResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenTreasureResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.info != null && message.hasOwnProperty("info"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.info);
            if (message.fashionID != null && message.hasOwnProperty("fashionID"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.fashionID);
            if (message.fragment != null && message.hasOwnProperty("fragment"))
                for (var keys = Object.keys(message.fragment), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.fragment[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OpenTreasureResp message, length delimited. Does not implicitly {@link Msg.OpenTreasureResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Msg.OpenTreasureResp
         * @static
         * @param {Msg.IOpenTreasureResp} message OpenTreasureResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenTreasureResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenTreasureResp message from the specified reader or buffer.
         * @function decode
         * @memberof Msg.OpenTreasureResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Msg.OpenTreasureResp} OpenTreasureResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenTreasureResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Msg.OpenTreasureResp(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.info = reader.string();
                    break;
                case 3:
                    message.fashionID = reader.int64();
                    break;
                case 4:
                    reader.skip().pos++;
                    if (message.fragment === $util.emptyObject)
                        message.fragment = {};
                    key = reader.string();
                    reader.pos++;
                    message.fragment[key] = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenTreasureResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Msg.OpenTreasureResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Msg.OpenTreasureResp} OpenTreasureResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenTreasureResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenTreasureResp message.
         * @function verify
         * @memberof Msg.OpenTreasureResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenTreasureResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.info != null && message.hasOwnProperty("info"))
                if (!$util.isString(message.info))
                    return "info: string expected";
            if (message.fashionID != null && message.hasOwnProperty("fashionID"))
                if (!$util.isInteger(message.fashionID) && !(message.fashionID && $util.isInteger(message.fashionID.low) && $util.isInteger(message.fashionID.high)))
                    return "fashionID: integer|Long expected";
            if (message.fragment != null && message.hasOwnProperty("fragment")) {
                if (!$util.isObject(message.fragment))
                    return "fragment: object expected";
                var key = Object.keys(message.fragment);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.fragment[key[i]]) && !(message.fragment[key[i]] && $util.isInteger(message.fragment[key[i]].low) && $util.isInteger(message.fragment[key[i]].high)))
                        return "fragment: integer|Long{k:string} expected";
            }
            return null;
        };

        /**
         * Creates an OpenTreasureResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Msg.OpenTreasureResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Msg.OpenTreasureResp} OpenTreasureResp
         */
        OpenTreasureResp.fromObject = function fromObject(object) {
            if (object instanceof $root.Msg.OpenTreasureResp)
                return object;
            var message = new $root.Msg.OpenTreasureResp();
            switch (object.result) {
            case "Internal":
            case 0:
                message.result = 0;
                break;
            case "Success":
            case 1:
                message.result = 1;
                break;
            case "NotEnoughGold":
            case 2:
                message.result = 2;
                break;
            case "NotEnoughDiamond":
            case 3:
                message.result = 3;
                break;
            case "InvalidType":
            case 4:
                message.result = 4;
                break;
            }
            if (object.info != null)
                message.info = String(object.info);
            if (object.fashionID != null)
                if ($util.Long)
                    (message.fashionID = $util.Long.fromValue(object.fashionID)).unsigned = false;
                else if (typeof object.fashionID === "string")
                    message.fashionID = parseInt(object.fashionID, 10);
                else if (typeof object.fashionID === "number")
                    message.fashionID = object.fashionID;
                else if (typeof object.fashionID === "object")
                    message.fashionID = new $util.LongBits(object.fashionID.low >>> 0, object.fashionID.high >>> 0).toNumber();
            if (object.fragment) {
                if (typeof object.fragment !== "object")
                    throw TypeError(".Msg.OpenTreasureResp.fragment: object expected");
                message.fragment = {};
                for (var keys = Object.keys(object.fragment), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.fragment[keys[i]] = $util.Long.fromValue(object.fragment[keys[i]])).unsigned = false;
                    else if (typeof object.fragment[keys[i]] === "string")
                        message.fragment[keys[i]] = parseInt(object.fragment[keys[i]], 10);
                    else if (typeof object.fragment[keys[i]] === "number")
                        message.fragment[keys[i]] = object.fragment[keys[i]];
                    else if (typeof object.fragment[keys[i]] === "object")
                        message.fragment[keys[i]] = new $util.LongBits(object.fragment[keys[i]].low >>> 0, object.fragment[keys[i]].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from an OpenTreasureResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Msg.OpenTreasureResp
         * @static
         * @param {Msg.OpenTreasureResp} message OpenTreasureResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OpenTreasureResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.fragment = {};
            if (options.defaults) {
                object.result = options.enums === String ? "Internal" : 0;
                object.info = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fashionID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fashionID = options.longs === String ? "0" : 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Msg.OpenTreasureResp.Result[message.result] : message.result;
            if (message.info != null && message.hasOwnProperty("info"))
                object.info = message.info;
            if (message.fashionID != null && message.hasOwnProperty("fashionID"))
                if (typeof message.fashionID === "number")
                    object.fashionID = options.longs === String ? String(message.fashionID) : message.fashionID;
                else
                    object.fashionID = options.longs === String ? $util.Long.prototype.toString.call(message.fashionID) : options.longs === Number ? new $util.LongBits(message.fashionID.low >>> 0, message.fashionID.high >>> 0).toNumber() : message.fashionID;
            var keys2;
            if (message.fragment && (keys2 = Object.keys(message.fragment)).length) {
                object.fragment = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.fragment[keys2[j]] === "number")
                        object.fragment[keys2[j]] = options.longs === String ? String(message.fragment[keys2[j]]) : message.fragment[keys2[j]];
                    else
                        object.fragment[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.fragment[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.fragment[keys2[j]].low >>> 0, message.fragment[keys2[j]].high >>> 0).toNumber() : message.fragment[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this OpenTreasureResp to JSON.
         * @function toJSON
         * @memberof Msg.OpenTreasureResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OpenTreasureResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Result enum.
         * @name Msg.OpenTreasureResp.Result
         * @enum {string}
         * @property {number} Internal=0 Internal value
         * @property {number} Success=1 Success value
         * @property {number} NotEnoughGold=2 NotEnoughGold value
         * @property {number} NotEnoughDiamond=3 NotEnoughDiamond value
         * @property {number} InvalidType=4 InvalidType value
         */
        OpenTreasureResp.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Internal"] = 0;
            values[valuesById[1] = "Success"] = 1;
            values[valuesById[2] = "NotEnoughGold"] = 2;
            values[valuesById[3] = "NotEnoughDiamond"] = 3;
            values[valuesById[4] = "InvalidType"] = 4;
            return values;
        })();

        return OpenTreasureResp;
    })();

    return Msg;
})();

module.exports = $root;
